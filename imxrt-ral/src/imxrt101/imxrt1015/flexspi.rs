#![allow(non_snake_case, non_upper_case_globals)]
#![allow(non_camel_case_types)]
//! FlexSPI

use crate::{RORegister, RWRegister, WORegister};
#[cfg(not(feature = "nosync"))]
use core::marker::PhantomData;

/// Module Control Register 0
pub mod MCR0 {

    /// Software Reset
    pub mod SWRESET {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Module Disable
    pub mod MDIS {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sample Clock source selection for Flash Reading
    pub mod RXCLKSRC {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (2 bits: 0b11 << 4)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Dummy Read strobe generated by FlexSPI Controller and loopback internally.
            pub const RXCLKSRC_0: u32 = 0b00;

            /// 0b01: Dummy Read strobe generated by FlexSPI Controller and loopback from DQS pad.
            pub const RXCLKSRC_1: u32 = 0b01;

            /// 0b11: Flash provided Read strobe and input from DQS pad
            pub const RXCLKSRC_3: u32 = 0b11;
        }
    }

    /// Enable AHB bus Read Access to IP RX FIFO.
    pub mod ARDFEN {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP RX FIFO should be read by IP Bus. AHB Bus read access to IP RX FIFO memory space will get bus error response.
            pub const ARDFEN_0: u32 = 0b0;

            /// 0b1: IP RX FIFO should be read by AHB Bus. IP Bus read access to IP RX FIFO memory space will always return data zero but no bus error response.
            pub const ARDFEN_1: u32 = 0b1;
        }
    }

    /// Enable AHB bus Write Access to IP TX FIFO.
    pub mod ATDFEN {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP TX FIFO should be written by IP Bus. AHB Bus write access to IP TX FIFO memory space will get bus error response.
            pub const ATDFEN_0: u32 = 0b0;

            /// 0b1: IP TX FIFO should be written by AHB Bus. IP Bus write access to IP TX FIFO memory space will be ignored but no bus error response.
            pub const ATDFEN_1: u32 = 0b1;
        }
    }

    /// Half Speed Serial Flash access Enable.
    pub mod HSEN {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disable divide by 2 of serial flash clock for half speed commands.
            pub const HSEN_0: u32 = 0b0;

            /// 0b1: Enable divide by 2 of serial flash clock for half speed commands.
            pub const HSEN_1: u32 = 0b1;
        }
    }

    /// Doze mode enable bit
    pub mod DOZEEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Doze mode support disabled. AHB clock and serial clock will not be gated off when there is doze mode request from system.
            pub const DOZEEN_0: u32 = 0b0;

            /// 0b1: Doze mode support enabled. AHB clock and serial clock will be gated off when there is doze mode request from system.
            pub const DOZEEN_1: u32 = 0b1;
        }
    }

    /// This bit is to support Flash Octal mode access by combining Port A and B Data pins (SIOA\[3:0\] and SIOB\[3:0\]).
    pub mod COMBINATIONEN {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disable.
            pub const COMBINATIONEN_0: u32 = 0b0;

            /// 0b1: Enable.
            pub const COMBINATIONEN_1: u32 = 0b1;
        }
    }

    /// This bit is used to force SCK output free-running. For FPGA applications, external device may use SCK clock as reference clock to its internal PLL. If SCK free-running is enabled, data sampling with loopback clock from SCK pad is not supported (MCR0\[RXCLKSRC\]=2).
    pub mod SCKFREERUNEN {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disable.
            pub const SCKFREERUNEN_0: u32 = 0b0;

            /// 0b1: Enable.
            pub const SCKFREERUNEN_1: u32 = 0b1;
        }
    }

    /// Time out wait cycle for IP command grant.
    pub mod IPGRANTWAIT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Timeout wait cycle for AHB command grant.
    pub mod AHBGRANTWAIT {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Module Control Register 1
pub mod MCR1 {

    /// AHB Read/Write access to Serial Flash Memory space will timeout if not data received from Flash or data not transmited after AHBBUSWAIT * 1024 ahb clock cycles, AHB Bus will get an error response
    pub mod AHBBUSWAIT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Command Sequence Execution will timeout and abort after SEQWAIT * 1024 Serial Root Clock cycles
    pub mod SEQWAIT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Module Control Register 2
pub mod MCR2 {

    /// This bit determines whether AHB RX Buffer and AHB TX Buffer will be cleaned automaticaly when FlexSPI returns STOP mode ACK. Software should set this bit if AHB RX Buffer or AHB TX Buffer will be powered off in STOP mode. Otherwise AHB read access after exiting STOP mode may hit AHB RX Buffer or AHB TX Buffer but their data entries are invalid.
    pub mod CLRAHBBUFOPT {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: AHB RX/TX Buffer will not be cleaned automatically when FlexSPI return Stop mode ACK.
            pub const CLRAHBBUFOPT_0: u32 = 0b0;

            /// 0b1: AHB RX/TX Buffer will be cleaned automatically when FlexSPI return Stop mode ACK.
            pub const CLRAHBBUFOPT_1: u32 = 0b1;
        }
    }

    /// The sampling clock phase selection will be reset to phase 0 when this bit is written with 0x1. This bit will be auto-cleared immediately.
    pub mod CLRLEARNPHASE {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// All external devices are same devices (both in types and size) for A1/A2/B1/B2.
    pub mod SAMEDEVICEEN {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: In Individual mode, FLSHA1CRx/FLSHA2CRx/FLSHB1CRx/FLSHB2CRx register setting will be applied to Flash A1/A2/B1/B2 seperately. In Parallel mode, FLSHA1CRx register setting will be applied to Flash A1 and B1, FLSHA2CRx register setting will be applied to Flash A2 and B2. FLSHB1CRx/FLSHB2CRx register settings will be ignored.
            pub const SAMEDEVICEEN_0: u32 = 0b0;

            /// 0b1: FLSHA1CR0/FLSHA1CR1/FLSHA1CR2 register settings will be applied to Flash A1/A2/B1/B2. FLSHA2CRx/FLSHB1CRx/FLSHB2CRx will be ignored.
            pub const SAMEDEVICEEN_1: u32 = 0b1;
        }
    }

    /// SCKB pad can be used as SCKA differential clock output (inverted clock to SCKA). In this case, port B flash access is not available. After change the value of this feild, MCR0\[SWRESET\] should be set.
    pub mod SCKBDIFFOPT {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: SCKB pad is used as port B SCK clock output. Port B flash access is available.
            pub const SCKBDIFFOPT_0: u32 = 0b0;

            /// 0b1: SCKB pad is used as port A SCK inverted clock output (Differential clock to SCKA). Port B flash access is not available.
            pub const SCKBDIFFOPT_1: u32 = 0b1;
        }
    }

    /// Wait cycle (in AHB clock cycle) for idle state before suspended command sequence resumed.
    pub mod RESUMEWAIT {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB Bus Control Register
pub mod AHBCR {

    /// Parallel mode enabled for AHB triggered Command (both read and write) .
    pub mod APAREN {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Flash will be accessed in Individual mode.
            pub const APAREN_0: u32 = 0b0;

            /// 0b1: Flash will be accessed in Parallel mode.
            pub const APAREN_1: u32 = 0b1;
        }
    }

    /// Enable AHB bus cachable read access support.
    pub mod CACHABLEEN {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disabled. When there is AHB bus cachable read access, FlexSPI will not check whether it hit AHB TX Buffer.
            pub const CACHABLEEN_0: u32 = 0b0;

            /// 0b1: Enabled. When there is AHB bus cachable read access, FlexSPI will check whether it hit AHB TX Buffer first.
            pub const CACHABLEEN_1: u32 = 0b1;
        }
    }

    /// Enable AHB bus bufferable write access support. This field affects the last beat of AHB write access, refer for more details about AHB bufferable write.
    pub mod BUFFERABLEEN {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Disabled. For all AHB write access (no matter bufferable or non-bufferable ), FlexSPI will return AHB Bus ready after all data is transmitted to External device and AHB command finished.
            pub const BUFFERABLEEN_0: u32 = 0b0;

            /// 0b1: Enabled. For AHB bufferable write access, FlexSPI will return AHB Bus ready when the AHB command is granted by arbitrator and will not wait for AHB command finished.
            pub const BUFFERABLEEN_1: u32 = 0b1;
        }
    }

    /// AHB Read Prefetch Enable.
    pub mod PREFETCHEN {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Read Address option bit. This option bit is intend to remove AHB burst start address alignment limitation.
    pub mod READADDROPT {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: There is AHB read burst start address alignment limitation when flash is accessed in parallel mode or flash is wordaddressable.
            pub const READADDROPT_0: u32 = 0b0;

            /// 0b1: There is no AHB read burst start address alignment limitation. FlexSPI will fetch more datas than AHB burst required to meet the alignment requirement.
            pub const READADDROPT_1: u32 = 0b1;
        }
    }
}

/// Interrupt Enable Register
pub mod INTEN {

    /// IP triggered Command Sequences Execution finished interrupt enable.
    pub mod IPCMDDONEEN {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Grant Timeout interrupt enable.
    pub mod IPCMDGEEN {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Grant Timeout interrupt enable.
    pub mod AHBCMDGEEN {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Error Detected interrupt enable.
    pub mod IPCMDERREN {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Error Detected interrupt enable.
    pub mod AHBCMDERREN {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP RX FIFO WaterMark available interrupt enable.
    pub mod IPRXWAEN {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP TX FIFO WaterMark empty interrupt enable.
    pub mod IPTXWEEN {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCK is stopped during command sequence because Async RX FIFO full interrupt enable.
    pub mod SCKSTOPBYRDEN {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCK is stopped during command sequence because Async TX FIFO empty interrupt enable.
    pub mod SCKSTOPBYWREN {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (1 bit: 1 << 9)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
    pub mod AHBBUSTIMEOUTEN {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence execution timeout interrupt enable.Refer Interrupts chapter for more details.
    pub mod SEQTIMEOUTEN {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Register
pub mod INTR {

    /// IP triggered Command Sequences Execution finished interrupt. This interrupt is also generated when there is IPCMDGE or IPCMDERR interrupt generated.
    pub mod IPCMDDONE {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Grant Timeout interrupt.
    pub mod IPCMDGE {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Grant Timeout interrupt.
    pub mod AHBCMDGE {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP triggered Command Sequences Error Detected interrupt. When an error detected for IP command, this command will be ignored and not executed at all.
    pub mod IPCMDERR {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB triggered Command Sequences Error Detected interrupt. When an error detected for AHB command, this command will be ignored and not executed at all.
    pub mod AHBCMDERR {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP RX FIFO watermark available interrupt.
    pub mod IPRXWA {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP TX FIFO watermark empty interrupt.
    pub mod IPTXWE {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCK is stopped during command sequence because Async RX FIFO full interrupt.
    pub mod SCKSTOPBYRD {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// SCK is stopped during command sequence because Async TX FIFO empty interrupt.
    pub mod SCKSTOPBYWR {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (1 bit: 1 << 9)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Bus timeout interrupt.Refer Interrupts chapter for more details.
    pub mod AHBBUSTIMEOUT {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence execution timeout interrupt.
    pub mod SEQTIMEOUT {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// LUT Key Register
pub mod LUTKEY {

    /// The Key to lock or unlock LUT.
    pub mod KEY {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// LUT Control Register
pub mod LUTCR {

    /// Lock LUT
    pub mod LOCK {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Unlock LUT
    pub mod UNLOCK {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB RX Buffer 0 Control Register 0
pub mod AHBRXBUF0CR0 {

    /// AHB RX Buffer Size in 64 bits.Refer AHB RX Buffer Management for more details.
    pub mod BUFSZ {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This AHB RX Buffer is assigned according to AHB Master with ID (MSTR_ID). Please refer to for AHB RX Buffer allocation.
    pub mod MSTRID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This priority for AHB Master Read which this AHB RX Buffer is assigned. Refer for more details.
    pub mod PRIORITY {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (2 bits: 0b11 << 24)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB Read Prefetch Enable for current AHB RX Buffer corresponding Master.
    pub mod PREFETCHEN {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB RX Buffer 1 Control Register 0
pub mod AHBRXBUF1CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
}

/// AHB RX Buffer 2 Control Register 0
pub mod AHBRXBUF2CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
}

/// AHB RX Buffer 3 Control Register 0
pub mod AHBRXBUF3CR0 {
    pub use super::AHBRXBUF0CR0::BUFSZ;
    pub use super::AHBRXBUF0CR0::MSTRID;
    pub use super::AHBRXBUF0CR0::PREFETCHEN;
    pub use super::AHBRXBUF0CR0::PRIORITY;
}

/// Flash A1 Control Register 0
pub mod FLSHA1CR0 {

    /// Flash Size in KByte.
    pub mod FLSHSZ {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (23 bits: 0x7fffff << 0)
        pub const mask: u32 = 0x7fffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Flash A2 Control Register 0
pub mod FLSHA2CR0 {
    pub use super::FLSHA1CR0::FLSHSZ;
}

/// Flash B1 Control Register 0
pub mod FLSHB1CR0 {
    pub use super::FLSHA1CR0::FLSHSZ;
}

/// Flash B2 Control Register 0
pub mod FLSHB2CR0 {
    pub use super::FLSHA1CR0::FLSHSZ;
}

/// Flash A1 Control Register 1
pub mod FLSHCR1A1 {

    /// Serial Flash CS setup time.
    pub mod TCSS {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Serial Flash CS Hold time.
    pub mod TCSH {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (5 bits: 0b11111 << 5)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Word Addressable.
    pub mod WA {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Column Address Size.
    pub mod CAS {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (4 bits: 0b1111 << 11)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// CS interval unit
    pub mod CSINTERVALUNIT {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The CS interval unit is 1 serial clock cycle
            pub const CSINTERVALUNIT_0: u32 = 0b0;

            /// 0b1: The CS interval unit is 256 serial clock cycle
            pub const CSINTERVALUNIT_1: u32 = 0b1;
        }
    }

    /// This field is used to set the minimum interval between flash device Chip selection deassertion and flash device Chip selection assertion. If external flash has a limitation on the interval between command sequences, this field should be set accordingly. If there is no limitation, set this field with value 0x0.
    pub mod CSINTERVAL {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Flash A1 Control Register 1
pub mod FLSHCR1A2 {
    pub use super::FLSHCR1A1::CAS;
    pub use super::FLSHCR1A1::CSINTERVAL;
    pub use super::FLSHCR1A1::CSINTERVALUNIT;
    pub use super::FLSHCR1A1::TCSH;
    pub use super::FLSHCR1A1::TCSS;
    pub use super::FLSHCR1A1::WA;
}

/// Flash A1 Control Register 1
pub mod FLSHCR1B1 {
    pub use super::FLSHCR1A1::CAS;
    pub use super::FLSHCR1A1::CSINTERVAL;
    pub use super::FLSHCR1A1::CSINTERVALUNIT;
    pub use super::FLSHCR1A1::TCSH;
    pub use super::FLSHCR1A1::TCSS;
    pub use super::FLSHCR1A1::WA;
}

/// Flash A1 Control Register 1
pub mod FLSHCR1B2 {
    pub use super::FLSHCR1A1::CAS;
    pub use super::FLSHCR1A1::CSINTERVAL;
    pub use super::FLSHCR1A1::CSINTERVALUNIT;
    pub use super::FLSHCR1A1::TCSH;
    pub use super::FLSHCR1A1::TCSS;
    pub use super::FLSHCR1A1::WA;
}

/// Flash A1 Control Register 2
pub mod FLSHCR2A1 {

    /// Sequence Index for AHB Read triggered Command in LUT.
    pub mod ARDSEQID {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (4 bits: 0b1111 << 0)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Number for AHB Read triggered Command in LUT.
    pub mod ARDSEQNUM {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (3 bits: 0b111 << 5)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Index for AHB Write triggered Command.
    pub mod AWRSEQID {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (4 bits: 0b1111 << 8)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Number for AHB Write triggered Command.
    pub mod AWRSEQNUM {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (3 bits: 0b111 << 13)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// For certain devices (such as FPGA), it need some time to write data into internal memory after the command sequences finished on FlexSPI interface
    pub mod AWRWAIT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (12 bits: 0xfff << 16)
        pub const mask: u32 = 0xfff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AWRWAIT unit
    pub mod AWRWAITUNIT {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (3 bits: 0b111 << 28)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b000: The AWRWAIT unit is 2 ahb clock cycle
            pub const AWRWAITUNIT_0: u32 = 0b000;

            /// 0b001: The AWRWAIT unit is 8 ahb clock cycle
            pub const AWRWAITUNIT_1: u32 = 0b001;

            /// 0b010: The AWRWAIT unit is 32 ahb clock cycle
            pub const AWRWAITUNIT_2: u32 = 0b010;

            /// 0b011: The AWRWAIT unit is 128 ahb clock cycle
            pub const AWRWAITUNIT_3: u32 = 0b011;

            /// 0b100: The AWRWAIT unit is 512 ahb clock cycle
            pub const AWRWAITUNIT_4: u32 = 0b100;

            /// 0b101: The AWRWAIT unit is 2048 ahb clock cycle
            pub const AWRWAITUNIT_5: u32 = 0b101;

            /// 0b110: The AWRWAIT unit is 8192 ahb clock cycle
            pub const AWRWAITUNIT_6: u32 = 0b110;

            /// 0b111: The AWRWAIT unit is 32768 ahb clock cycle
            pub const AWRWAITUNIT_7: u32 = 0b111;
        }
    }

    /// Clear the instruction pointer which is internally saved pointer by JMP_ON_CS. Refer Programmable Sequence Engine for details.
    pub mod CLRINSTRPTR {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Flash A1 Control Register 2
pub mod FLSHCR2A2 {
    pub use super::FLSHCR2A1::ARDSEQID;
    pub use super::FLSHCR2A1::ARDSEQNUM;
    pub use super::FLSHCR2A1::AWRSEQID;
    pub use super::FLSHCR2A1::AWRSEQNUM;
    pub use super::FLSHCR2A1::AWRWAIT;
    pub use super::FLSHCR2A1::AWRWAITUNIT;
    pub use super::FLSHCR2A1::CLRINSTRPTR;
}

/// Flash A1 Control Register 2
pub mod FLSHCR2B1 {
    pub use super::FLSHCR2A1::ARDSEQID;
    pub use super::FLSHCR2A1::ARDSEQNUM;
    pub use super::FLSHCR2A1::AWRSEQID;
    pub use super::FLSHCR2A1::AWRSEQNUM;
    pub use super::FLSHCR2A1::AWRWAIT;
    pub use super::FLSHCR2A1::AWRWAITUNIT;
    pub use super::FLSHCR2A1::CLRINSTRPTR;
}

/// Flash A1 Control Register 2
pub mod FLSHCR2B2 {
    pub use super::FLSHCR2A1::ARDSEQID;
    pub use super::FLSHCR2A1::ARDSEQNUM;
    pub use super::FLSHCR2A1::AWRSEQID;
    pub use super::FLSHCR2A1::AWRSEQNUM;
    pub use super::FLSHCR2A1::AWRWAIT;
    pub use super::FLSHCR2A1::AWRWAITUNIT;
    pub use super::FLSHCR2A1::CLRINSTRPTR;
}

/// Flash Control Register 4
pub mod FLSHCR4 {

    /// Write mask option bit 1. This option bit could be used to remove AHB write burst start address alignment limitation.
    pub mod WMOPT1 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: DQS pin will be used as Write Mask when writing to external device. There is no limitation on AHB write burst start address alignment when flash is accessed in individual mode.
            pub const WMOPT1_0: u32 = 0b0;

            /// 0b1: DQS pin will not be used as Write Mask when writing to external device. There is limitation on AHB write burst start address alignment when flash is accessed in individual mode.
            pub const WMOPT1_1: u32 = 0b1;
        }
    }

    /// Write mask enable bit for flash device on port A. When write mask function is needed for memory device on port A, this bit must be set.
    pub mod WMENA {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
            pub const WMENA_0: u32 = 0b0;

            /// 0b1: Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
            pub const WMENA_1: u32 = 0b1;
        }
    }

    /// Write mask enable bit for flash device on port B. When write mask function is needed for memory device on port B, this bit must be set.
    pub mod WMENB {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Write mask is disabled, DQS(RWDS) pin will be un-driven when writing to external device.
            pub const WMENB_0: u32 = 0b0;

            /// 0b1: Write mask is enabled, DQS(RWDS) pin will be driven by FlexSPI as write mask output when writing to external device.
            pub const WMENB_1: u32 = 0b1;
        }
    }
}

/// IP Control Register 0
pub mod IPCR0 {

    /// Serial Flash Address for IP command.
    pub mod SFAR {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP Control Register 1
pub mod IPCR1 {

    /// Flash Read/Program Data Size (in Bytes) for IP command.
    pub mod IDATSZ {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Index in LUT for IP command.
    pub mod ISEQID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Sequence Number for IP command: ISEQNUM+1.
    pub mod ISEQNUM {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (3 bits: 0b111 << 24)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Parallel mode Enabled for IP command.
    pub mod IPAREN {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Flash will be accessed in Individual mode.
            pub const IPAREN_0: u32 = 0b0;

            /// 0b1: Flash will be accessed in Parallel mode.
            pub const IPAREN_1: u32 = 0b1;
        }
    }
}

/// IP Command Register
pub mod IPCMD {

    /// Setting this bit will trigger an IP Command.
    pub mod TRG {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Control Register
pub mod IPRXFCR {

    /// Clear all valid data entries in IP RX FIFO.
    pub mod CLRIPRXF {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP RX FIFO reading by DMA enabled.
    pub mod RXDMAEN {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP RX FIFO would be read by processor.
            pub const RXDMAEN_0: u32 = 0b0;

            /// 0b1: IP RX FIFO would be read by DMA.
            pub const RXDMAEN_1: u32 = 0b1;
        }
    }

    /// Watermark level is (RXWMRK+1)*64 Bits.
    pub mod RXWMRK {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (4 bits: 0b1111 << 2)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP TX FIFO Control Register
pub mod IPTXFCR {

    /// Clear all valid data entries in IP TX FIFO.
    pub mod CLRIPTXF {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// IP TX FIFO filling by DMA enabled.
    pub mod TXDMAEN {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: IP TX FIFO would be filled by processor.
            pub const TXDMAEN_0: u32 = 0b0;

            /// 0b1: IP TX FIFO would be filled by DMA.
            pub const TXDMAEN_1: u32 = 0b1;
        }
    }

    /// Watermark level is (TXWMRK+1)*64 Bits.
    pub mod TXWMRK {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (4 bits: 0b1111 << 2)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// DLL Control Register 0
pub mod DLLCRA {

    /// DLL calibration enable.
    pub mod DLLEN {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Software could force a reset on DLL by setting this field to 0x1. This will cause the DLL to lose lock and re-calibrate to detect an ref_clock half period phase shift. The reset action is edge triggered, so software need to clear this bit after set this bit (no delay limitation).
    pub mod DLLRESET {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// The delay target for slave delay line is: ((SLVDLYTARGET+1) * 1/32 * clock cycle of reference clock (serial clock).
    pub mod SLVDLYTARGET {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (4 bits: 0b1111 << 3)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Slave clock delay line delay cell number selection override enable.
    pub mod OVRDEN {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Slave clock delay line delay cell number selection override value.
    pub mod OVRDVAL {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (6 bits: 0x3f << 9)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// DLL Control Register 0
pub mod DLLCRB {
    pub use super::DLLCRA::DLLEN;
    pub use super::DLLCRA::DLLRESET;
    pub use super::DLLCRA::OVRDEN;
    pub use super::DLLCRA::OVRDVAL;
    pub use super::DLLCRA::SLVDLYTARGET;
}

/// Status Register 0
pub mod STS0 {

    /// This status bit indicates the state machine in SEQ_CTL is idle and there is command sequence executing on FlexSPI interface.
    pub mod SEQIDLE {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This status bit indicates the state machine in ARB_CTL is busy and there is command sequence granted by arbitrator and not finished yet on FlexSPI interface. When ARB_CTL state (ARBIDLE=0x1) is idle, there will be no transaction on FlexSPI interface also (SEQIDLE=0x1). So this bit should be polled to wait for FlexSPI controller become idle instead of SEQIDLE.
    pub mod ARBIDLE {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// This status field indicates the trigger source of current command sequence granted by arbitrator. This field value is meaningless when ARB_CTL is not busy (STS0\[ARBIDLE\]=0x1).
    pub mod ARBCMDSRC {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (2 bits: 0b11 << 2)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Triggered by AHB read command (triggered by AHB read).
            pub const ARBCMDSRC_0: u32 = 0b00;

            /// 0b01: Triggered by AHB write command (triggered by AHB Write).
            pub const ARBCMDSRC_1: u32 = 0b01;

            /// 0b10: Triggered by IP command (triggered by setting register bit IPCMD.TRG).
            pub const ARBCMDSRC_2: u32 = 0b10;

            /// 0b11: Triggered by suspended command (resumed).
            pub const ARBCMDSRC_3: u32 = 0b11;
        }
    }
}

/// Status Register 1
pub mod STS1 {

    /// Indicates the sequence index when an AHB command error is detected. This field will be cleared when INTR\[AHBCMDERR\] is write-1-clear(w1c).
    pub mod AHBCMDERRID {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (4 bits: 0b1111 << 0)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Indicates the Error Code when AHB command Error detected. This field will be cleared when INTR\[AHBCMDERR\] is write-1-clear(w1c).
    pub mod AHBCMDERRCODE {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (4 bits: 0b1111 << 8)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0000: No error.
            pub const AHBCMDERRCODE_0: u32 = 0b0000;

            /// 0b0010: AHB Write command with JMP_ON_CS instruction used in the sequence.
            pub const AHBCMDERRCODE_2: u32 = 0b0010;

            /// 0b0011: There is unknown instruction opcode in the sequence.
            pub const AHBCMDERRCODE_3: u32 = 0b0011;

            /// 0b0100: Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
            pub const AHBCMDERRCODE_4: u32 = 0b0100;

            /// 0b0101: Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
            pub const AHBCMDERRCODE_5: u32 = 0b0101;

            /// 0b1110: Sequence execution timeout.
            pub const AHBCMDERRCODE_14: u32 = 0b1110;
        }
    }

    /// Indicates the sequence Index when IP command error detected. This field will be cleared when INTR\[IPCMDERR\] is write-1-clear(w1c).
    pub mod IPCMDERRID {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Indicates the Error Code when IP command Error detected. This field will be cleared when INTR\[IPCMDERR\] is write-1-clear(w1c).
    pub mod IPCMDERRCODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0000: No error.
            pub const IPCMDERRCODE_0: u32 = 0b0000;

            /// 0b0010: IP command with JMP_ON_CS instruction used in the sequence.
            pub const IPCMDERRCODE_2: u32 = 0b0010;

            /// 0b0011: There is unknown instruction opcode in the sequence.
            pub const IPCMDERRCODE_3: u32 = 0b0011;

            /// 0b0100: Instruction DUMMY_SDR/DUMMY_RWDS_SDR used in DDR sequence.
            pub const IPCMDERRCODE_4: u32 = 0b0100;

            /// 0b0101: Instruction DUMMY_DDR/DUMMY_RWDS_DDR used in SDR sequence.
            pub const IPCMDERRCODE_5: u32 = 0b0101;

            /// 0b0110: Flash access start address exceed the whole flash address range (A1/A2/B1/B2).
            pub const IPCMDERRCODE_6: u32 = 0b0110;

            /// 0b1110: Sequence execution timeout.
            pub const IPCMDERRCODE_14: u32 = 0b1110;

            /// 0b1111: Flash boundary crossed.
            pub const IPCMDERRCODE_15: u32 = 0b1111;
        }
    }
}

/// Status Register 2
pub mod STS2 {

    /// Flash A sample clock slave delay line locked.
    pub mod ASLVLOCK {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash A sample clock reference delay line locked.
    pub mod AREFLOCK {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash A sample clock slave delay line delay cell number selection .
    pub mod ASLVSEL {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (6 bits: 0x3f << 2)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash A sample clock reference delay line delay cell number selection.
    pub mod AREFSEL {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (6 bits: 0x3f << 8)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock slave delay line locked.
    pub mod BSLVLOCK {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock reference delay line locked.
    pub mod BREFLOCK {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock slave delay line delay cell number selection.
    pub mod BSLVSEL {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (6 bits: 0x3f << 18)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Flash B sample clock reference delay line delay cell number selection.
    pub mod BREFSEL {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (6 bits: 0x3f << 24)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// AHB Suspend Status Register
pub mod AHBSPNDSTS {

    /// Indicates if an AHB read prefetch command sequence has been suspended.
    pub mod ACTIVE {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// AHB RX BUF ID for suspended command sequence.
    pub mod BUFID {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (3 bits: 0b111 << 1)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Left Data size for suspended command sequence (in byte).
    pub mod DATLFT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Status Register
pub mod IPRXFSTS {

    /// Fill level of IP RX FIFO.
    pub mod FILL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Total Read Data Counter: RDCNTR * 64 Bits.
    pub mod RDCNTR {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP TX FIFO Status Register
pub mod IPTXFSTS {

    /// Fill level of IP TX FIFO.
    pub mod FILL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Total Write Data Counter: WRCNTR * 64 Bits.
    pub mod WRCNTR {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (16 bits: 0xffff << 16)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Data Register 0
pub mod RFDR0 {

    /// RX Data
    pub mod RXDATA {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP RX FIFO Data Register 0
pub mod RFDR1 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR2 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR3 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR4 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR5 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR6 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR7 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR8 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR9 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR10 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR11 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR12 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR13 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR14 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR15 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR16 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR17 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR18 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR19 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR20 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR21 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR22 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR23 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR24 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR25 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR26 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR27 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR28 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR29 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR30 {
    pub use super::RFDR0::RXDATA;
}

/// IP RX FIFO Data Register 0
pub mod RFDR31 {
    pub use super::RFDR0::RXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR0 {

    /// TX Data
    pub mod TXDATA {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// IP TX FIFO Data Register 0
pub mod TFDR1 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR2 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR3 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR4 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR5 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR6 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR7 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR8 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR9 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR10 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR11 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR12 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR13 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR14 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR15 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR16 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR17 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR18 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR19 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR20 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR21 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR22 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR23 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR24 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR25 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR26 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR27 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR28 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR29 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR30 {
    pub use super::TFDR0::TXDATA;
}

/// IP TX FIFO Data Register 0
pub mod TFDR31 {
    pub use super::TFDR0::TXDATA;
}

/// LUT 0
pub mod LUT0 {

    /// OPERAND0
    pub mod OPERAND0 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// NUM_PADS0
    pub mod NUM_PADS0 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (2 bits: 0b11 << 8)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OPCODE
    pub mod OPCODE0 {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (6 bits: 0x3f << 10)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OPERAND1
    pub mod OPERAND1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// NUM_PADS1
    pub mod NUM_PADS1 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (2 bits: 0b11 << 24)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// OPCODE1
    pub mod OPCODE1 {
        /// Offset (26 bits)
        pub const offset: u32 = 26;
        /// Mask (6 bits: 0x3f << 26)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// LUT 0
pub mod LUT1 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT2 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT3 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT4 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT5 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT6 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT7 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT8 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT9 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT10 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT11 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT12 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT13 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT14 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT15 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT16 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT17 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT18 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT19 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT20 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT21 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT22 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT23 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT24 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT25 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT26 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT27 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT28 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT29 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT30 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT31 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT32 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT33 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT34 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT35 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT36 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT37 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT38 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT39 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT40 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT41 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT42 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT43 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT44 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT45 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT46 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT47 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT48 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT49 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT50 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT51 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT52 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT53 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT54 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT55 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT56 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT57 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT58 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT59 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT60 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT61 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT62 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}

/// LUT 0
pub mod LUT63 {
    pub use super::LUT0::NUM_PADS0;
    pub use super::LUT0::NUM_PADS1;
    pub use super::LUT0::OPCODE0;
    pub use super::LUT0::OPCODE1;
    pub use super::LUT0::OPERAND0;
    pub use super::LUT0::OPERAND1;
}
pub struct RegisterBlock {
    /// Module Control Register 0
    pub MCR0: RWRegister<u32>,

    /// Module Control Register 1
    pub MCR1: RWRegister<u32>,

    /// Module Control Register 2
    pub MCR2: RWRegister<u32>,

    /// AHB Bus Control Register
    pub AHBCR: RWRegister<u32>,

    /// Interrupt Enable Register
    pub INTEN: RWRegister<u32>,

    /// Interrupt Register
    pub INTR: RWRegister<u32>,

    /// LUT Key Register
    pub LUTKEY: RWRegister<u32>,

    /// LUT Control Register
    pub LUTCR: RWRegister<u32>,

    /// AHB RX Buffer 0 Control Register 0
    pub AHBRXBUF0CR0: RWRegister<u32>,

    /// AHB RX Buffer 1 Control Register 0
    pub AHBRXBUF1CR0: RWRegister<u32>,

    /// AHB RX Buffer 2 Control Register 0
    pub AHBRXBUF2CR0: RWRegister<u32>,

    /// AHB RX Buffer 3 Control Register 0
    pub AHBRXBUF3CR0: RWRegister<u32>,

    _reserved1: [u32; 12],

    /// Flash A1 Control Register 0
    pub FLSHA1CR0: RWRegister<u32>,

    /// Flash A2 Control Register 0
    pub FLSHA2CR0: RWRegister<u32>,

    /// Flash B1 Control Register 0
    pub FLSHB1CR0: RWRegister<u32>,

    /// Flash B2 Control Register 0
    pub FLSHB2CR0: RWRegister<u32>,

    /// Flash A1 Control Register 1
    pub FLSHCR1A1: RWRegister<u32>,

    /// Flash A1 Control Register 1
    pub FLSHCR1A2: RWRegister<u32>,

    /// Flash A1 Control Register 1
    pub FLSHCR1B1: RWRegister<u32>,

    /// Flash A1 Control Register 1
    pub FLSHCR1B2: RWRegister<u32>,

    /// Flash A1 Control Register 2
    pub FLSHCR2A1: RWRegister<u32>,

    /// Flash A1 Control Register 2
    pub FLSHCR2A2: RWRegister<u32>,

    /// Flash A1 Control Register 2
    pub FLSHCR2B1: RWRegister<u32>,

    /// Flash A1 Control Register 2
    pub FLSHCR2B2: RWRegister<u32>,

    _reserved2: [u32; 1],

    /// Flash Control Register 4
    pub FLSHCR4: RWRegister<u32>,

    _reserved3: [u32; 2],

    /// IP Control Register 0
    pub IPCR0: RWRegister<u32>,

    /// IP Control Register 1
    pub IPCR1: RWRegister<u32>,

    _reserved4: [u32; 2],

    /// IP Command Register
    pub IPCMD: RWRegister<u32>,

    _reserved5: [u32; 1],

    /// IP RX FIFO Control Register
    pub IPRXFCR: RWRegister<u32>,

    /// IP TX FIFO Control Register
    pub IPTXFCR: RWRegister<u32>,

    /// DLL Control Register 0
    pub DLLCRA: RWRegister<u32>,

    /// DLL Control Register 0
    pub DLLCRB: RWRegister<u32>,

    _reserved6: [u32; 6],

    /// Status Register 0
    pub STS0: RORegister<u32>,

    /// Status Register 1
    pub STS1: RORegister<u32>,

    /// Status Register 2
    pub STS2: RORegister<u32>,

    /// AHB Suspend Status Register
    pub AHBSPNDSTS: RORegister<u32>,

    /// IP RX FIFO Status Register
    pub IPRXFSTS: RORegister<u32>,

    /// IP TX FIFO Status Register
    pub IPTXFSTS: RORegister<u32>,

    _reserved7: [u32; 2],

    /// IP RX FIFO Data Register 0
    pub RFDR0: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR1: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR2: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR3: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR4: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR5: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR6: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR7: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR8: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR9: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR10: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR11: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR12: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR13: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR14: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR15: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR16: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR17: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR18: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR19: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR20: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR21: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR22: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR23: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR24: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR25: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR26: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR27: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR28: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR29: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR30: RORegister<u32>,

    /// IP RX FIFO Data Register 0
    pub RFDR31: RORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR0: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR1: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR2: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR3: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR4: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR5: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR6: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR7: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR8: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR9: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR10: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR11: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR12: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR13: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR14: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR15: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR16: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR17: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR18: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR19: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR20: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR21: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR22: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR23: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR24: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR25: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR26: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR27: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR28: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR29: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR30: WORegister<u32>,

    /// IP TX FIFO Data Register 0
    pub TFDR31: WORegister<u32>,

    /// LUT 0
    pub LUT0: RWRegister<u32>,

    /// LUT 0
    pub LUT1: RWRegister<u32>,

    /// LUT 0
    pub LUT2: RWRegister<u32>,

    /// LUT 0
    pub LUT3: RWRegister<u32>,

    /// LUT 0
    pub LUT4: RWRegister<u32>,

    /// LUT 0
    pub LUT5: RWRegister<u32>,

    /// LUT 0
    pub LUT6: RWRegister<u32>,

    /// LUT 0
    pub LUT7: RWRegister<u32>,

    /// LUT 0
    pub LUT8: RWRegister<u32>,

    /// LUT 0
    pub LUT9: RWRegister<u32>,

    /// LUT 0
    pub LUT10: RWRegister<u32>,

    /// LUT 0
    pub LUT11: RWRegister<u32>,

    /// LUT 0
    pub LUT12: RWRegister<u32>,

    /// LUT 0
    pub LUT13: RWRegister<u32>,

    /// LUT 0
    pub LUT14: RWRegister<u32>,

    /// LUT 0
    pub LUT15: RWRegister<u32>,

    /// LUT 0
    pub LUT16: RWRegister<u32>,

    /// LUT 0
    pub LUT17: RWRegister<u32>,

    /// LUT 0
    pub LUT18: RWRegister<u32>,

    /// LUT 0
    pub LUT19: RWRegister<u32>,

    /// LUT 0
    pub LUT20: RWRegister<u32>,

    /// LUT 0
    pub LUT21: RWRegister<u32>,

    /// LUT 0
    pub LUT22: RWRegister<u32>,

    /// LUT 0
    pub LUT23: RWRegister<u32>,

    /// LUT 0
    pub LUT24: RWRegister<u32>,

    /// LUT 0
    pub LUT25: RWRegister<u32>,

    /// LUT 0
    pub LUT26: RWRegister<u32>,

    /// LUT 0
    pub LUT27: RWRegister<u32>,

    /// LUT 0
    pub LUT28: RWRegister<u32>,

    /// LUT 0
    pub LUT29: RWRegister<u32>,

    /// LUT 0
    pub LUT30: RWRegister<u32>,

    /// LUT 0
    pub LUT31: RWRegister<u32>,

    /// LUT 0
    pub LUT32: RWRegister<u32>,

    /// LUT 0
    pub LUT33: RWRegister<u32>,

    /// LUT 0
    pub LUT34: RWRegister<u32>,

    /// LUT 0
    pub LUT35: RWRegister<u32>,

    /// LUT 0
    pub LUT36: RWRegister<u32>,

    /// LUT 0
    pub LUT37: RWRegister<u32>,

    /// LUT 0
    pub LUT38: RWRegister<u32>,

    /// LUT 0
    pub LUT39: RWRegister<u32>,

    /// LUT 0
    pub LUT40: RWRegister<u32>,

    /// LUT 0
    pub LUT41: RWRegister<u32>,

    /// LUT 0
    pub LUT42: RWRegister<u32>,

    /// LUT 0
    pub LUT43: RWRegister<u32>,

    /// LUT 0
    pub LUT44: RWRegister<u32>,

    /// LUT 0
    pub LUT45: RWRegister<u32>,

    /// LUT 0
    pub LUT46: RWRegister<u32>,

    /// LUT 0
    pub LUT47: RWRegister<u32>,

    /// LUT 0
    pub LUT48: RWRegister<u32>,

    /// LUT 0
    pub LUT49: RWRegister<u32>,

    /// LUT 0
    pub LUT50: RWRegister<u32>,

    /// LUT 0
    pub LUT51: RWRegister<u32>,

    /// LUT 0
    pub LUT52: RWRegister<u32>,

    /// LUT 0
    pub LUT53: RWRegister<u32>,

    /// LUT 0
    pub LUT54: RWRegister<u32>,

    /// LUT 0
    pub LUT55: RWRegister<u32>,

    /// LUT 0
    pub LUT56: RWRegister<u32>,

    /// LUT 0
    pub LUT57: RWRegister<u32>,

    /// LUT 0
    pub LUT58: RWRegister<u32>,

    /// LUT 0
    pub LUT59: RWRegister<u32>,

    /// LUT 0
    pub LUT60: RWRegister<u32>,

    /// LUT 0
    pub LUT61: RWRegister<u32>,

    /// LUT 0
    pub LUT62: RWRegister<u32>,

    /// LUT 0
    pub LUT63: RWRegister<u32>,
}
pub struct ResetValues {
    pub MCR0: u32,
    pub MCR1: u32,
    pub MCR2: u32,
    pub AHBCR: u32,
    pub INTEN: u32,
    pub INTR: u32,
    pub LUTKEY: u32,
    pub LUTCR: u32,
    pub AHBRXBUF0CR0: u32,
    pub AHBRXBUF1CR0: u32,
    pub AHBRXBUF2CR0: u32,
    pub AHBRXBUF3CR0: u32,
    pub FLSHA1CR0: u32,
    pub FLSHA2CR0: u32,
    pub FLSHB1CR0: u32,
    pub FLSHB2CR0: u32,
    pub FLSHCR1A1: u32,
    pub FLSHCR1A2: u32,
    pub FLSHCR1B1: u32,
    pub FLSHCR1B2: u32,
    pub FLSHCR2A1: u32,
    pub FLSHCR2A2: u32,
    pub FLSHCR2B1: u32,
    pub FLSHCR2B2: u32,
    pub FLSHCR4: u32,
    pub IPCR0: u32,
    pub IPCR1: u32,
    pub IPCMD: u32,
    pub IPRXFCR: u32,
    pub IPTXFCR: u32,
    pub DLLCRA: u32,
    pub DLLCRB: u32,
    pub STS0: u32,
    pub STS1: u32,
    pub STS2: u32,
    pub AHBSPNDSTS: u32,
    pub IPRXFSTS: u32,
    pub IPTXFSTS: u32,
    pub RFDR0: u32,
    pub RFDR1: u32,
    pub RFDR2: u32,
    pub RFDR3: u32,
    pub RFDR4: u32,
    pub RFDR5: u32,
    pub RFDR6: u32,
    pub RFDR7: u32,
    pub RFDR8: u32,
    pub RFDR9: u32,
    pub RFDR10: u32,
    pub RFDR11: u32,
    pub RFDR12: u32,
    pub RFDR13: u32,
    pub RFDR14: u32,
    pub RFDR15: u32,
    pub RFDR16: u32,
    pub RFDR17: u32,
    pub RFDR18: u32,
    pub RFDR19: u32,
    pub RFDR20: u32,
    pub RFDR21: u32,
    pub RFDR22: u32,
    pub RFDR23: u32,
    pub RFDR24: u32,
    pub RFDR25: u32,
    pub RFDR26: u32,
    pub RFDR27: u32,
    pub RFDR28: u32,
    pub RFDR29: u32,
    pub RFDR30: u32,
    pub RFDR31: u32,
    pub TFDR0: u32,
    pub TFDR1: u32,
    pub TFDR2: u32,
    pub TFDR3: u32,
    pub TFDR4: u32,
    pub TFDR5: u32,
    pub TFDR6: u32,
    pub TFDR7: u32,
    pub TFDR8: u32,
    pub TFDR9: u32,
    pub TFDR10: u32,
    pub TFDR11: u32,
    pub TFDR12: u32,
    pub TFDR13: u32,
    pub TFDR14: u32,
    pub TFDR15: u32,
    pub TFDR16: u32,
    pub TFDR17: u32,
    pub TFDR18: u32,
    pub TFDR19: u32,
    pub TFDR20: u32,
    pub TFDR21: u32,
    pub TFDR22: u32,
    pub TFDR23: u32,
    pub TFDR24: u32,
    pub TFDR25: u32,
    pub TFDR26: u32,
    pub TFDR27: u32,
    pub TFDR28: u32,
    pub TFDR29: u32,
    pub TFDR30: u32,
    pub TFDR31: u32,
    pub LUT0: u32,
    pub LUT1: u32,
    pub LUT2: u32,
    pub LUT3: u32,
    pub LUT4: u32,
    pub LUT5: u32,
    pub LUT6: u32,
    pub LUT7: u32,
    pub LUT8: u32,
    pub LUT9: u32,
    pub LUT10: u32,
    pub LUT11: u32,
    pub LUT12: u32,
    pub LUT13: u32,
    pub LUT14: u32,
    pub LUT15: u32,
    pub LUT16: u32,
    pub LUT17: u32,
    pub LUT18: u32,
    pub LUT19: u32,
    pub LUT20: u32,
    pub LUT21: u32,
    pub LUT22: u32,
    pub LUT23: u32,
    pub LUT24: u32,
    pub LUT25: u32,
    pub LUT26: u32,
    pub LUT27: u32,
    pub LUT28: u32,
    pub LUT29: u32,
    pub LUT30: u32,
    pub LUT31: u32,
    pub LUT32: u32,
    pub LUT33: u32,
    pub LUT34: u32,
    pub LUT35: u32,
    pub LUT36: u32,
    pub LUT37: u32,
    pub LUT38: u32,
    pub LUT39: u32,
    pub LUT40: u32,
    pub LUT41: u32,
    pub LUT42: u32,
    pub LUT43: u32,
    pub LUT44: u32,
    pub LUT45: u32,
    pub LUT46: u32,
    pub LUT47: u32,
    pub LUT48: u32,
    pub LUT49: u32,
    pub LUT50: u32,
    pub LUT51: u32,
    pub LUT52: u32,
    pub LUT53: u32,
    pub LUT54: u32,
    pub LUT55: u32,
    pub LUT56: u32,
    pub LUT57: u32,
    pub LUT58: u32,
    pub LUT59: u32,
    pub LUT60: u32,
    pub LUT61: u32,
    pub LUT62: u32,
    pub LUT63: u32,
}
#[cfg(not(feature = "nosync"))]
pub struct Instance {
    pub(crate) addr: u32,
    pub(crate) _marker: PhantomData<*const RegisterBlock>,
}
#[cfg(not(feature = "nosync"))]
impl ::core::ops::Deref for Instance {
    type Target = RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &RegisterBlock {
        unsafe { &*(self.addr as *const _) }
    }
}
#[cfg(feature = "rtfm")]
unsafe impl Send for Instance {}

/// Access functions for the FLEXSPI peripheral instance
pub mod FLEXSPI {
    use super::ResetValues;

    #[cfg(not(feature = "nosync"))]
    use super::Instance;

    #[cfg(not(feature = "nosync"))]
    const INSTANCE: Instance = Instance {
        addr: 0x402a8000,
        _marker: ::core::marker::PhantomData,
    };

    /// Reset values for each field in FLEXSPI
    pub const reset: ResetValues = ResetValues {
        MCR0: 0xFFFF80C2,
        MCR1: 0xFFFFFFFF,
        MCR2: 0x200081F7,
        AHBCR: 0x00000018,
        INTEN: 0x00000000,
        INTR: 0x00000040,
        LUTKEY: 0x5AF05AF0,
        LUTCR: 0x00000002,
        AHBRXBUF0CR0: 0x80000020,
        AHBRXBUF1CR0: 0x80010020,
        AHBRXBUF2CR0: 0x80020020,
        AHBRXBUF3CR0: 0x80030020,
        FLSHA1CR0: 0x00010000,
        FLSHA2CR0: 0x00010000,
        FLSHB1CR0: 0x00010000,
        FLSHB2CR0: 0x00010000,
        FLSHCR1A1: 0x00000063,
        FLSHCR1A2: 0x00000063,
        FLSHCR1B1: 0x00000063,
        FLSHCR1B2: 0x00000063,
        FLSHCR2A1: 0x00000000,
        FLSHCR2A2: 0x00000000,
        FLSHCR2B1: 0x00000000,
        FLSHCR2B2: 0x00000000,
        FLSHCR4: 0x00000000,
        IPCR0: 0x00000000,
        IPCR1: 0x00000000,
        IPCMD: 0x00000000,
        IPRXFCR: 0x00000000,
        IPTXFCR: 0x00000000,
        DLLCRA: 0x00000100,
        DLLCRB: 0x00000100,
        STS0: 0x00000003,
        STS1: 0x00000000,
        STS2: 0x01000100,
        AHBSPNDSTS: 0x00000000,
        IPRXFSTS: 0x00000000,
        IPTXFSTS: 0x00000000,
        RFDR0: 0x00000000,
        RFDR1: 0x00000000,
        RFDR2: 0x00000000,
        RFDR3: 0x00000000,
        RFDR4: 0x00000000,
        RFDR5: 0x00000000,
        RFDR6: 0x00000000,
        RFDR7: 0x00000000,
        RFDR8: 0x00000000,
        RFDR9: 0x00000000,
        RFDR10: 0x00000000,
        RFDR11: 0x00000000,
        RFDR12: 0x00000000,
        RFDR13: 0x00000000,
        RFDR14: 0x00000000,
        RFDR15: 0x00000000,
        RFDR16: 0x00000000,
        RFDR17: 0x00000000,
        RFDR18: 0x00000000,
        RFDR19: 0x00000000,
        RFDR20: 0x00000000,
        RFDR21: 0x00000000,
        RFDR22: 0x00000000,
        RFDR23: 0x00000000,
        RFDR24: 0x00000000,
        RFDR25: 0x00000000,
        RFDR26: 0x00000000,
        RFDR27: 0x00000000,
        RFDR28: 0x00000000,
        RFDR29: 0x00000000,
        RFDR30: 0x00000000,
        RFDR31: 0x00000000,
        TFDR0: 0x00000000,
        TFDR1: 0x00000000,
        TFDR2: 0x00000000,
        TFDR3: 0x00000000,
        TFDR4: 0x00000000,
        TFDR5: 0x00000000,
        TFDR6: 0x00000000,
        TFDR7: 0x00000000,
        TFDR8: 0x00000000,
        TFDR9: 0x00000000,
        TFDR10: 0x00000000,
        TFDR11: 0x00000000,
        TFDR12: 0x00000000,
        TFDR13: 0x00000000,
        TFDR14: 0x00000000,
        TFDR15: 0x00000000,
        TFDR16: 0x00000000,
        TFDR17: 0x00000000,
        TFDR18: 0x00000000,
        TFDR19: 0x00000000,
        TFDR20: 0x00000000,
        TFDR21: 0x00000000,
        TFDR22: 0x00000000,
        TFDR23: 0x00000000,
        TFDR24: 0x00000000,
        TFDR25: 0x00000000,
        TFDR26: 0x00000000,
        TFDR27: 0x00000000,
        TFDR28: 0x00000000,
        TFDR29: 0x00000000,
        TFDR30: 0x00000000,
        TFDR31: 0x00000000,
        LUT0: 0x00000000,
        LUT1: 0x00000000,
        LUT2: 0x00000000,
        LUT3: 0x00000000,
        LUT4: 0x00000000,
        LUT5: 0x00000000,
        LUT6: 0x00000000,
        LUT7: 0x00000000,
        LUT8: 0x00000000,
        LUT9: 0x00000000,
        LUT10: 0x00000000,
        LUT11: 0x00000000,
        LUT12: 0x00000000,
        LUT13: 0x00000000,
        LUT14: 0x00000000,
        LUT15: 0x00000000,
        LUT16: 0x00000000,
        LUT17: 0x00000000,
        LUT18: 0x00000000,
        LUT19: 0x00000000,
        LUT20: 0x00000000,
        LUT21: 0x00000000,
        LUT22: 0x00000000,
        LUT23: 0x00000000,
        LUT24: 0x00000000,
        LUT25: 0x00000000,
        LUT26: 0x00000000,
        LUT27: 0x00000000,
        LUT28: 0x00000000,
        LUT29: 0x00000000,
        LUT30: 0x00000000,
        LUT31: 0x00000000,
        LUT32: 0x00000000,
        LUT33: 0x00000000,
        LUT34: 0x00000000,
        LUT35: 0x00000000,
        LUT36: 0x00000000,
        LUT37: 0x00000000,
        LUT38: 0x00000000,
        LUT39: 0x00000000,
        LUT40: 0x00000000,
        LUT41: 0x00000000,
        LUT42: 0x00000000,
        LUT43: 0x00000000,
        LUT44: 0x00000000,
        LUT45: 0x00000000,
        LUT46: 0x00000000,
        LUT47: 0x00000000,
        LUT48: 0x00000000,
        LUT49: 0x00000000,
        LUT50: 0x00000000,
        LUT51: 0x00000000,
        LUT52: 0x00000000,
        LUT53: 0x00000000,
        LUT54: 0x00000000,
        LUT55: 0x00000000,
        LUT56: 0x00000000,
        LUT57: 0x00000000,
        LUT58: 0x00000000,
        LUT59: 0x00000000,
        LUT60: 0x00000000,
        LUT61: 0x00000000,
        LUT62: 0x00000000,
        LUT63: 0x00000000,
    };

    #[cfg(not(feature = "nosync"))]
    #[allow(renamed_and_removed_lints)]
    #[allow(private_no_mangle_statics)]
    #[no_mangle]
    static mut FLEXSPI_TAKEN: bool = false;

    /// Safe access to FLEXSPI
    ///
    /// This function returns `Some(Instance)` if this instance is not
    /// currently taken, and `None` if it is. This ensures that if you
    /// do get `Some(Instance)`, you are ensured unique access to
    /// the peripheral and there cannot be data races (unless other
    /// code uses `unsafe`, of course). You can then pass the
    /// `Instance` around to other functions as required. When you're
    /// done with it, you can call `release(instance)` to return it.
    ///
    /// `Instance` itself dereferences to a `RegisterBlock`, which
    /// provides access to the peripheral's registers.
    #[cfg(not(feature = "nosync"))]
    #[inline]
    pub fn take() -> Option<Instance> {
        external_cortex_m::interrupt::free(|_| unsafe {
            if FLEXSPI_TAKEN {
                None
            } else {
                FLEXSPI_TAKEN = true;
                Some(INSTANCE)
            }
        })
    }

    /// Release exclusive access to FLEXSPI
    ///
    /// This function allows you to return an `Instance` so that it
    /// is available to `take()` again. This function will panic if
    /// you return a different `Instance` or if this instance is not
    /// already taken.
    #[cfg(not(feature = "nosync"))]
    #[inline]
    pub fn release(inst: Instance) {
        external_cortex_m::interrupt::free(|_| unsafe {
            if FLEXSPI_TAKEN && inst.addr == INSTANCE.addr {
                FLEXSPI_TAKEN = false;
            } else {
                panic!("Released a peripheral which was not taken");
            }
        });
    }

    /// Unsafely steal FLEXSPI
    ///
    /// This function is similar to take() but forcibly takes the
    /// Instance, marking it as taken irregardless of its previous
    /// state.
    #[cfg(not(feature = "nosync"))]
    #[inline]
    pub unsafe fn steal() -> Instance {
        FLEXSPI_TAKEN = true;
        INSTANCE
    }
}

/// Raw pointer to FLEXSPI
///
/// Dereferencing this is unsafe because you are not ensured unique
/// access to the peripheral, so you may encounter data races with
/// other users of this peripheral. It is up to you to ensure you
/// will not cause data races.
///
/// This constant is provided for ease of use in unsafe code: you can
/// simply call for example `write_reg!(gpio, GPIOA, ODR, 1);`.
pub const FLEXSPI: *const RegisterBlock = 0x402a8000 as *const _;

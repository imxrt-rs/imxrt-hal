#![allow(non_snake_case, non_upper_case_globals)]
#![allow(non_camel_case_types)]
//! CAN
//!
//! Used by: imxrt1061, imxrt1062, imxrt1064

use crate::{RORegister, RWRegister};
#[cfg(not(feature = "nosync"))]
use core::marker::PhantomData;

/// Module Configuration Register
pub mod MCR {

    /// Number Of The Last Message Buffer
    pub mod MAXMB {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (7 bits: 0x7f << 0)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Acceptance Mode
    pub mod IDAM {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (2 bits: 0b11 << 8)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Format A: One full ID (standard and extended) per ID Filter Table element.
            pub const IDAM_0: u32 = 0b00;

            /// 0b01: Format B: Two full standard IDs or two partial 14-bit (standard and extended) IDs per ID Filter Table element.
            pub const IDAM_1: u32 = 0b01;

            /// 0b10: Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
            pub const IDAM_2: u32 = 0b10;

            /// 0b11: Format D: All frames rejected.
            pub const IDAM_3: u32 = 0b11;
        }
    }

    /// CAN FD operation enable
    pub mod FDEN {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: CAN FD is disabled. FlexCAN is able to receive and transmit messages in CAN 2.0 format.
            pub const FDEN_0: u32 = 0b0;

            /// 0b1: CAN FD is enabled. FlexCAN is able to receive and transmit messages in both CAN FD and CAN 2.0 formats.
            pub const FDEN_1: u32 = 0b1;
        }
    }

    /// Abort Enable
    pub mod AEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Abort disabled.
            pub const AEN_0: u32 = 0b0;

            /// 0b1: Abort enabled.
            pub const AEN_1: u32 = 0b1;
        }
    }

    /// Local Priority Enable
    pub mod LPRIOEN {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Local Priority disabled.
            pub const LPRIOEN_0: u32 = 0b0;

            /// 0b1: Local Priority enabled.
            pub const LPRIOEN_1: u32 = 0b1;
        }
    }

    /// DMA Enable
    pub mod DMA {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: DMA feature for Legacy RX FIFO or Enhanced Rx FIFO are disabled.
            pub const DMA_0: u32 = 0b0;

            /// 0b1: DMA feature for Legacy RX FIFO or Enhanced Rx FIFO are enabled.
            pub const DMA_1: u32 = 0b1;
        }
    }

    /// Individual Rx Masking And Queue Enable
    pub mod IRMQ {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Individual Rx masking and queue feature are disabled. For backward compatibility with legacy applications, the reading of C/S word locks the MB even if it is EMPTY.
            pub const IRMQ_0: u32 = 0b0;

            /// 0b1: Individual Rx masking and queue feature are enabled.
            pub const IRMQ_1: u32 = 0b1;
        }
    }

    /// Self Reception Disable
    pub mod SRXDIS {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Self reception enabled.
            pub const SRXDIS_0: u32 = 0b0;

            /// 0b1: Self reception disabled.
            pub const SRXDIS_1: u32 = 0b1;
        }
    }

    /// Doze Mode Enable
    pub mod DOZE {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not enabled to enter low-power mode when Doze mode is requested.
            pub const DOZE_0: u32 = 0b0;

            /// 0b1: FlexCAN is enabled to enter low-power mode when Doze mode is requested.
            pub const DOZE_1: u32 = 0b1;
        }
    }

    /// Wake Up Source
    pub mod WAKSRC {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN uses the unfiltered Rx input to detect recessive to dominant edges on the CAN bus.
            pub const WAKSRC_0: u32 = 0b0;

            /// 0b1: FlexCAN uses the filtered Rx input to detect recessive to dominant edges on the CAN bus.
            pub const WAKSRC_1: u32 = 0b1;
        }
    }

    /// Low-Power Mode Acknowledge
    pub mod LPMACK {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not in a low-power mode.
            pub const LPMACK_0: u32 = 0b0;

            /// 0b1: FlexCAN is in a low-power mode.
            pub const LPMACK_1: u32 = 0b1;
        }
    }

    /// Warning Interrupt Enable
    pub mod WRNEN {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: TWRNINT and RWRNINT bits are zero, independent of the values in the error counters.
            pub const WRNEN_0: u32 = 0b0;

            /// 0b1: TWRNINT and RWRNINT bits are set when the respective error counter transitions from less than 96 to greater than or equal to 96.
            pub const WRNEN_1: u32 = 0b1;
        }
    }

    /// Self Wake Up
    pub mod SLFWAK {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN Self Wake Up feature is disabled.
            pub const SLFWAK_0: u32 = 0b0;

            /// 0b1: FlexCAN Self Wake Up feature is enabled.
            pub const SLFWAK_1: u32 = 0b1;
        }
    }

    /// Supervisor Mode
    pub mod SUPV {
        /// Offset (23 bits)
        pub const offset: u32 = 23;
        /// Mask (1 bit: 1 << 23)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is in User mode. Affected registers allow both Supervisor and Unrestricted accesses.
            pub const SUPV_0: u32 = 0b0;

            /// 0b1: FlexCAN is in Supervisor mode. Affected registers allow only Supervisor access. Unrestricted access behaves as though the access was done to an unimplemented register location.
            pub const SUPV_1: u32 = 0b1;
        }
    }

    /// Freeze Mode Acknowledge
    pub mod FRZACK {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (1 bit: 1 << 24)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN not in Freeze mode, prescaler running.
            pub const FRZACK_0: u32 = 0b0;

            /// 0b1: FlexCAN in Freeze mode, prescaler stopped.
            pub const FRZACK_1: u32 = 0b1;
        }
    }

    /// Soft Reset
    pub mod SOFTRST {
        /// Offset (25 bits)
        pub const offset: u32 = 25;
        /// Mask (1 bit: 1 << 25)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No reset request.
            pub const SOFTRST_0: u32 = 0b0;

            /// 0b1: Resets the registers affected by soft reset.
            pub const SOFTRST_1: u32 = 0b1;
        }
    }

    /// Wake Up Interrupt Mask
    pub mod WAKMSK {
        /// Offset (26 bits)
        pub const offset: u32 = 26;
        /// Mask (1 bit: 1 << 26)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Wake Up Interrupt is disabled.
            pub const WAKMSK_0: u32 = 0b0;

            /// 0b1: Wake Up Interrupt is enabled.
            pub const WAKMSK_1: u32 = 0b1;
        }
    }

    /// FlexCAN Not Ready
    pub mod NOTRDY {
        /// Offset (27 bits)
        pub const offset: u32 = 27;
        /// Mask (1 bit: 1 << 27)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back mode.
            pub const NOTRDY_0: u32 = 0b0;

            /// 0b1: FlexCAN module is either in Disable mode, Doze mode , Stop mode or Freeze mode.
            pub const NOTRDY_1: u32 = 0b1;
        }
    }

    /// Halt FlexCAN
    pub mod HALT {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (1 bit: 1 << 28)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No Freeze mode request.
            pub const HALT_0: u32 = 0b0;

            /// 0b1: Enters Freeze mode if the FRZ bit is asserted.
            pub const HALT_1: u32 = 0b1;
        }
    }

    /// Legacy Rx FIFO Enable
    pub mod RFEN {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Legacy Rx FIFO not enabled.
            pub const RFEN_0: u32 = 0b0;

            /// 0b1: Legacy Rx FIFO enabled.
            pub const RFEN_1: u32 = 0b1;
        }
    }

    /// Freeze Enable
    pub mod FRZ {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Not enabled to enter Freeze mode.
            pub const FRZ_0: u32 = 0b0;

            /// 0b1: Enabled to enter Freeze mode.
            pub const FRZ_1: u32 = 0b1;
        }
    }

    /// Module Disable
    pub mod MDIS {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enable the FlexCAN module.
            pub const MDIS_0: u32 = 0b0;

            /// 0b1: Disable the FlexCAN module.
            pub const MDIS_1: u32 = 0b1;
        }
    }
}

/// Control 1 register
pub mod CTRL1 {

    /// Propagation Segment
    pub mod PROPSEG {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (3 bits: 0b111 << 0)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Listen-Only Mode
    pub mod LOM {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Listen-Only mode is deactivated.
            pub const LOM_0: u32 = 0b0;

            /// 0b1: FlexCAN module operates in Listen-Only mode.
            pub const LOM_1: u32 = 0b1;
        }
    }

    /// Lowest Buffer Transmitted First
    pub mod LBUF {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (1 bit: 1 << 4)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Buffer with highest priority is transmitted first.
            pub const LBUF_0: u32 = 0b0;

            /// 0b1: Lowest number buffer is transmitted first.
            pub const LBUF_1: u32 = 0b1;
        }
    }

    /// Timer Sync
    pub mod TSYN {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Timer Sync feature disabled
            pub const TSYN_0: u32 = 0b0;

            /// 0b1: Timer Sync feature enabled
            pub const TSYN_1: u32 = 0b1;
        }
    }

    /// Bus Off Recovery
    pub mod BOFFREC {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Automatic recovering from Bus Off state enabled.
            pub const BOFFREC_0: u32 = 0b0;

            /// 0b1: Automatic recovering from Bus Off state disabled.
            pub const BOFFREC_1: u32 = 0b1;
        }
    }

    /// CAN Bit Sampling
    pub mod SMP {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Just one sample is used to determine the bit value.
            pub const SMP_0: u32 = 0b0;

            /// 0b1: Three samples are used to determine the value of the received bit: the regular one (sample point) and 2 preceding samples; a majority rule is used.
            pub const SMP_1: u32 = 0b1;
        }
    }

    /// Rx Warning Interrupt Mask
    pub mod RWRNMSK {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Rx Warning Interrupt disabled.
            pub const RWRNMSK_0: u32 = 0b0;

            /// 0b1: Rx Warning Interrupt enabled.
            pub const RWRNMSK_1: u32 = 0b1;
        }
    }

    /// Tx Warning Interrupt Mask
    pub mod TWRNMSK {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Tx Warning Interrupt disabled.
            pub const TWRNMSK_0: u32 = 0b0;

            /// 0b1: Tx Warning Interrupt enabled.
            pub const TWRNMSK_1: u32 = 0b1;
        }
    }

    /// Loop Back Mode
    pub mod LPB {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Loop Back disabled.
            pub const LPB_0: u32 = 0b0;

            /// 0b1: Loop Back enabled.
            pub const LPB_1: u32 = 0b1;
        }
    }

    /// CAN Engine Clock Source
    pub mod CLKSRC {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The CAN engine clock source is the oscillator clock. Under this condition, the oscillator clock frequency must be lower than the bus clock.
            pub const CLKSRC_0: u32 = 0b0;

            /// 0b1: The CAN engine clock source is the peripheral clock.
            pub const CLKSRC_1: u32 = 0b1;
        }
    }

    /// Error Interrupt Mask
    pub mod ERRMSK {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Error interrupt disabled.
            pub const ERRMSK_0: u32 = 0b0;

            /// 0b1: Error interrupt enabled.
            pub const ERRMSK_1: u32 = 0b1;
        }
    }

    /// Bus Off Interrupt Mask
    pub mod BOFFMSK {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Bus Off interrupt disabled.
            pub const BOFFMSK_0: u32 = 0b0;

            /// 0b1: Bus Off interrupt enabled.
            pub const BOFFMSK_1: u32 = 0b1;
        }
    }

    /// Phase Segment 2
    pub mod PSEG2 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (3 bits: 0b111 << 16)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Phase Segment 1
    pub mod PSEG1 {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (3 bits: 0b111 << 19)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Resync Jump Width
    pub mod RJW {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (2 bits: 0b11 << 22)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Prescaler Division Factor
    pub mod PRESDIV {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Free Running Timer
pub mod TIMER {

    /// Timer Value
    pub mod TIMER {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx Mailboxes Global Mask Register
pub mod RXMGMASK {

    /// Rx Mailboxes Global Mask Bits
    pub mod MG {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx 14 Mask register
pub mod RX14MASK {

    /// Rx Buffer 14 Mask Bits
    pub mod RX14M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx 15 Mask register
pub mod RX15MASK {

    /// Rx Buffer 15 Mask Bits
    pub mod RX15M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error Counter
pub mod ECR {

    /// Transmit Error Counter
    pub mod TXERRCNT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Receive Error Counter
    pub mod RXERRCNT {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Transmit Error Counter for fast bits
    pub mod TXERRCNT_FAST {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Receive Error Counter for fast bits
    pub mod RXERRCNT_FAST {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Error and Status 1 register
pub mod ESR1 {

    /// Wake-Up Interrupt
    pub mod WAKINT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const WAKINT_0: u32 = 0b0;

            /// 0b1: Indicates a recessive to dominant transition was received on the CAN bus.
            pub const WAKINT_1: u32 = 0b1;
        }
    }

    /// Error Interrupt
    pub mod ERRINT {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (1 bit: 1 << 1)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const ERRINT_0: u32 = 0b0;

            /// 0b1: Indicates setting of any Error Bit in the Error and Status Register.
            pub const ERRINT_1: u32 = 0b1;
        }
    }

    /// Bus Off Interrupt
    pub mod BOFFINT {
        /// Offset (2 bits)
        pub const offset: u32 = 2;
        /// Mask (1 bit: 1 << 2)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const BOFFINT_0: u32 = 0b0;

            /// 0b1: FlexCAN module entered Bus Off state.
            pub const BOFFINT_1: u32 = 0b1;
        }
    }

    /// FlexCAN In Reception
    pub mod RX {
        /// Offset (3 bits)
        pub const offset: u32 = 3;
        /// Mask (1 bit: 1 << 3)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not receiving a message.
            pub const RX_0: u32 = 0b0;

            /// 0b1: FlexCAN is receiving a message.
            pub const RX_1: u32 = 0b1;
        }
    }

    /// Fault Confinement State
    pub mod FLTCONF {
        /// Offset (4 bits)
        pub const offset: u32 = 4;
        /// Mask (2 bits: 0b11 << 4)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Error Active
            pub const FLTCONF_0: u32 = 0b00;

            /// 0b01: Error Passive
            pub const FLTCONF_1: u32 = 0b01;

            /// 0b00: Bus Off
            pub const FLTCONF_2: u32 = 0b00;
        }
    }

    /// FlexCAN In Transmission
    pub mod TX {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not transmitting a message.
            pub const TX_0: u32 = 0b0;

            /// 0b1: FlexCAN is transmitting a message.
            pub const TX_1: u32 = 0b1;
        }
    }

    /// IDLE
    pub mod IDLE {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const IDLE_0: u32 = 0b0;

            /// 0b1: CAN bus is now IDLE.
            pub const IDLE_1: u32 = 0b1;
        }
    }

    /// Rx Error Warning
    pub mod RXWRN {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (1 bit: 1 << 8)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const RXWRN_0: u32 = 0b0;

            /// 0b1: RXERRCNT is greater than or equal to 96.
            pub const RXWRN_1: u32 = 0b1;
        }
    }

    /// TX Error Warning
    pub mod TXWRN {
        /// Offset (9 bits)
        pub const offset: u32 = 9;
        /// Mask (1 bit: 1 << 9)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const TXWRN_0: u32 = 0b0;

            /// 0b1: TXERRCNT is greater than or equal to 96.
            pub const TXWRN_1: u32 = 0b1;
        }
    }

    /// Stuffing Error
    pub mod STFERR {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (1 bit: 1 << 10)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const STFERR_0: u32 = 0b0;

            /// 0b1: A Stuffing Error occurred since last read of this register.
            pub const STFERR_1: u32 = 0b1;
        }
    }

    /// Form Error
    pub mod FRMERR {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const FRMERR_0: u32 = 0b0;

            /// 0b1: A Form Error occurred since last read of this register.
            pub const FRMERR_1: u32 = 0b1;
        }
    }

    /// Cyclic Redundancy Check Error
    pub mod CRCERR {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const CRCERR_0: u32 = 0b0;

            /// 0b1: A CRC error occurred since last read of this register.
            pub const CRCERR_1: u32 = 0b1;
        }
    }

    /// Acknowledge Error
    pub mod ACKERR {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const ACKERR_0: u32 = 0b0;

            /// 0b1: An ACK error occurred since last read of this register.
            pub const ACKERR_1: u32 = 0b1;
        }
    }

    /// Bit0 Error
    pub mod BIT0ERR {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const BIT0ERR_0: u32 = 0b0;

            /// 0b1: At least one bit sent as dominant is received as recessive.
            pub const BIT0ERR_1: u32 = 0b1;
        }
    }

    /// Bit1 Error
    pub mod BIT1ERR {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const BIT1ERR_0: u32 = 0b0;

            /// 0b1: At least one bit sent as recessive is received as dominant.
            pub const BIT1ERR_1: u32 = 0b1;
        }
    }

    /// Rx Warning Interrupt Flag
    pub mod RWRNINT {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const RWRNINT_0: u32 = 0b0;

            /// 0b1: The Rx error counter transitioned from less than 96 to greater than or equal to 96.
            pub const RWRNINT_1: u32 = 0b1;
        }
    }

    /// Tx Warning Interrupt Flag
    pub mod TWRNINT {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const TWRNINT_0: u32 = 0b0;

            /// 0b1: The Tx error counter transitioned from less than 96 to greater than or equal to 96.
            pub const TWRNINT_1: u32 = 0b1;
        }
    }

    /// CAN Synchronization Status
    pub mod SYNCH {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN is not synchronized to the CAN bus.
            pub const SYNCH_0: u32 = 0b0;

            /// 0b1: FlexCAN is synchronized to the CAN bus.
            pub const SYNCH_1: u32 = 0b1;
        }
    }

    /// Bus Off Done Interrupt
    pub mod BOFFDONEINT {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (1 bit: 1 << 19)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const BOFFDONEINT_0: u32 = 0b0;

            /// 0b1: FlexCAN module has completed Bus Off process.
            pub const BOFFDONEINT_1: u32 = 0b1;
        }
    }

    /// Error Interrupt for errors detected in the Data Phase of CAN FD frames with the BRS bit set
    pub mod ERRINT_FAST {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const ERRINT_FAST_0: u32 = 0b0;

            /// 0b1: Indicates setting of any Error Bit detected in the Data Phase of CAN FD frames with the BRS bit set.
            pub const ERRINT_FAST_1: u32 = 0b1;
        }
    }

    /// Error Overrun bit
    pub mod ERROVR {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Overrun has not occurred.
            pub const ERROVR_0: u32 = 0b0;

            /// 0b1: Overrun has occurred.
            pub const ERROVR_1: u32 = 0b1;
        }
    }

    /// Stuffing Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod STFERR_FAST {
        /// Offset (26 bits)
        pub const offset: u32 = 26;
        /// Mask (1 bit: 1 << 26)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const STFERR_FAST_0: u32 = 0b0;

            /// 0b1: A Stuffing Error occurred since last read of this register.
            pub const STFERR_FAST_1: u32 = 0b1;
        }
    }

    /// Form Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod FRMERR_FAST {
        /// Offset (27 bits)
        pub const offset: u32 = 27;
        /// Mask (1 bit: 1 << 27)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const FRMERR_FAST_0: u32 = 0b0;

            /// 0b1: A Form Error occurred since last read of this register.
            pub const FRMERR_FAST_1: u32 = 0b1;
        }
    }

    /// Cyclic Redundancy Check Error in the CRC field of CAN FD frames with the BRS bit set
    pub mod CRCERR_FAST {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (1 bit: 1 << 28)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const CRCERR_FAST_0: u32 = 0b0;

            /// 0b1: A CRC error occurred since last read of this register.
            pub const CRCERR_FAST_1: u32 = 0b1;
        }
    }

    /// Bit0 Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod BIT0ERR_FAST {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const BIT0ERR_FAST_0: u32 = 0b0;

            /// 0b1: At least one bit sent as dominant is received as recessive.
            pub const BIT0ERR_FAST_1: u32 = 0b1;
        }
    }

    /// Bit1 Error in the Data Phase of CAN FD frames with the BRS bit set
    pub mod BIT1ERR_FAST {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence.
            pub const BIT1ERR_FAST_0: u32 = 0b0;

            /// 0b1: At least one bit sent as recessive is received as dominant.
            pub const BIT1ERR_FAST_1: u32 = 0b1;
        }
    }
}

/// Interrupt Masks 2 register
pub mod IMASK2 {

    /// Buffer MB i Mask
    pub mod BUF63TO32M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Masks 1 register
pub mod IMASK1 {

    /// Buffer MB i Mask
    pub mod BUF31TO0M {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Flags 2 register
pub mod IFLAG2 {

    /// Buffer MB i Interrupt
    pub mod BUF63TO32I {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Interrupt Flags 1 register
pub mod IFLAG1 {

    /// Buffer MB0 Interrupt Or Clear Legacy FIFO bit
    pub mod BUF0I {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (1 bit: 1 << 0)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The corresponding buffer has no occurrence of successfully completed transmission or reception when CAN_MCR\[RFEN\]=0.
            pub const BUF0I_0: u32 = 0b0;

            /// 0b1: The corresponding buffer has successfully completed transmission or reception when CAN_MCR\[RFEN\]=0.
            pub const BUF0I_1: u32 = 0b1;
        }
    }

    /// Buffer MB i Interrupt Or "reserved"
    pub mod BUF4TO1I {
        /// Offset (1 bits)
        pub const offset: u32 = 1;
        /// Mask (4 bits: 0b1111 << 1)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Buffer MB5 Interrupt Or "Frames available in Legacy Rx FIFO"
    pub mod BUF5I {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (1 bit: 1 << 5)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No occurrence of MB5 completing transmission/reception when CAN_MCR\[RFEN\]=0, or of frame(s) available in the Legacy FIFO, when CAN_MCR\[RFEN\]=1
            pub const BUF5I_0: u32 = 0b0;

            /// 0b1: MB5 completed transmission/reception when CAN_MCR\[RFEN\]=0, or frame(s) available in the Legacy Rx FIFO when CAN_MCR\[RFEN\]=1. It generates a DMA request in case of CAN_MCR\[RFEN\] and CAN_MCR\[DMA\] are enabled.
            pub const BUF5I_1: u32 = 0b1;
        }
    }

    /// Buffer MB6 Interrupt Or "Legacy Rx FIFO Warning"
    pub mod BUF6I {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (1 bit: 1 << 6)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No occurrence of MB6 completing transmission/reception when CAN_MCR\[RFEN\]=0, or of Legacy Rx FIFO almost full when CAN_MCR\[RFEN\]=1
            pub const BUF6I_0: u32 = 0b0;

            /// 0b1: MB6 completed transmission/reception when CAN_MCR\[RFEN\]=0, or Legacy Rx FIFO almost full when CAN_MCR\[RFEN\]=1
            pub const BUF6I_1: u32 = 0b1;
        }
    }

    /// Buffer MB7 Interrupt Or "Legacy Rx FIFO Overflow"
    pub mod BUF7I {
        /// Offset (7 bits)
        pub const offset: u32 = 7;
        /// Mask (1 bit: 1 << 7)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No occurrence of MB7 completing transmission/reception when CAN_MCR\[RFEN\]=0, or of Legacy Rx FIFO overflow when CAN_MCR\[RFEN\]=1
            pub const BUF7I_0: u32 = 0b0;

            /// 0b1: MB7 completed transmission/reception when CAN_MCR\[RFEN\]=0, or Legacy Rx FIFO overflow when CAN_MCR\[RFEN\]=1
            pub const BUF7I_1: u32 = 0b1;
        }
    }

    /// Buffer MBi Interrupt
    pub mod BUF31TO8I {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (24 bits: 0xffffff << 8)
        pub const mask: u32 = 0xffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Control 2 register
pub mod CTRL2 {

    /// Time Stamp Capture Point
    pub mod TSTAMPCAP {
        /// Offset (6 bits)
        pub const offset: u32 = 6;
        /// Mask (2 bits: 0b11 << 6)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: The high resolution time stamp capture is disabled
            pub const TSTAMPCAP_0: u32 = 0b00;

            /// 0b01: The high resolution time stamp is captured in the end of the CAN frame
            pub const TSTAMPCAP_1: u32 = 0b01;

            /// 0b10: The high resolution time stamp is captured in the start of the CAN frame
            pub const TSTAMPCAP_2: u32 = 0b10;

            /// 0b11: The high resolution time stamp is captured in the start of frame for classical CAN frames and in res bit for CAN FD frames
            pub const TSTAMPCAP_3: u32 = 0b11;
        }
    }

    /// Message Buffer Time Stamp Base
    pub mod MBTSBASE {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (2 bits: 0b11 << 8)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Message Buffer Time Stamp base is CAN_TIMER
            pub const MBTSBASE_0: u32 = 0b00;

            /// 0b01: Message Buffer Time Stamp base is lower 16-bits of high resolution timer
            pub const MBTSBASE_1: u32 = 0b01;

            /// 0b10: Message Buffer Time Stamp base is upper 16-bits of high resolution timerT
            pub const MBTSBASE_2: u32 = 0b10;
        }
    }

    /// Edge Filter Disable
    pub mod EDFLTDIS {
        /// Offset (11 bits)
        pub const offset: u32 = 11;
        /// Mask (1 bit: 1 << 11)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Edge Filter is enabled
            pub const EDFLTDIS_0: u32 = 0b0;

            /// 0b1: Edge Filter is disabled
            pub const EDFLTDIS_1: u32 = 0b1;
        }
    }

    /// ISO CAN FD Enable
    pub mod ISOCANFDEN {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (1 bit: 1 << 12)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: FlexCAN operates using the non-ISO CAN FD protocol.
            pub const ISOCANFDEN_0: u32 = 0b0;

            /// 0b1: FlexCAN operates using the ISO CAN FD protocol (ISO 11898-1).
            pub const ISOCANFDEN_1: u32 = 0b1;
        }
    }

    /// Bit Timing Expansion enable
    pub mod BTE {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: CAN Bit timing expansion is disabled.
            pub const BTE_0: u32 = 0b0;

            /// 0b1: CAN bit timing expansion is enabled.
            pub const BTE_1: u32 = 0b1;
        }
    }

    /// Protocol Exception Enable
    pub mod PREXCEN {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Protocol Exception is disabled.
            pub const PREXCEN_0: u32 = 0b0;

            /// 0b1: Protocol Exception is enabled.
            pub const PREXCEN_1: u32 = 0b1;
        }
    }

    /// Timer Source
    pub mod TIMER_SRC {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: The Free Running Timer is clocked by the CAN bit clock, which defines the baud rate on the CAN bus.
            pub const TIMER_SRC_0: u32 = 0b0;

            /// 0b1: The Free Running Timer is clocked by an external time tick. The period can be either adjusted to be equal to the baud rate on the CAN bus, or a different value as required. See the device specific section for details about the external time tick.
            pub const TIMER_SRC_1: u32 = 0b1;
        }
    }

    /// Entire Frame Arbitration Field Comparison Enable For Rx Mailboxes
    pub mod EACEN {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Rx Mailbox filter's IDE bit is always compared and RTR is never compared despite mask bits.
            pub const EACEN_0: u32 = 0b0;

            /// 0b1: Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with their corresponding bits within the incoming frame. Mask bits do apply.
            pub const EACEN_1: u32 = 0b1;
        }
    }

    /// Remote Request Storing
    pub mod RRS {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Remote Response Frame is generated.
            pub const RRS_0: u32 = 0b0;

            /// 0b1: Remote Request Frame is stored.
            pub const RRS_1: u32 = 0b1;
        }
    }

    /// Mailboxes Reception Priority
    pub mod MRP {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (1 bit: 1 << 18)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Matching starts from Legacy Rx FIFO or Enhanced Rx FIFO and continues on Mailboxes.
            pub const MRP_0: u32 = 0b0;

            /// 0b1: Matching starts from Mailboxes and continues on Legacy Rx FIFO or Enhanced Rx FIFO .
            pub const MRP_1: u32 = 0b1;
        }
    }

    /// Tx Arbitration Start Delay
    pub mod TASD {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (5 bits: 0b11111 << 19)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Number Of Legacy Rx FIFO Filters
    pub mod RFFN {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bus Off Done Interrupt Mask
    pub mod BOFFDONEMSK {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Bus Off Done interrupt disabled.
            pub const BOFFDONEMSK_0: u32 = 0b0;

            /// 0b1: Bus Off Done interrupt enabled.
            pub const BOFFDONEMSK_1: u32 = 0b1;
        }
    }

    /// Error Interrupt Mask for errors detected in the Data Phase of fast CAN FD frames
    pub mod ERRMSK_FAST {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: ERRINT_FAST Error interrupt disabled.
            pub const ERRMSK_FAST_0: u32 = 0b0;

            /// 0b1: ERRINT_FAST Error interrupt enabled.
            pub const ERRMSK_FAST_1: u32 = 0b1;
        }
    }
}

/// Error and Status 2 register
pub mod ESR2 {

    /// Inactive Mailbox
    pub mod IMB {
        /// Offset (13 bits)
        pub const offset: u32 = 13;
        /// Mask (1 bit: 1 << 13)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: If CAN_ESR2\[VPS\] is asserted, the CAN_ESR2\[LPTM\] is not an inactive Mailbox.
            pub const IMB_0: u32 = 0b0;

            /// 0b1: If CAN_ESR2\[VPS\] is asserted, there is at least one inactive Mailbox. LPTM content is the number of the first one.
            pub const IMB_1: u32 = 0b1;
        }
    }

    /// Valid Priority Status
    pub mod VPS {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Contents of IMB and LPTM are invalid.
            pub const VPS_0: u32 = 0b0;

            /// 0b1: Contents of IMB and LPTM are valid.
            pub const VPS_1: u32 = 0b1;
        }
    }

    /// Lowest Priority Tx Mailbox
    pub mod LPTM {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (7 bits: 0x7f << 16)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CRC Register
pub mod CRCR {

    /// Transmitted CRC value
    pub mod TXCRC {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (15 bits: 0x7fff << 0)
        pub const mask: u32 = 0x7fff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// CRC Mailbox
    pub mod MBCRC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (7 bits: 0x7f << 16)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Legacy Rx FIFO Global Mask register
pub mod RXFGMASK {

    /// Legacy Rx FIFO Global Mask Bits
    pub mod FGM {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Legacy Rx FIFO Information Register
pub mod RXFIR {

    /// Identifier Acceptance Filter Hit Indicator
    pub mod IDHIT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (9 bits: 0x1ff << 0)
        pub const mask: u32 = 0x1ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CAN Bit Timing Register
pub mod CBT {

    /// Extended Phase Segment 2
    pub mod EPSEG2 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Phase Segment 1
    pub mod EPSEG1 {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (5 bits: 0b11111 << 5)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Propagation Segment
    pub mod EPROPSEG {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (6 bits: 0x3f << 10)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Resync Jump Width
    pub mod ERJW {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (5 bits: 0b11111 << 16)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Prescaler Division Factor
    pub mod EPRESDIV {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (10 bits: 0x3ff << 21)
        pub const mask: u32 = 0x3ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Timing Format Enable
    pub mod BTF {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Extended bit time definitions disabled.
            pub const BTF_0: u32 = 0b0;

            /// 0b1: Extended bit time definitions enabled.
            pub const BTF_1: u32 = 0b1;
        }
    }
}

/// CS0 and MB0_8B_CS
/// CS0: CS0 and MB0_64B_CS
/// CS0: CS0 and MB0_32B_CS
/// CS0: CS0 and MB0_16B_CS
/// CS0: Message Buffer 0 CS Register
/// MB0_16B_CS: Message Buffer 0 CS Register
/// MB0_32B_CS: Message Buffer 0 CS Register
/// MB0_64B_CS: Message Buffer 0 CS Register
/// MB0_8B_CS: Message Buffer 0 CS Register
pub mod CS0 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID0 and MB0_8B_ID
/// ID0: ID0 and MB0_64B_ID
/// ID0: ID0 and MB0_32B_ID
/// ID0: ID0 and MB0_16B_ID
/// ID0: Message Buffer 0 ID Register
/// MB0_16B_ID: Message Buffer 0 ID Register
/// MB0_32B_ID: Message Buffer 0 ID Register
/// MB0_64B_ID: Message Buffer 0 ID Register
/// MB0_8B_ID: Message Buffer 0 ID Register
pub mod ID0 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0 and WORD00
/// MB0: MB0 and MB0_8B_WORD0
/// MB0: MB0 and MB0_64B_WORD0
/// MB0: MB0_16B_WORD0 and MB0_32B_WORD0
/// MB0_16B_WORD0: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD0: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD0: Message Buffer 0 WORD_64B Register
/// MB0_8B_WORD0: Message Buffer 0 WORD_8B Register
/// WORD00: Message Buffer 0 WORD0 Register
pub mod MB0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_16B_WORD1 and WORD10
/// MB0_16B_WORD1: MB0_16B_WORD1 and MB0_8B_WORD1
/// MB0_16B_WORD1: MB0_16B_WORD1 and MB0_64B_WORD1
/// MB0_16B_WORD1: MB0_16B_WORD1 and MB0_32B_WORD1
/// MB0_16B_WORD1: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD1: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD1: Message Buffer 0 WORD_64B Register
/// MB0_8B_WORD1: Message Buffer 0 WORD_8B Register
/// WORD10: Message Buffer 0 WORD1 Register
pub mod MB0_16B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS1 and MB1_8B_CS
/// CS1: CS1 and MB0_64B_WORD2
/// CS1: CS1 and MB0_32B_WORD2
/// CS1: CS1 and MB0_16B_WORD2
/// CS1: Message Buffer 1 CS Register
/// MB0_16B_WORD2: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD2: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD2: Message Buffer 0 WORD_64B Register
/// MB1_8B_CS: Message Buffer 1 CS Register
pub mod CS1 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID1 and MB1_8B_ID
/// ID1: ID1 and MB0_64B_WORD3
/// ID1: ID1 and MB0_32B_WORD3
/// ID1: ID1 and MB0_16B_WORD3
/// ID1: Message Buffer 1 ID Register
/// MB0_16B_WORD3: Message Buffer 0 WORD_16B Register
/// MB0_32B_WORD3: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD3: Message Buffer 0 WORD_64B Register
/// MB1_8B_ID: Message Buffer 1 ID Register
pub mod ID1 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB and WORD01
/// MB: MB and MB1_8B_WORD0
/// MB: MB0_32B_WORD4 and MB1_16B_CS
/// MB0_32B_WORD4: MB0_32B_WORD4 and MB0_64B_WORD4
/// MB0_32B_WORD4: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD4: Message Buffer 0 WORD_64B Register
/// MB1_16B_CS: Message Buffer 1 CS Register
/// MB1_8B_WORD0: Message Buffer 1 WORD_8B Register
/// WORD01: Message Buffer 1 WORD0 Register
pub mod MB {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_32B_WORD5 and WORD11
/// MB0_32B_WORD5: MB0_32B_WORD5 and MB1_8B_WORD1
/// MB0_32B_WORD5: MB0_32B_WORD5 and MB1_16B_ID
/// MB0_32B_WORD5: MB0_32B_WORD5 and MB0_64B_WORD5
/// MB0_32B_WORD5: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD5: Message Buffer 0 WORD_64B Register
/// MB1_16B_ID: Message Buffer 1 ID Register
/// MB1_8B_WORD1: Message Buffer 1 WORD_8B Register
/// WORD11: Message Buffer 1 WORD1 Register
pub mod MB0_32B_WORD5 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS2 and MB2_8B_CS
/// CS2: CS2 and MB1_16B_WORD0
/// CS2: CS2 and MB0_64B_WORD6
/// CS2: CS2 and MB0_32B_WORD6
/// CS2: Message Buffer 2 CS Register
/// MB0_32B_WORD6: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD6: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD0: Message Buffer 1 WORD_16B Register
/// MB2_8B_CS: Message Buffer 2 CS Register
pub mod CS2 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID2 and MB2_8B_ID
/// ID2: ID2 and MB1_16B_WORD1
/// ID2: ID2 and MB0_64B_WORD7
/// ID2: ID2 and MB0_32B_WORD7
/// ID2: Message Buffer 2 ID Register
/// MB0_32B_WORD7: Message Buffer 0 WORD_32B Register
/// MB0_64B_WORD7: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD1: Message Buffer 1 WORD_16B Register
/// MB2_8B_ID: Message Buffer 2 ID Register
pub mod ID2 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD8 and WORD02
/// MB0_64B_WORD8: MB0_64B_WORD8 and MB2_8B_WORD0
/// MB0_64B_WORD8: MB0_64B_WORD8 and MB1_32B_CS
/// MB0_64B_WORD8: MB0_64B_WORD8 and MB1_16B_WORD2
/// MB0_64B_WORD8: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD2: Message Buffer 1 WORD_16B Register
/// MB1_32B_CS: Message Buffer 1 CS Register
/// MB2_8B_WORD0: Message Buffer 2 WORD_8B Register
/// WORD02: Message Buffer 2 WORD0 Register
pub mod MB0_64B_WORD8 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD9 and WORD12
/// MB0_64B_WORD9: MB0_64B_WORD9 and MB2_8B_WORD1
/// MB0_64B_WORD9: MB0_64B_WORD9 and MB1_32B_ID
/// MB0_64B_WORD9: MB0_64B_WORD9 and MB1_16B_WORD3
/// MB0_64B_WORD9: Message Buffer 0 WORD_64B Register
/// MB1_16B_WORD3: Message Buffer 1 WORD_16B Register
/// MB1_32B_ID: Message Buffer 1 ID Register
/// MB2_8B_WORD1: Message Buffer 2 WORD_8B Register
/// WORD12: Message Buffer 2 WORD1 Register
pub mod MB0_64B_WORD9 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS3 and MB3_8B_CS
/// CS3: CS3 and MB2_16B_CS
/// CS3: CS3 and MB1_32B_WORD0
/// CS3: CS3 and MB0_64B_WORD10
/// CS3: Message Buffer 3 CS Register
/// MB0_64B_WORD10: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD0: Message Buffer 1 WORD_32B Register
/// MB2_16B_CS: Message Buffer 2 CS Register
/// MB3_8B_CS: Message Buffer 3 CS Register
pub mod CS3 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID3 and MB3_8B_ID
/// ID3: ID3 and MB2_16B_ID
/// ID3: ID3 and MB1_32B_WORD1
/// ID3: ID3 and MB0_64B_WORD11
/// ID3: Message Buffer 3 ID Register
/// MB0_64B_WORD11: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD1: Message Buffer 1 WORD_32B Register
/// MB2_16B_ID: Message Buffer 2 ID Register
/// MB3_8B_ID: Message Buffer 3 ID Register
pub mod ID3 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD12 and WORD03
/// MB0_64B_WORD12: MB0_64B_WORD12 and MB3_8B_WORD0
/// MB0_64B_WORD12: MB0_64B_WORD12 and MB2_16B_WORD0
/// MB0_64B_WORD12: MB0_64B_WORD12 and MB1_32B_WORD2
/// MB0_64B_WORD12: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD2: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD0: Message Buffer 2 WORD_16B Register
/// MB3_8B_WORD0: Message Buffer 3 WORD_8B Register
/// WORD03: Message Buffer 3 WORD0 Register
pub mod MB0_64B_WORD12 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB0_64B_WORD13 and WORD13
/// MB0_64B_WORD13: MB0_64B_WORD13 and MB3_8B_WORD1
/// MB0_64B_WORD13: MB0_64B_WORD13 and MB2_16B_WORD1
/// MB0_64B_WORD13: MB0_64B_WORD13 and MB1_32B_WORD3
/// MB0_64B_WORD13: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD3: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD1: Message Buffer 2 WORD_16B Register
/// MB3_8B_WORD1: Message Buffer 3 WORD_8B Register
/// WORD13: Message Buffer 3 WORD1 Register
pub mod MB0_64B_WORD13 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS4 and MB4_8B_CS
/// CS4: CS4 and MB2_16B_WORD2
/// CS4: CS4 and MB1_32B_WORD4
/// CS4: CS4 and MB0_64B_WORD14
/// CS4: Message Buffer 4 CS Register
/// MB0_64B_WORD14: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD4: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD2: Message Buffer 2 WORD_16B Register
/// MB4_8B_CS: Message Buffer 4 CS Register
pub mod CS4 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID4 and MB4_8B_ID
/// ID4: ID4 and MB2_16B_WORD3
/// ID4: ID4 and MB1_32B_WORD5
/// ID4: ID4 and MB0_64B_WORD15
/// ID4: Message Buffer 4 ID Register
/// MB0_64B_WORD15: Message Buffer 0 WORD_64B Register
/// MB1_32B_WORD5: Message Buffer 1 WORD_32B Register
/// MB2_16B_WORD3: Message Buffer 2 WORD_16B Register
/// MB4_8B_ID: Message Buffer 4 ID Register
pub mod ID4 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1 and WORD04
/// MB1: MB1 and MB4_8B_WORD0
/// MB1: MB1 and MB3_16B_CS
/// MB1: MB1_32B_WORD6 and MB1_64B_CS
/// MB1_32B_WORD6: Message Buffer 1 WORD_32B Register
/// MB1_64B_CS: Message Buffer 1 CS Register
/// MB3_16B_CS: Message Buffer 3 CS Register
/// MB4_8B_WORD0: Message Buffer 4 WORD_8B Register
/// WORD04: Message Buffer 4 WORD0 Register
pub mod MB1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_32B_WORD7 and WORD14
/// MB1_32B_WORD7: MB1_32B_WORD7 and MB4_8B_WORD1
/// MB1_32B_WORD7: MB1_32B_WORD7 and MB3_16B_ID
/// MB1_32B_WORD7: MB1_32B_WORD7 and MB1_64B_ID
/// MB1_32B_WORD7: Message Buffer 1 WORD_32B Register
/// MB1_64B_ID: Message Buffer 1 ID Register
/// MB3_16B_ID: Message Buffer 3 ID Register
/// MB4_8B_WORD1: Message Buffer 4 WORD_8B Register
/// WORD14: Message Buffer 4 WORD1 Register
pub mod MB1_32B_WORD7 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS5 and MB5_8B_CS
/// CS5: CS5 and MB3_16B_WORD0
/// CS5: CS5 and MB2_32B_CS
/// CS5: CS5 and MB1_64B_WORD0
/// CS5: Message Buffer 5 CS Register
/// MB1_64B_WORD0: Message Buffer 1 WORD_64B Register
/// MB2_32B_CS: Message Buffer 2 CS Register
/// MB3_16B_WORD0: Message Buffer 3 WORD_16B Register
/// MB5_8B_CS: Message Buffer 5 CS Register
pub mod CS5 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID5 and MB5_8B_ID
/// ID5: ID5 and MB3_16B_WORD1
/// ID5: ID5 and MB2_32B_ID
/// ID5: ID5 and MB1_64B_WORD1
/// ID5: Message Buffer 5 ID Register
/// MB1_64B_WORD1: Message Buffer 1 WORD_64B Register
/// MB2_32B_ID: Message Buffer 2 ID Register
/// MB3_16B_WORD1: Message Buffer 3 WORD_16B Register
/// MB5_8B_ID: Message Buffer 5 ID Register
pub mod ID5 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD2 and WORD05
/// MB1_64B_WORD2: MB1_64B_WORD2 and MB5_8B_WORD0
/// MB1_64B_WORD2: MB1_64B_WORD2 and MB3_16B_WORD2
/// MB1_64B_WORD2: MB1_64B_WORD2 and MB2_32B_WORD0
/// MB1_64B_WORD2: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD0: Message Buffer 2 WORD_32B Register
/// MB3_16B_WORD2: Message Buffer 3 WORD_16B Register
/// MB5_8B_WORD0: Message Buffer 5 WORD_8B Register
/// WORD05: Message Buffer 5 WORD0 Register
pub mod MB1_64B_WORD2 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD3 and WORD15
/// MB1_64B_WORD3: MB1_64B_WORD3 and MB5_8B_WORD1
/// MB1_64B_WORD3: MB1_64B_WORD3 and MB3_16B_WORD3
/// MB1_64B_WORD3: MB1_64B_WORD3 and MB2_32B_WORD1
/// MB1_64B_WORD3: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD1: Message Buffer 2 WORD_32B Register
/// MB3_16B_WORD3: Message Buffer 3 WORD_16B Register
/// MB5_8B_WORD1: Message Buffer 5 WORD_8B Register
/// WORD15: Message Buffer 5 WORD1 Register
pub mod MB1_64B_WORD3 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS6 and MB6_8B_CS
/// CS6: CS6 and MB4_16B_CS
/// CS6: CS6 and MB2_32B_WORD2
/// CS6: CS6 and MB1_64B_WORD4
/// CS6: Message Buffer 6 CS Register
/// MB1_64B_WORD4: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD2: Message Buffer 2 WORD_32B Register
/// MB4_16B_CS: Message Buffer 4 CS Register
/// MB6_8B_CS: Message Buffer 6 CS Register
pub mod CS6 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID6 and MB6_8B_ID
/// ID6: ID6 and MB4_16B_ID
/// ID6: ID6 and MB2_32B_WORD3
/// ID6: ID6 and MB1_64B_WORD5
/// ID6: Message Buffer 6 ID Register
/// MB1_64B_WORD5: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD3: Message Buffer 2 WORD_32B Register
/// MB4_16B_ID: Message Buffer 4 ID Register
/// MB6_8B_ID: Message Buffer 6 ID Register
pub mod ID6 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD6 and WORD06
/// MB1_64B_WORD6: MB1_64B_WORD6 and MB6_8B_WORD0
/// MB1_64B_WORD6: MB1_64B_WORD6 and MB4_16B_WORD0
/// MB1_64B_WORD6: MB1_64B_WORD6 and MB2_32B_WORD4
/// MB1_64B_WORD6: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD4: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD0: Message Buffer 4 WORD_16B Register
/// MB6_8B_WORD0: Message Buffer 6 WORD_8B Register
/// WORD06: Message Buffer 6 WORD0 Register
pub mod MB1_64B_WORD6 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD7 and WORD16
/// MB1_64B_WORD7: MB1_64B_WORD7 and MB6_8B_WORD1
/// MB1_64B_WORD7: MB1_64B_WORD7 and MB4_16B_WORD1
/// MB1_64B_WORD7: MB1_64B_WORD7 and MB2_32B_WORD5
/// MB1_64B_WORD7: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD5: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD1: Message Buffer 4 WORD_16B Register
/// MB6_8B_WORD1: Message Buffer 6 WORD_8B Register
/// WORD16: Message Buffer 6 WORD1 Register
pub mod MB1_64B_WORD7 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS7 and MB7_8B_CS
/// CS7: CS7 and MB4_16B_WORD2
/// CS7: CS7 and MB2_32B_WORD6
/// CS7: CS7 and MB1_64B_WORD8
/// CS7: Message Buffer 7 CS Register
/// MB1_64B_WORD8: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD6: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD2: Message Buffer 4 WORD_16B Register
/// MB7_8B_CS: Message Buffer 7 CS Register
pub mod CS7 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID7 and MB7_8B_ID
/// ID7: ID7 and MB4_16B_WORD3
/// ID7: ID7 and MB2_32B_WORD7
/// ID7: ID7 and MB1_64B_WORD9
/// ID7: Message Buffer 7 ID Register
/// MB1_64B_WORD9: Message Buffer 1 WORD_64B Register
/// MB2_32B_WORD7: Message Buffer 2 WORD_32B Register
/// MB4_16B_WORD3: Message Buffer 4 WORD_16B Register
/// MB7_8B_ID: Message Buffer 7 ID Register
pub mod ID7 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD10 and WORD07
/// MB1_64B_WORD10: MB1_64B_WORD10 and MB7_8B_WORD0
/// MB1_64B_WORD10: MB1_64B_WORD10 and MB5_16B_CS
/// MB1_64B_WORD10: MB1_64B_WORD10 and MB3_32B_CS
/// MB1_64B_WORD10: Message Buffer 1 WORD_64B Register
/// MB3_32B_CS: Message Buffer 3 CS Register
/// MB5_16B_CS: Message Buffer 5 CS Register
/// MB7_8B_WORD0: Message Buffer 7 WORD_8B Register
/// WORD07: Message Buffer 7 WORD0 Register
pub mod MB1_64B_WORD10 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD11 and WORD17
/// MB1_64B_WORD11: MB1_64B_WORD11 and MB7_8B_WORD1
/// MB1_64B_WORD11: MB1_64B_WORD11 and MB5_16B_ID
/// MB1_64B_WORD11: MB1_64B_WORD11 and MB3_32B_ID
/// MB1_64B_WORD11: Message Buffer 1 WORD_64B Register
/// MB3_32B_ID: Message Buffer 3 ID Register
/// MB5_16B_ID: Message Buffer 5 ID Register
/// MB7_8B_WORD1: Message Buffer 7 WORD_8B Register
/// WORD17: Message Buffer 7 WORD1 Register
pub mod MB1_64B_WORD11 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS8 and MB8_8B_CS
/// CS8: CS8 and MB5_16B_WORD0
/// CS8: CS8 and MB3_32B_WORD0
/// CS8: CS8 and MB1_64B_WORD12
/// CS8: Message Buffer 8 CS Register
/// MB1_64B_WORD12: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD0: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD0: Message Buffer 5 WORD_16B Register
/// MB8_8B_CS: Message Buffer 8 CS Register
pub mod CS8 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID8 and MB8_8B_ID
/// ID8: ID8 and MB5_16B_WORD1
/// ID8: ID8 and MB3_32B_WORD1
/// ID8: ID8 and MB1_64B_WORD13
/// ID8: Message Buffer 8 ID Register
/// MB1_64B_WORD13: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD1: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD1: Message Buffer 5 WORD_16B Register
/// MB8_8B_ID: Message Buffer 8 ID Register
pub mod ID8 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD14 and WORD08
/// MB1_64B_WORD14: MB1_64B_WORD14 and MB8_8B_WORD0
/// MB1_64B_WORD14: MB1_64B_WORD14 and MB5_16B_WORD2
/// MB1_64B_WORD14: MB1_64B_WORD14 and MB3_32B_WORD2
/// MB1_64B_WORD14: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD2: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD2: Message Buffer 5 WORD_16B Register
/// MB8_8B_WORD0: Message Buffer 8 WORD_8B Register
/// WORD08: Message Buffer 8 WORD0 Register
pub mod MB1_64B_WORD14 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB1_64B_WORD15 and WORD18
/// MB1_64B_WORD15: MB1_64B_WORD15 and MB8_8B_WORD1
/// MB1_64B_WORD15: MB1_64B_WORD15 and MB5_16B_WORD3
/// MB1_64B_WORD15: MB1_64B_WORD15 and MB3_32B_WORD3
/// MB1_64B_WORD15: Message Buffer 1 WORD_64B Register
/// MB3_32B_WORD3: Message Buffer 3 WORD_32B Register
/// MB5_16B_WORD3: Message Buffer 5 WORD_16B Register
/// MB8_8B_WORD1: Message Buffer 8 WORD_8B Register
/// WORD18: Message Buffer 8 WORD1 Register
pub mod MB1_64B_WORD15 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS9 and MB9_8B_CS
/// CS9: CS9 and MB6_16B_CS
/// CS9: CS9 and MB3_32B_WORD4
/// CS9: CS9 and MB2_64B_CS
/// CS9: Message Buffer 9 CS Register
/// MB2_64B_CS: Message Buffer 2 CS Register
/// MB3_32B_WORD4: Message Buffer 3 WORD_32B Register
/// MB6_16B_CS: Message Buffer 6 CS Register
/// MB9_8B_CS: Message Buffer 9 CS Register
pub mod CS9 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID9 and MB9_8B_ID
/// ID9: ID9 and MB6_16B_ID
/// ID9: ID9 and MB3_32B_WORD5
/// ID9: ID9 and MB2_64B_ID
/// ID9: Message Buffer 9 ID Register
/// MB2_64B_ID: Message Buffer 2 ID Register
/// MB3_32B_WORD5: Message Buffer 3 WORD_32B Register
/// MB6_16B_ID: Message Buffer 6 ID Register
/// MB9_8B_ID: Message Buffer 9 ID Register
pub mod ID9 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB2_64B_WORD0 and WORD09
/// MB2_64B_WORD0: MB2_64B_WORD0 and MB9_8B_WORD0
/// MB2_64B_WORD0: MB2_64B_WORD0 and MB6_16B_WORD0
/// MB2_64B_WORD0: MB2_64B_WORD0 and MB3_32B_WORD6
/// MB2_64B_WORD0: Message Buffer 2 WORD_64B Register
/// MB3_32B_WORD6: Message Buffer 3 WORD_32B Register
/// MB6_16B_WORD0: Message Buffer 6 WORD_16B Register
/// MB9_8B_WORD0: Message Buffer 9 WORD_8B Register
/// WORD09: Message Buffer 9 WORD0 Register
pub mod MB2_64B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB2_64B_WORD1 and WORD19
/// MB2_64B_WORD1: MB2_64B_WORD1 and MB9_8B_WORD1
/// MB2_64B_WORD1: MB2_64B_WORD1 and MB6_16B_WORD1
/// MB2_64B_WORD1: MB2_64B_WORD1 and MB3_32B_WORD7
/// MB2_64B_WORD1: Message Buffer 2 WORD_64B Register
/// MB3_32B_WORD7: Message Buffer 3 WORD_32B Register
/// MB6_16B_WORD1: Message Buffer 6 WORD_16B Register
/// MB9_8B_WORD1: Message Buffer 9 WORD_8B Register
/// WORD19: Message Buffer 9 WORD1 Register
pub mod MB2_64B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS10 and MB6_16B_WORD2
/// CS10: CS10 and MB4_32B_CS
/// CS10: CS10 and MB2_64B_WORD2
/// CS10: CS10 and MB10_8B_CS
/// CS10: Message Buffer 10 CS Register
/// MB10_8B_CS: Message Buffer 10 CS Register
/// MB2_64B_WORD2: Message Buffer 2 WORD_64B Register
/// MB4_32B_CS: Message Buffer 4 CS Register
/// MB6_16B_WORD2: Message Buffer 6 WORD_16B Register
pub mod CS10 {
    pub use super::CS1::BRS;
    pub use super::CS1::CODE;
    pub use super::CS1::DATA_BYTE_10;
    pub use super::CS1::DATA_BYTE_11;
    pub use super::CS1::DATA_BYTE_8;
    pub use super::CS1::DATA_BYTE_9;
    pub use super::CS1::DLC;
    pub use super::CS1::EDL;
    pub use super::CS1::ESI;
    pub use super::CS1::IDE;
    pub use super::CS1::RTR;
    pub use super::CS1::SRR;
    pub use super::CS1::TIME_STAMP;
}

/// ID10 and MB6_16B_WORD3
/// ID10: ID10 and MB4_32B_ID
/// ID10: ID10 and MB2_64B_WORD3
/// ID10: ID10 and MB10_8B_ID
/// ID10: Message Buffer 10 ID Register
/// MB10_8B_ID: Message Buffer 10 ID Register
/// MB2_64B_WORD3: Message Buffer 2 WORD_64B Register
/// MB4_32B_ID: Message Buffer 4 ID Register
/// MB6_16B_WORD3: Message Buffer 6 WORD_16B Register
pub mod ID10 {
    pub use super::ID1::DATA_BYTE_12;
    pub use super::ID1::DATA_BYTE_13;
    pub use super::ID1::DATA_BYTE_14;
    pub use super::ID1::DATA_BYTE_15;
    pub use super::ID1::EXT;
    pub use super::ID1::PRIO;
    pub use super::ID1::STD;
}

/// MB10_8B_WORD0 and WORD010
/// MB10_8B_WORD0: MB10_8B_WORD0 and MB7_16B_CS
/// MB10_8B_WORD0: MB10_8B_WORD0 and MB4_32B_WORD0
/// MB10_8B_WORD0: MB10_8B_WORD0 and MB2_64B_WORD4
/// MB10_8B_WORD0: Message Buffer 10 WORD_8B Register
/// MB2_64B_WORD4: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD0: Message Buffer 4 WORD_32B Register
/// MB7_16B_CS: Message Buffer 7 CS Register
/// WORD010: Message Buffer 10 WORD0 Register
pub mod MB10_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_8B_WORD1 and WORD110
/// MB10_8B_WORD1: MB10_8B_WORD1 and MB7_16B_ID
/// MB10_8B_WORD1: MB10_8B_WORD1 and MB4_32B_WORD1
/// MB10_8B_WORD1: MB10_8B_WORD1 and MB2_64B_WORD5
/// MB10_8B_WORD1: Message Buffer 10 WORD_8B Register
/// MB2_64B_WORD5: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD1: Message Buffer 4 WORD_32B Register
/// MB7_16B_ID: Message Buffer 7 ID Register
/// WORD110: Message Buffer 10 WORD1 Register
pub mod MB10_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS11 and MB7_16B_WORD0
/// CS11: CS11 and MB4_32B_WORD2
/// CS11: CS11 and MB2_64B_WORD6
/// CS11: CS11 and MB11_8B_CS
/// CS11: Message Buffer 11 CS Register
/// MB11_8B_CS: Message Buffer 11 CS Register
/// MB2_64B_WORD6: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD2: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD0: Message Buffer 7 WORD_16B Register
pub mod CS11 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID11 and MB7_16B_WORD1
/// ID11: ID11 and MB4_32B_WORD3
/// ID11: ID11 and MB2_64B_WORD7
/// ID11: ID11 and MB11_8B_ID
/// ID11: Message Buffer 11 ID Register
/// MB11_8B_ID: Message Buffer 11 ID Register
/// MB2_64B_WORD7: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD3: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD1: Message Buffer 7 WORD_16B Register
pub mod ID11 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_8B_WORD0 and WORD011
/// MB11_8B_WORD0: MB11_8B_WORD0 and MB7_16B_WORD2
/// MB11_8B_WORD0: MB11_8B_WORD0 and MB4_32B_WORD4
/// MB11_8B_WORD0: MB11_8B_WORD0 and MB2_64B_WORD8
/// MB11_8B_WORD0: Message Buffer 11 WORD_8B Register
/// MB2_64B_WORD8: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD4: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD2: Message Buffer 7 WORD_16B Register
/// WORD011: Message Buffer 11 WORD0 Register
pub mod MB11_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_8B_WORD1 and WORD111
/// MB11_8B_WORD1: MB11_8B_WORD1 and MB7_16B_WORD3
/// MB11_8B_WORD1: MB11_8B_WORD1 and MB4_32B_WORD5
/// MB11_8B_WORD1: MB11_8B_WORD1 and MB2_64B_WORD9
/// MB11_8B_WORD1: Message Buffer 11 WORD_8B Register
/// MB2_64B_WORD9: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD5: Message Buffer 4 WORD_32B Register
/// MB7_16B_WORD3: Message Buffer 7 WORD_16B Register
/// WORD111: Message Buffer 11 WORD1 Register
pub mod MB11_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS12 and MB8_16B_CS
/// CS12: CS12 and MB4_32B_WORD6
/// CS12: CS12 and MB2_64B_WORD10
/// CS12: CS12 and MB12_8B_CS
/// CS12: Message Buffer 12 CS Register
/// MB12_8B_CS: Message Buffer 12 CS Register
/// MB2_64B_WORD10: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD6: Message Buffer 4 WORD_32B Register
/// MB8_16B_CS: Message Buffer 8 CS Register
pub mod CS12 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID12 and MB8_16B_ID
/// ID12: ID12 and MB4_32B_WORD7
/// ID12: ID12 and MB2_64B_WORD11
/// ID12: ID12 and MB12_8B_ID
/// ID12: Message Buffer 12 ID Register
/// MB12_8B_ID: Message Buffer 12 ID Register
/// MB2_64B_WORD11: Message Buffer 2 WORD_64B Register
/// MB4_32B_WORD7: Message Buffer 4 WORD_32B Register
/// MB8_16B_ID: Message Buffer 8 ID Register
pub mod ID12 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_8B_WORD0 and WORD012
/// MB12_8B_WORD0: MB12_8B_WORD0 and MB8_16B_WORD0
/// MB12_8B_WORD0: MB12_8B_WORD0 and MB5_32B_CS
/// MB12_8B_WORD0: MB12_8B_WORD0 and MB2_64B_WORD12
/// MB12_8B_WORD0: Message Buffer 12 WORD_8B Register
/// MB2_64B_WORD12: Message Buffer 2 WORD_64B Register
/// MB5_32B_CS: Message Buffer 5 CS Register
/// MB8_16B_WORD0: Message Buffer 8 WORD_16B Register
/// WORD012: Message Buffer 12 WORD0 Register
pub mod MB12_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_8B_WORD1 and WORD112
/// MB12_8B_WORD1: MB12_8B_WORD1 and MB8_16B_WORD1
/// MB12_8B_WORD1: MB12_8B_WORD1 and MB5_32B_ID
/// MB12_8B_WORD1: MB12_8B_WORD1 and MB2_64B_WORD13
/// MB12_8B_WORD1: Message Buffer 12 WORD_8B Register
/// MB2_64B_WORD13: Message Buffer 2 WORD_64B Register
/// MB5_32B_ID: Message Buffer 5 ID Register
/// MB8_16B_WORD1: Message Buffer 8 WORD_16B Register
/// WORD112: Message Buffer 12 WORD1 Register
pub mod MB12_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS13 and MB8_16B_WORD2
/// CS13: CS13 and MB5_32B_WORD0
/// CS13: CS13 and MB2_64B_WORD14
/// CS13: CS13 and MB13_8B_CS
/// CS13: Message Buffer 13 CS Register
/// MB13_8B_CS: Message Buffer 13 CS Register
/// MB2_64B_WORD14: Message Buffer 2 WORD_64B Register
/// MB5_32B_WORD0: Message Buffer 5 WORD_32B Register
/// MB8_16B_WORD2: Message Buffer 8 WORD_16B Register
pub mod CS13 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID13 and MB8_16B_WORD3
/// ID13: ID13 and MB5_32B_WORD1
/// ID13: ID13 and MB2_64B_WORD15
/// ID13: ID13 and MB13_8B_ID
/// ID13: Message Buffer 13 ID Register
/// MB13_8B_ID: Message Buffer 13 ID Register
/// MB2_64B_WORD15: Message Buffer 2 WORD_64B Register
/// MB5_32B_WORD1: Message Buffer 5 WORD_32B Register
/// MB8_16B_WORD3: Message Buffer 8 WORD_16B Register
pub mod ID13 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_8B_WORD0 and WORD013
/// MB13_8B_WORD0: MB13_8B_WORD0 and MB9_16B_CS
/// MB13_8B_WORD0: MB13_8B_WORD0 and MB5_32B_WORD2
/// MB13_8B_WORD0: MB13_8B_WORD0 and MB3_64B_CS
/// MB13_8B_WORD0: Message Buffer 13 WORD_8B Register
/// MB3_64B_CS: Message Buffer 3 CS Register
/// MB5_32B_WORD2: Message Buffer 5 WORD_32B Register
/// MB9_16B_CS: Message Buffer 9 CS Register
/// WORD013: Message Buffer 13 WORD0 Register
pub mod MB13_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_8B_WORD1 and WORD113
/// MB13_8B_WORD1: MB13_8B_WORD1 and MB9_16B_ID
/// MB13_8B_WORD1: MB13_8B_WORD1 and MB5_32B_WORD3
/// MB13_8B_WORD1: MB13_8B_WORD1 and MB3_64B_ID
/// MB13_8B_WORD1: Message Buffer 13 WORD_8B Register
/// MB3_64B_ID: Message Buffer 3 ID Register
/// MB5_32B_WORD3: Message Buffer 5 WORD_32B Register
/// MB9_16B_ID: Message Buffer 9 ID Register
/// WORD113: Message Buffer 13 WORD1 Register
pub mod MB13_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS14 and MB9_16B_WORD0
/// CS14: CS14 and MB5_32B_WORD4
/// CS14: CS14 and MB3_64B_WORD0
/// CS14: CS14 and MB14_8B_CS
/// CS14: Message Buffer 14 CS Register
/// MB14_8B_CS: Message Buffer 14 CS Register
/// MB3_64B_WORD0: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD4: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD0: Message Buffer 9 WORD_16B Register
pub mod CS14 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID14 and MB9_16B_WORD1
/// ID14: ID14 and MB5_32B_WORD5
/// ID14: ID14 and MB3_64B_WORD1
/// ID14: ID14 and MB14_8B_ID
/// ID14: Message Buffer 14 ID Register
/// MB14_8B_ID: Message Buffer 14 ID Register
/// MB3_64B_WORD1: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD5: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD1: Message Buffer 9 WORD_16B Register
pub mod ID14 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_8B_WORD0 and WORD014
/// MB14_8B_WORD0: MB14_8B_WORD0 and MB9_16B_WORD2
/// MB14_8B_WORD0: MB14_8B_WORD0 and MB5_32B_WORD6
/// MB14_8B_WORD0: MB14_8B_WORD0 and MB3_64B_WORD2
/// MB14_8B_WORD0: Message Buffer 14 WORD_8B Register
/// MB3_64B_WORD2: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD6: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD2: Message Buffer 9 WORD_16B Register
/// WORD014: Message Buffer 14 WORD0 Register
pub mod MB14_8B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_8B_WORD1 and WORD114
/// MB14_8B_WORD1: MB14_8B_WORD1 and MB9_16B_WORD3
/// MB14_8B_WORD1: MB14_8B_WORD1 and MB5_32B_WORD7
/// MB14_8B_WORD1: MB14_8B_WORD1 and MB3_64B_WORD3
/// MB14_8B_WORD1: Message Buffer 14 WORD_8B Register
/// MB3_64B_WORD3: Message Buffer 3 WORD_64B Register
/// MB5_32B_WORD7: Message Buffer 5 WORD_32B Register
/// MB9_16B_WORD3: Message Buffer 9 WORD_16B Register
/// WORD114: Message Buffer 14 WORD1 Register
pub mod MB14_8B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS15 and MB6_32B_CS
/// CS15: CS15 and MB3_64B_WORD4
/// CS15: CS15 and MB15_8B_CS
/// CS15: CS15 and MB10_16B_CS
/// CS15: Message Buffer 15 CS Register
/// MB10_16B_CS: Message Buffer 10 CS Register
/// MB15_8B_CS: Message Buffer 15 CS Register
/// MB3_64B_WORD4: Message Buffer 3 WORD_64B Register
/// MB6_32B_CS: Message Buffer 6 CS Register
pub mod CS15 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID15 and MB6_32B_ID
/// ID15: ID15 and MB3_64B_WORD5
/// ID15: ID15 and MB15_8B_ID
/// ID15: ID15 and MB10_16B_ID
/// ID15: Message Buffer 15 ID Register
/// MB10_16B_ID: Message Buffer 10 ID Register
/// MB15_8B_ID: Message Buffer 15 ID Register
/// MB3_64B_WORD5: Message Buffer 3 WORD_64B Register
/// MB6_32B_ID: Message Buffer 6 ID Register
pub mod ID15 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB10_16B_WORD0 and WORD015
/// MB10_16B_WORD0: MB10_16B_WORD0 and MB6_32B_WORD0
/// MB10_16B_WORD0: MB10_16B_WORD0 and MB3_64B_WORD6
/// MB10_16B_WORD0: MB10_16B_WORD0 and MB15_8B_WORD0
/// MB10_16B_WORD0: Message Buffer 10 WORD_16B Register
/// MB15_8B_WORD0: Message Buffer 15 WORD_8B Register
/// MB3_64B_WORD6: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD0: Message Buffer 6 WORD_32B Register
/// WORD015: Message Buffer 15 WORD0 Register
pub mod MB10_16B_WORD0 {
    pub use super::MB2_64B_WORD0::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0::DATA_BYTE_3;
}

/// MB10_16B_WORD1 and WORD115
/// MB10_16B_WORD1: MB10_16B_WORD1 and MB6_32B_WORD1
/// MB10_16B_WORD1: MB10_16B_WORD1 and MB3_64B_WORD7
/// MB10_16B_WORD1: MB10_16B_WORD1 and MB15_8B_WORD1
/// MB10_16B_WORD1: Message Buffer 10 WORD_16B Register
/// MB15_8B_WORD1: Message Buffer 15 WORD_8B Register
/// MB3_64B_WORD7: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD1: Message Buffer 6 WORD_32B Register
/// WORD115: Message Buffer 15 WORD1 Register
pub mod MB10_16B_WORD1 {
    pub use super::MB2_64B_WORD1::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1::DATA_BYTE_7;
}

/// CS16 and MB6_32B_WORD2
/// CS16: CS16 and MB3_64B_WORD8
/// CS16: CS16 and MB16_8B_CS
/// CS16: CS16 and MB10_16B_WORD2
/// CS16: Message Buffer 16 CS Register
/// MB10_16B_WORD2: Message Buffer 10 WORD_16B Register
/// MB16_8B_CS: Message Buffer 16 CS Register
/// MB3_64B_WORD8: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD2: Message Buffer 6 WORD_32B Register
pub mod CS16 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID16 and MB6_32B_WORD3
/// ID16: ID16 and MB3_64B_WORD9
/// ID16: ID16 and MB16_8B_ID
/// ID16: ID16 and MB10_16B_WORD3
/// ID16: Message Buffer 16 ID Register
/// MB10_16B_WORD3: Message Buffer 10 WORD_16B Register
/// MB16_8B_ID: Message Buffer 16 ID Register
/// MB3_64B_WORD9: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD3: Message Buffer 6 WORD_32B Register
pub mod ID16 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_CS and WORD016
/// MB11_16B_CS: MB11_16B_CS and MB6_32B_WORD4
/// MB11_16B_CS: MB11_16B_CS and MB3_64B_WORD10
/// MB11_16B_CS: MB11_16B_CS and MB16_8B_WORD0
/// MB11_16B_CS: Message Buffer 11 CS Register
/// MB16_8B_WORD0: Message Buffer 16 WORD_8B Register
/// MB3_64B_WORD10: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD4: Message Buffer 6 WORD_32B Register
/// WORD016: Message Buffer 16 WORD0 Register
pub mod MB11_16B_CS {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_ID and WORD116
/// MB11_16B_ID: MB11_16B_ID and MB6_32B_WORD5
/// MB11_16B_ID: MB11_16B_ID and MB3_64B_WORD11
/// MB11_16B_ID: MB11_16B_ID and MB16_8B_WORD1
/// MB11_16B_ID: Message Buffer 11 ID Register
/// MB16_8B_WORD1: Message Buffer 16 WORD_8B Register
/// MB3_64B_WORD11: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD5: Message Buffer 6 WORD_32B Register
/// WORD116: Message Buffer 16 WORD1 Register
pub mod MB11_16B_ID {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS17 and MB6_32B_WORD6
/// CS17: CS17 and MB3_64B_WORD12
/// CS17: CS17 and MB17_8B_CS
/// CS17: CS17 and MB11_16B_WORD0
/// CS17: Message Buffer 17 CS Register
/// MB11_16B_WORD0: Message Buffer 11 WORD_16B Register
/// MB17_8B_CS: Message Buffer 17 CS Register
/// MB3_64B_WORD12: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD6: Message Buffer 6 WORD_32B Register
pub mod CS17 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID17 and MB6_32B_WORD7
/// ID17: ID17 and MB3_64B_WORD13
/// ID17: ID17 and MB17_8B_ID
/// ID17: ID17 and MB11_16B_WORD1
/// ID17: Message Buffer 17 ID Register
/// MB11_16B_WORD1: Message Buffer 11 WORD_16B Register
/// MB17_8B_ID: Message Buffer 17 ID Register
/// MB3_64B_WORD13: Message Buffer 3 WORD_64B Register
/// MB6_32B_WORD7: Message Buffer 6 WORD_32B Register
pub mod ID17 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_WORD2 and WORD017
/// MB11_16B_WORD2: MB11_16B_WORD2 and MB7_32B_CS
/// MB11_16B_WORD2: MB11_16B_WORD2 and MB3_64B_WORD14
/// MB11_16B_WORD2: MB11_16B_WORD2 and MB17_8B_WORD0
/// MB11_16B_WORD2: Message Buffer 11 WORD_16B Register
/// MB17_8B_WORD0: Message Buffer 17 WORD_8B Register
/// MB3_64B_WORD14: Message Buffer 3 WORD_64B Register
/// MB7_32B_CS: Message Buffer 7 CS Register
/// WORD017: Message Buffer 17 WORD0 Register
pub mod MB11_16B_WORD2 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_16B_WORD3 and WORD117
/// MB11_16B_WORD3: MB11_16B_WORD3 and MB7_32B_ID
/// MB11_16B_WORD3: MB11_16B_WORD3 and MB3_64B_WORD15
/// MB11_16B_WORD3: MB11_16B_WORD3 and MB17_8B_WORD1
/// MB11_16B_WORD3: Message Buffer 11 WORD_16B Register
/// MB17_8B_WORD1: Message Buffer 17 WORD_8B Register
/// MB3_64B_WORD15: Message Buffer 3 WORD_64B Register
/// MB7_32B_ID: Message Buffer 7 ID Register
/// WORD117: Message Buffer 17 WORD1 Register
pub mod MB11_16B_WORD3 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS18 and MB7_32B_WORD0
/// CS18: CS18 and MB4_64B_CS
/// CS18: CS18 and MB18_8B_CS
/// CS18: CS18 and MB12_16B_CS
/// CS18: Message Buffer 18 CS Register
/// MB12_16B_CS: Message Buffer 12 CS Register
/// MB18_8B_CS: Message Buffer 18 CS Register
/// MB4_64B_CS: Message Buffer 4 CS Register
/// MB7_32B_WORD0: Message Buffer 7 WORD_32B Register
pub mod CS18 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID18 and MB7_32B_WORD1
/// ID18: ID18 and MB4_64B_ID
/// ID18: ID18 and MB18_8B_ID
/// ID18: ID18 and MB12_16B_ID
/// ID18: Message Buffer 18 ID Register
/// MB12_16B_ID: Message Buffer 12 ID Register
/// MB18_8B_ID: Message Buffer 18 ID Register
/// MB4_64B_ID: Message Buffer 4 ID Register
/// MB7_32B_WORD1: Message Buffer 7 WORD_32B Register
pub mod ID18 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB12_16B_WORD0 and WORD018
/// MB12_16B_WORD0: MB12_16B_WORD0 and MB7_32B_WORD2
/// MB12_16B_WORD0: MB12_16B_WORD0 and MB4_64B_WORD0
/// MB12_16B_WORD0: MB12_16B_WORD0 and MB18_8B_WORD0
/// MB12_16B_WORD0: Message Buffer 12 WORD_16B Register
/// MB18_8B_WORD0: Message Buffer 18 WORD_8B Register
/// MB4_64B_WORD0: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD2: Message Buffer 7 WORD_32B Register
/// WORD018: Message Buffer 18 WORD0 Register
pub mod MB12_16B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_16B_WORD1 and WORD118
/// MB12_16B_WORD1: MB12_16B_WORD1 and MB7_32B_WORD3
/// MB12_16B_WORD1: MB12_16B_WORD1 and MB4_64B_WORD1
/// MB12_16B_WORD1: MB12_16B_WORD1 and MB18_8B_WORD1
/// MB12_16B_WORD1: Message Buffer 12 WORD_16B Register
/// MB18_8B_WORD1: Message Buffer 18 WORD_8B Register
/// MB4_64B_WORD1: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD3: Message Buffer 7 WORD_32B Register
/// WORD118: Message Buffer 18 WORD1 Register
pub mod MB12_16B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS19 and MB7_32B_WORD4
/// CS19: CS19 and MB4_64B_WORD2
/// CS19: CS19 and MB19_8B_CS
/// CS19: CS19 and MB12_16B_WORD2
/// CS19: Message Buffer 19 CS Register
/// MB12_16B_WORD2: Message Buffer 12 WORD_16B Register
/// MB19_8B_CS: Message Buffer 19 CS Register
/// MB4_64B_WORD2: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD4: Message Buffer 7 WORD_32B Register
pub mod CS19 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID19 and MB7_32B_WORD5
/// ID19: ID19 and MB4_64B_WORD3
/// ID19: ID19 and MB19_8B_ID
/// ID19: ID19 and MB12_16B_WORD3
/// ID19: Message Buffer 19 ID Register
/// MB12_16B_WORD3: Message Buffer 12 WORD_16B Register
/// MB19_8B_ID: Message Buffer 19 ID Register
/// MB4_64B_WORD3: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD5: Message Buffer 7 WORD_32B Register
pub mod ID19 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_CS and WORD019
/// MB13_16B_CS: MB13_16B_CS and MB7_32B_WORD6
/// MB13_16B_CS: MB13_16B_CS and MB4_64B_WORD4
/// MB13_16B_CS: MB13_16B_CS and MB19_8B_WORD0
/// MB13_16B_CS: Message Buffer 13 CS Register
/// MB19_8B_WORD0: Message Buffer 19 WORD_8B Register
/// MB4_64B_WORD4: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD6: Message Buffer 7 WORD_32B Register
/// WORD019: Message Buffer 19 WORD0 Register
pub mod MB13_16B_CS {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_ID and WORD119
/// MB13_16B_ID: MB13_16B_ID and MB7_32B_WORD7
/// MB13_16B_ID: MB13_16B_ID and MB4_64B_WORD5
/// MB13_16B_ID: MB13_16B_ID and MB19_8B_WORD1
/// MB13_16B_ID: Message Buffer 13 ID Register
/// MB19_8B_WORD1: Message Buffer 19 WORD_8B Register
/// MB4_64B_WORD5: Message Buffer 4 WORD_64B Register
/// MB7_32B_WORD7: Message Buffer 7 WORD_32B Register
/// WORD119: Message Buffer 19 WORD1 Register
pub mod MB13_16B_ID {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS20 and MB8_32B_CS
/// CS20: CS20 and MB4_64B_WORD6
/// CS20: CS20 and MB20_8B_CS
/// CS20: CS20 and MB13_16B_WORD0
/// CS20: Message Buffer 20 CS Register
/// MB13_16B_WORD0: Message Buffer 13 WORD_16B Register
/// MB20_8B_CS: Message Buffer 20 CS Register
/// MB4_64B_WORD6: Message Buffer 4 WORD_64B Register
/// MB8_32B_CS: Message Buffer 8 CS Register
pub mod CS20 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID20 and MB8_32B_ID
/// ID20: ID20 and MB4_64B_WORD7
/// ID20: ID20 and MB20_8B_ID
/// ID20: ID20 and MB13_16B_WORD1
/// ID20: Message Buffer 20 ID Register
/// MB13_16B_WORD1: Message Buffer 13 WORD_16B Register
/// MB20_8B_ID: Message Buffer 20 ID Register
/// MB4_64B_WORD7: Message Buffer 4 WORD_64B Register
/// MB8_32B_ID: Message Buffer 8 ID Register
pub mod ID20 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_WORD2 and WORD020
/// MB13_16B_WORD2: MB13_16B_WORD2 and MB8_32B_WORD0
/// MB13_16B_WORD2: MB13_16B_WORD2 and MB4_64B_WORD8
/// MB13_16B_WORD2: MB13_16B_WORD2 and MB20_8B_WORD0
/// MB13_16B_WORD2: Message Buffer 13 WORD_16B Register
/// MB20_8B_WORD0: Message Buffer 20 WORD_8B Register
/// MB4_64B_WORD8: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD0: Message Buffer 8 WORD_32B Register
/// WORD020: Message Buffer 20 WORD0 Register
pub mod MB13_16B_WORD2 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_16B_WORD3 and WORD120
/// MB13_16B_WORD3: MB13_16B_WORD3 and MB8_32B_WORD1
/// MB13_16B_WORD3: MB13_16B_WORD3 and MB4_64B_WORD9
/// MB13_16B_WORD3: MB13_16B_WORD3 and MB20_8B_WORD1
/// MB13_16B_WORD3: Message Buffer 13 WORD_16B Register
/// MB20_8B_WORD1: Message Buffer 20 WORD_8B Register
/// MB4_64B_WORD9: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD1: Message Buffer 8 WORD_32B Register
/// WORD120: Message Buffer 20 WORD1 Register
pub mod MB13_16B_WORD3 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS21 and MB8_32B_WORD2
/// CS21: CS21 and MB4_64B_WORD10
/// CS21: CS21 and MB21_8B_CS
/// CS21: CS21 and MB14_16B_CS
/// CS21: Message Buffer 21 CS Register
/// MB14_16B_CS: Message Buffer 14 CS Register
/// MB21_8B_CS: Message Buffer 21 CS Register
/// MB4_64B_WORD10: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD2: Message Buffer 8 WORD_32B Register
pub mod CS21 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID21 and MB8_32B_WORD3
/// ID21: ID21 and MB4_64B_WORD11
/// ID21: ID21 and MB21_8B_ID
/// ID21: ID21 and MB14_16B_ID
/// ID21: Message Buffer 21 ID Register
/// MB14_16B_ID: Message Buffer 14 ID Register
/// MB21_8B_ID: Message Buffer 21 ID Register
/// MB4_64B_WORD11: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD3: Message Buffer 8 WORD_32B Register
pub mod ID21 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_16B_WORD0 and WORD021
/// MB14_16B_WORD0: MB14_16B_WORD0 and MB8_32B_WORD4
/// MB14_16B_WORD0: MB14_16B_WORD0 and MB4_64B_WORD12
/// MB14_16B_WORD0: MB14_16B_WORD0 and MB21_8B_WORD0
/// MB14_16B_WORD0: Message Buffer 14 WORD_16B Register
/// MB21_8B_WORD0: Message Buffer 21 WORD_8B Register
/// MB4_64B_WORD12: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD4: Message Buffer 8 WORD_32B Register
/// WORD021: Message Buffer 21 WORD0 Register
pub mod MB14_16B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_16B_WORD1 and WORD121
/// MB14_16B_WORD1: MB14_16B_WORD1 and MB8_32B_WORD5
/// MB14_16B_WORD1: MB14_16B_WORD1 and MB4_64B_WORD13
/// MB14_16B_WORD1: MB14_16B_WORD1 and MB21_8B_WORD1
/// MB14_16B_WORD1: Message Buffer 14 WORD_16B Register
/// MB21_8B_WORD1: Message Buffer 21 WORD_8B Register
/// MB4_64B_WORD13: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD5: Message Buffer 8 WORD_32B Register
/// WORD121: Message Buffer 21 WORD1 Register
pub mod MB14_16B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS22 and MB8_32B_WORD6
/// CS22: CS22 and MB4_64B_WORD14
/// CS22: CS22 and MB22_8B_CS
/// CS22: CS22 and MB14_16B_WORD2
/// CS22: Message Buffer 22 CS Register
/// MB14_16B_WORD2: Message Buffer 14 WORD_16B Register
/// MB22_8B_CS: Message Buffer 22 CS Register
/// MB4_64B_WORD14: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD6: Message Buffer 8 WORD_32B Register
pub mod CS22 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID22 and MB8_32B_WORD7
/// ID22: ID22 and MB4_64B_WORD15
/// ID22: ID22 and MB22_8B_ID
/// ID22: ID22 and MB14_16B_WORD3
/// ID22: Message Buffer 22 ID Register
/// MB14_16B_WORD3: Message Buffer 14 WORD_16B Register
/// MB22_8B_ID: Message Buffer 22 ID Register
/// MB4_64B_WORD15: Message Buffer 4 WORD_64B Register
/// MB8_32B_WORD7: Message Buffer 8 WORD_32B Register
pub mod ID22 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB15_16B_CS and WORD022
/// MB15_16B_CS: MB15_16B_CS and MB9_32B_CS
/// MB15_16B_CS: MB15_16B_CS and MB5_64B_CS
/// MB15_16B_CS: MB15_16B_CS and MB22_8B_WORD0
/// MB15_16B_CS: Message Buffer 15 CS Register
/// MB22_8B_WORD0: Message Buffer 22 WORD_8B Register
/// MB5_64B_CS: Message Buffer 5 CS Register
/// MB9_32B_CS: Message Buffer 9 CS Register
/// WORD022: Message Buffer 22 WORD0 Register
pub mod MB15_16B_CS {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// MB15_16B_ID and WORD122
/// MB15_16B_ID: MB15_16B_ID and MB9_32B_ID
/// MB15_16B_ID: MB15_16B_ID and MB5_64B_ID
/// MB15_16B_ID: MB15_16B_ID and MB22_8B_WORD1
/// MB15_16B_ID: Message Buffer 15 ID Register
/// MB22_8B_WORD1: Message Buffer 22 WORD_8B Register
/// MB5_64B_ID: Message Buffer 5 ID Register
/// MB9_32B_ID: Message Buffer 9 ID Register
/// WORD122: Message Buffer 22 WORD1 Register
pub mod MB15_16B_ID {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// CS23 and MB9_32B_WORD0
/// CS23: CS23 and MB5_64B_WORD0
/// CS23: CS23 and MB23_8B_CS
/// CS23: CS23 and MB15_16B_WORD0
/// CS23: Message Buffer 23 CS Register
/// MB15_16B_WORD0: Message Buffer 15 WORD_16B Register
/// MB23_8B_CS: Message Buffer 23 CS Register
/// MB5_64B_WORD0: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD0: Message Buffer 9 WORD_32B Register
pub mod CS23 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID23 and MB9_32B_WORD1
/// ID23: ID23 and MB5_64B_WORD1
/// ID23: ID23 and MB23_8B_ID
/// ID23: ID23 and MB15_16B_WORD1
/// ID23: Message Buffer 23 ID Register
/// MB15_16B_WORD1: Message Buffer 15 WORD_16B Register
/// MB23_8B_ID: Message Buffer 23 ID Register
/// MB5_64B_WORD1: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD1: Message Buffer 9 WORD_32B Register
pub mod ID23 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB15_16B_WORD2 and WORD023
/// MB15_16B_WORD2: MB15_16B_WORD2 and MB9_32B_WORD2
/// MB15_16B_WORD2: MB15_16B_WORD2 and MB5_64B_WORD2
/// MB15_16B_WORD2: MB15_16B_WORD2 and MB23_8B_WORD0
/// MB15_16B_WORD2: Message Buffer 15 WORD_16B Register
/// MB23_8B_WORD0: Message Buffer 23 WORD_8B Register
/// MB5_64B_WORD2: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD2: Message Buffer 9 WORD_32B Register
/// WORD023: Message Buffer 23 WORD0 Register
pub mod MB15_16B_WORD2 {
    pub use super::MB1_64B_WORD2::DATA_BYTE_0;
    pub use super::MB1_64B_WORD2::DATA_BYTE_1;
    pub use super::MB1_64B_WORD2::DATA_BYTE_10;
    pub use super::MB1_64B_WORD2::DATA_BYTE_11;
    pub use super::MB1_64B_WORD2::DATA_BYTE_2;
    pub use super::MB1_64B_WORD2::DATA_BYTE_3;
    pub use super::MB1_64B_WORD2::DATA_BYTE_8;
    pub use super::MB1_64B_WORD2::DATA_BYTE_9;
}

/// MB15_16B_WORD3 and WORD123
/// MB15_16B_WORD3: MB15_16B_WORD3 and MB9_32B_WORD3
/// MB15_16B_WORD3: MB15_16B_WORD3 and MB5_64B_WORD3
/// MB15_16B_WORD3: MB15_16B_WORD3 and MB23_8B_WORD1
/// MB15_16B_WORD3: Message Buffer 15 WORD_16B Register
/// MB23_8B_WORD1: Message Buffer 23 WORD_8B Register
/// MB5_64B_WORD3: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD3: Message Buffer 9 WORD_32B Register
/// WORD123: Message Buffer 23 WORD1 Register
pub mod MB15_16B_WORD3 {
    pub use super::MB1_64B_WORD3::DATA_BYTE_12;
    pub use super::MB1_64B_WORD3::DATA_BYTE_13;
    pub use super::MB1_64B_WORD3::DATA_BYTE_14;
    pub use super::MB1_64B_WORD3::DATA_BYTE_15;
    pub use super::MB1_64B_WORD3::DATA_BYTE_4;
    pub use super::MB1_64B_WORD3::DATA_BYTE_5;
    pub use super::MB1_64B_WORD3::DATA_BYTE_6;
    pub use super::MB1_64B_WORD3::DATA_BYTE_7;
}

/// CS24 and MB9_32B_WORD4
/// CS24: CS24 and MB5_64B_WORD4
/// CS24: CS24 and MB24_8B_CS
/// CS24: CS24 and MB16_16B_CS
/// CS24: Message Buffer 24 CS Register
/// MB16_16B_CS: Message Buffer 16 CS Register
/// MB24_8B_CS: Message Buffer 24 CS Register
/// MB5_64B_WORD4: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD4: Message Buffer 9 WORD_32B Register
pub mod CS24 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID24 and MB9_32B_WORD5
/// ID24: ID24 and MB5_64B_WORD5
/// ID24: ID24 and MB24_8B_ID
/// ID24: ID24 and MB16_16B_ID
/// ID24: Message Buffer 24 ID Register
/// MB16_16B_ID: Message Buffer 16 ID Register
/// MB24_8B_ID: Message Buffer 24 ID Register
/// MB5_64B_WORD5: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD5: Message Buffer 9 WORD_32B Register
pub mod ID24 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB16_16B_WORD0 and WORD024
/// MB16_16B_WORD0: MB16_16B_WORD0 and MB9_32B_WORD6
/// MB16_16B_WORD0: MB16_16B_WORD0 and MB5_64B_WORD6
/// MB16_16B_WORD0: MB16_16B_WORD0 and MB24_8B_WORD0
/// MB16_16B_WORD0: Message Buffer 16 WORD_16B Register
/// MB24_8B_WORD0: Message Buffer 24 WORD_8B Register
/// MB5_64B_WORD6: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD6: Message Buffer 9 WORD_32B Register
/// WORD024: Message Buffer 24 WORD0 Register
pub mod MB16_16B_WORD0 {
    pub use super::MB2_64B_WORD0::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0::DATA_BYTE_3;
}

/// MB16_16B_WORD1 and WORD124
/// MB16_16B_WORD1: MB16_16B_WORD1 and MB9_32B_WORD7
/// MB16_16B_WORD1: MB16_16B_WORD1 and MB5_64B_WORD7
/// MB16_16B_WORD1: MB16_16B_WORD1 and MB24_8B_WORD1
/// MB16_16B_WORD1: Message Buffer 16 WORD_16B Register
/// MB24_8B_WORD1: Message Buffer 24 WORD_8B Register
/// MB5_64B_WORD7: Message Buffer 5 WORD_64B Register
/// MB9_32B_WORD7: Message Buffer 9 WORD_32B Register
/// WORD124: Message Buffer 24 WORD1 Register
pub mod MB16_16B_WORD1 {
    pub use super::MB2_64B_WORD1::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1::DATA_BYTE_7;
}

/// CS25 and MB5_64B_WORD8
/// CS25: CS25 and MB25_8B_CS
/// CS25: CS25 and MB16_16B_WORD2
/// CS25: CS25 and MB10_32B_CS
/// CS25: Message Buffer 25 CS Register
/// MB10_32B_CS: Message Buffer 10 CS Register
/// MB16_16B_WORD2: Message Buffer 16 WORD_16B Register
/// MB25_8B_CS: Message Buffer 25 CS Register
/// MB5_64B_WORD8: Message Buffer 5 WORD_64B Register
pub mod CS25 {
    pub use super::CS16::BRS;
    pub use super::CS16::CODE;
    pub use super::CS16::DATA_BYTE_10;
    pub use super::CS16::DATA_BYTE_11;
    pub use super::CS16::DATA_BYTE_32;
    pub use super::CS16::DATA_BYTE_33;
    pub use super::CS16::DATA_BYTE_34;
    pub use super::CS16::DATA_BYTE_35;
    pub use super::CS16::DATA_BYTE_8;
    pub use super::CS16::DATA_BYTE_9;
    pub use super::CS16::DLC;
    pub use super::CS16::EDL;
    pub use super::CS16::ESI;
    pub use super::CS16::IDE;
    pub use super::CS16::RTR;
    pub use super::CS16::SRR;
    pub use super::CS16::TIME_STAMP;
}

/// ID25 and MB5_64B_WORD9
/// ID25: ID25 and MB25_8B_ID
/// ID25: ID25 and MB16_16B_WORD3
/// ID25: ID25 and MB10_32B_ID
/// ID25: Message Buffer 25 ID Register
/// MB10_32B_ID: Message Buffer 10 ID Register
/// MB16_16B_WORD3: Message Buffer 16 WORD_16B Register
/// MB25_8B_ID: Message Buffer 25 ID Register
/// MB5_64B_WORD9: Message Buffer 5 WORD_64B Register
pub mod ID25 {
    pub use super::ID16::DATA_BYTE_12;
    pub use super::ID16::DATA_BYTE_13;
    pub use super::ID16::DATA_BYTE_14;
    pub use super::ID16::DATA_BYTE_15;
    pub use super::ID16::DATA_BYTE_36;
    pub use super::ID16::DATA_BYTE_37;
    pub use super::ID16::DATA_BYTE_38;
    pub use super::ID16::DATA_BYTE_39;
    pub use super::ID16::EXT;
    pub use super::ID16::PRIO;
    pub use super::ID16::STD;
}

/// MB10_32B_WORD0 and WORD025
/// MB10_32B_WORD0: MB10_32B_WORD0 and MB5_64B_WORD10
/// MB10_32B_WORD0: MB10_32B_WORD0 and MB25_8B_WORD0
/// MB10_32B_WORD0: MB10_32B_WORD0 and MB17_16B_CS
/// MB10_32B_WORD0: Message Buffer 10 WORD_32B Register
/// MB17_16B_CS: Message Buffer 17 CS Register
/// MB25_8B_WORD0: Message Buffer 25 WORD_8B Register
/// MB5_64B_WORD10: Message Buffer 5 WORD_64B Register
/// WORD025: Message Buffer 25 WORD0 Register
pub mod MB10_32B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_32B_WORD1 and WORD125
/// MB10_32B_WORD1: MB10_32B_WORD1 and MB5_64B_WORD11
/// MB10_32B_WORD1: MB10_32B_WORD1 and MB25_8B_WORD1
/// MB10_32B_WORD1: MB10_32B_WORD1 and MB17_16B_ID
/// MB10_32B_WORD1: Message Buffer 10 WORD_32B Register
/// MB17_16B_ID: Message Buffer 17 ID Register
/// MB25_8B_WORD1: Message Buffer 25 WORD_8B Register
/// MB5_64B_WORD11: Message Buffer 5 WORD_64B Register
/// WORD125: Message Buffer 25 WORD1 Register
pub mod MB10_32B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS26 and MB5_64B_WORD12
/// CS26: CS26 and MB26_8B_CS
/// CS26: CS26 and MB17_16B_WORD0
/// CS26: CS26 and MB10_32B_WORD2
/// CS26: Message Buffer 26 CS Register
/// MB10_32B_WORD2: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD0: Message Buffer 17 WORD_16B Register
/// MB26_8B_CS: Message Buffer 26 CS Register
/// MB5_64B_WORD12: Message Buffer 5 WORD_64B Register
pub mod CS26 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID26 and MB5_64B_WORD13
/// ID26: ID26 and MB26_8B_ID
/// ID26: ID26 and MB17_16B_WORD1
/// ID26: ID26 and MB10_32B_WORD3
/// ID26: Message Buffer 26 ID Register
/// MB10_32B_WORD3: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD1: Message Buffer 17 WORD_16B Register
/// MB26_8B_ID: Message Buffer 26 ID Register
/// MB5_64B_WORD13: Message Buffer 5 WORD_64B Register
pub mod ID26 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_32B_WORD4 and WORD026
/// MB10_32B_WORD4: MB10_32B_WORD4 and MB5_64B_WORD14
/// MB10_32B_WORD4: MB10_32B_WORD4 and MB26_8B_WORD0
/// MB10_32B_WORD4: MB10_32B_WORD4 and MB17_16B_WORD2
/// MB10_32B_WORD4: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD2: Message Buffer 17 WORD_16B Register
/// MB26_8B_WORD0: Message Buffer 26 WORD_8B Register
/// MB5_64B_WORD14: Message Buffer 5 WORD_64B Register
/// WORD026: Message Buffer 26 WORD0 Register
pub mod MB10_32B_WORD4 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_32B_WORD5 and WORD126
/// MB10_32B_WORD5: MB10_32B_WORD5 and MB5_64B_WORD15
/// MB10_32B_WORD5: MB10_32B_WORD5 and MB26_8B_WORD1
/// MB10_32B_WORD5: MB10_32B_WORD5 and MB17_16B_WORD3
/// MB10_32B_WORD5: Message Buffer 10 WORD_32B Register
/// MB17_16B_WORD3: Message Buffer 17 WORD_16B Register
/// MB26_8B_WORD1: Message Buffer 26 WORD_8B Register
/// MB5_64B_WORD15: Message Buffer 5 WORD_64B Register
/// WORD126: Message Buffer 26 WORD1 Register
pub mod MB10_32B_WORD5 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS27 and MB6_64B_CS
/// CS27: CS27 and MB27_8B_CS
/// CS27: CS27 and MB18_16B_CS
/// CS27: CS27 and MB10_32B_WORD6
/// CS27: Message Buffer 27 CS Register
/// MB10_32B_WORD6: Message Buffer 10 WORD_32B Register
/// MB18_16B_CS: Message Buffer 18 CS Register
/// MB27_8B_CS: Message Buffer 27 CS Register
/// MB6_64B_CS: Message Buffer 6 CS Register
pub mod CS27 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID27 and MB6_64B_ID
/// ID27: ID27 and MB27_8B_ID
/// ID27: ID27 and MB18_16B_ID
/// ID27: ID27 and MB10_32B_WORD7
/// ID27: Message Buffer 27 ID Register
/// MB10_32B_WORD7: Message Buffer 10 WORD_32B Register
/// MB18_16B_ID: Message Buffer 18 ID Register
/// MB27_8B_ID: Message Buffer 27 ID Register
/// MB6_64B_ID: Message Buffer 6 ID Register
pub mod ID27 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_CS and WORD027
/// MB11_32B_CS: MB11_32B_CS and MB6_64B_WORD0
/// MB11_32B_CS: MB11_32B_CS and MB27_8B_WORD0
/// MB11_32B_CS: MB11_32B_CS and MB18_16B_WORD0
/// MB11_32B_CS: Message Buffer 11 CS Register
/// MB18_16B_WORD0: Message Buffer 18 WORD_16B Register
/// MB27_8B_WORD0: Message Buffer 27 WORD_8B Register
/// MB6_64B_WORD0: Message Buffer 6 WORD_64B Register
/// WORD027: Message Buffer 27 WORD0 Register
pub mod MB11_32B_CS {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// MB11_32B_ID and WORD127
/// MB11_32B_ID: MB11_32B_ID and MB6_64B_WORD1
/// MB11_32B_ID: MB11_32B_ID and MB27_8B_WORD1
/// MB11_32B_ID: MB11_32B_ID and MB18_16B_WORD1
/// MB11_32B_ID: Message Buffer 11 ID Register
/// MB18_16B_WORD1: Message Buffer 18 WORD_16B Register
/// MB27_8B_WORD1: Message Buffer 27 WORD_8B Register
/// MB6_64B_WORD1: Message Buffer 6 WORD_64B Register
/// WORD127: Message Buffer 27 WORD1 Register
pub mod MB11_32B_ID {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// CS28 and MB6_64B_WORD2
/// CS28: CS28 and MB28_8B_CS
/// CS28: CS28 and MB18_16B_WORD2
/// CS28: CS28 and MB11_32B_WORD0
/// CS28: Message Buffer 28 CS Register
/// MB11_32B_WORD0: Message Buffer 11 WORD_32B Register
/// MB18_16B_WORD2: Message Buffer 18 WORD_16B Register
/// MB28_8B_CS: Message Buffer 28 CS Register
/// MB6_64B_WORD2: Message Buffer 6 WORD_64B Register
pub mod CS28 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID28 and MB6_64B_WORD3
/// ID28: ID28 and MB28_8B_ID
/// ID28: ID28 and MB18_16B_WORD3
/// ID28: ID28 and MB11_32B_WORD1
/// ID28: Message Buffer 28 ID Register
/// MB11_32B_WORD1: Message Buffer 11 WORD_32B Register
/// MB18_16B_WORD3: Message Buffer 18 WORD_16B Register
/// MB28_8B_ID: Message Buffer 28 ID Register
/// MB6_64B_WORD3: Message Buffer 6 WORD_64B Register
pub mod ID28 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD2 and WORD028
/// MB11_32B_WORD2: MB11_32B_WORD2 and MB6_64B_WORD4
/// MB11_32B_WORD2: MB11_32B_WORD2 and MB28_8B_WORD0
/// MB11_32B_WORD2: MB11_32B_WORD2 and MB19_16B_CS
/// MB11_32B_WORD2: Message Buffer 11 WORD_32B Register
/// MB19_16B_CS: Message Buffer 19 CS Register
/// MB28_8B_WORD0: Message Buffer 28 WORD_8B Register
/// MB6_64B_WORD4: Message Buffer 6 WORD_64B Register
/// WORD028: Message Buffer 28 WORD0 Register
pub mod MB11_32B_WORD2 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD3 and WORD128
/// MB11_32B_WORD3: MB11_32B_WORD3 and MB6_64B_WORD5
/// MB11_32B_WORD3: MB11_32B_WORD3 and MB28_8B_WORD1
/// MB11_32B_WORD3: MB11_32B_WORD3 and MB19_16B_ID
/// MB11_32B_WORD3: Message Buffer 11 WORD_32B Register
/// MB19_16B_ID: Message Buffer 19 ID Register
/// MB28_8B_WORD1: Message Buffer 28 WORD_8B Register
/// MB6_64B_WORD5: Message Buffer 6 WORD_64B Register
/// WORD128: Message Buffer 28 WORD1 Register
pub mod MB11_32B_WORD3 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS29 and MB6_64B_WORD6
/// CS29: CS29 and MB29_8B_CS
/// CS29: CS29 and MB19_16B_WORD0
/// CS29: CS29 and MB11_32B_WORD4
/// CS29: Message Buffer 29 CS Register
/// MB11_32B_WORD4: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD0: Message Buffer 19 WORD_16B Register
/// MB29_8B_CS: Message Buffer 29 CS Register
/// MB6_64B_WORD6: Message Buffer 6 WORD_64B Register
pub mod CS29 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID29 and MB6_64B_WORD7
/// ID29: ID29 and MB29_8B_ID
/// ID29: ID29 and MB19_16B_WORD1
/// ID29: ID29 and MB11_32B_WORD5
/// ID29: Message Buffer 29 ID Register
/// MB11_32B_WORD5: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD1: Message Buffer 19 WORD_16B Register
/// MB29_8B_ID: Message Buffer 29 ID Register
/// MB6_64B_WORD7: Message Buffer 6 WORD_64B Register
pub mod ID29 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD6 and WORD029
/// MB11_32B_WORD6: MB11_32B_WORD6 and MB6_64B_WORD8
/// MB11_32B_WORD6: MB11_32B_WORD6 and MB29_8B_WORD0
/// MB11_32B_WORD6: MB11_32B_WORD6 and MB19_16B_WORD2
/// MB11_32B_WORD6: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD2: Message Buffer 19 WORD_16B Register
/// MB29_8B_WORD0: Message Buffer 29 WORD_8B Register
/// MB6_64B_WORD8: Message Buffer 6 WORD_64B Register
/// WORD029: Message Buffer 29 WORD0 Register
pub mod MB11_32B_WORD6 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB11_32B_WORD7 and WORD129
/// MB11_32B_WORD7: MB11_32B_WORD7 and MB6_64B_WORD9
/// MB11_32B_WORD7: MB11_32B_WORD7 and MB29_8B_WORD1
/// MB11_32B_WORD7: MB11_32B_WORD7 and MB19_16B_WORD3
/// MB11_32B_WORD7: Message Buffer 11 WORD_32B Register
/// MB19_16B_WORD3: Message Buffer 19 WORD_16B Register
/// MB29_8B_WORD1: Message Buffer 29 WORD_8B Register
/// MB6_64B_WORD9: Message Buffer 6 WORD_64B Register
/// WORD129: Message Buffer 29 WORD1 Register
pub mod MB11_32B_WORD7 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS30 and MB6_64B_WORD10
/// CS30: CS30 and MB30_8B_CS
/// CS30: CS30 and MB20_16B_CS
/// CS30: CS30 and MB12_32B_CS
/// CS30: Message Buffer 30 CS Register
/// MB12_32B_CS: Message Buffer 12 CS Register
/// MB20_16B_CS: Message Buffer 20 CS Register
/// MB30_8B_CS: Message Buffer 30 CS Register
/// MB6_64B_WORD10: Message Buffer 6 WORD_64B Register
pub mod CS30 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID30 and MB6_64B_WORD11
/// ID30: ID30 and MB30_8B_ID
/// ID30: ID30 and MB20_16B_ID
/// ID30: ID30 and MB12_32B_ID
/// ID30: Message Buffer 30 ID Register
/// MB12_32B_ID: Message Buffer 12 ID Register
/// MB20_16B_ID: Message Buffer 20 ID Register
/// MB30_8B_ID: Message Buffer 30 ID Register
/// MB6_64B_WORD11: Message Buffer 6 WORD_64B Register
pub mod ID30 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_32B_WORD0 and WORD030
/// MB12_32B_WORD0: MB12_32B_WORD0 and MB6_64B_WORD12
/// MB12_32B_WORD0: MB12_32B_WORD0 and MB30_8B_WORD0
/// MB12_32B_WORD0: MB12_32B_WORD0 and MB20_16B_WORD0
/// MB12_32B_WORD0: Message Buffer 12 WORD_32B Register
/// MB20_16B_WORD0: Message Buffer 20 WORD_16B Register
/// MB30_8B_WORD0: Message Buffer 30 WORD_8B Register
/// MB6_64B_WORD12: Message Buffer 6 WORD_64B Register
/// WORD030: Message Buffer 30 WORD0 Register
pub mod MB12_32B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_32B_WORD1 and WORD130
/// MB12_32B_WORD1: MB12_32B_WORD1 and MB6_64B_WORD13
/// MB12_32B_WORD1: MB12_32B_WORD1 and MB30_8B_WORD1
/// MB12_32B_WORD1: MB12_32B_WORD1 and MB20_16B_WORD1
/// MB12_32B_WORD1: Message Buffer 12 WORD_32B Register
/// MB20_16B_WORD1: Message Buffer 20 WORD_16B Register
/// MB30_8B_WORD1: Message Buffer 30 WORD_8B Register
/// MB6_64B_WORD13: Message Buffer 6 WORD_64B Register
/// WORD130: Message Buffer 30 WORD1 Register
pub mod MB12_32B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS31 and MB6_64B_WORD14
/// CS31: CS31 and MB31_8B_CS
/// CS31: CS31 and MB20_16B_WORD2
/// CS31: CS31 and MB12_32B_WORD2
/// CS31: Message Buffer 31 CS Register
/// MB12_32B_WORD2: Message Buffer 12 WORD_32B Register
/// MB20_16B_WORD2: Message Buffer 20 WORD_16B Register
/// MB31_8B_CS: Message Buffer 31 CS Register
/// MB6_64B_WORD14: Message Buffer 6 WORD_64B Register
pub mod CS31 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID31 and MB6_64B_WORD15
/// ID31: ID31 and MB31_8B_ID
/// ID31: ID31 and MB20_16B_WORD3
/// ID31: ID31 and MB12_32B_WORD3
/// ID31: Message Buffer 31 ID Register
/// MB12_32B_WORD3: Message Buffer 12 WORD_32B Register
/// MB20_16B_WORD3: Message Buffer 20 WORD_16B Register
/// MB31_8B_ID: Message Buffer 31 ID Register
/// MB6_64B_WORD15: Message Buffer 6 WORD_64B Register
pub mod ID31 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_32B_WORD4 and WORD031
/// MB12_32B_WORD4: MB12_32B_WORD4 and MB7_64B_CS
/// MB12_32B_WORD4: MB12_32B_WORD4 and MB31_8B_WORD0
/// MB12_32B_WORD4: MB12_32B_WORD4 and MB21_16B_CS
/// MB12_32B_WORD4: Message Buffer 12 WORD_32B Register
/// MB21_16B_CS: Message Buffer 21 CS Register
/// MB31_8B_WORD0: Message Buffer 31 WORD_8B Register
/// MB7_64B_CS: Message Buffer 7 CS Register
/// WORD031: Message Buffer 31 WORD0 Register
pub mod MB12_32B_WORD4 {
    pub use super::MB::BRS;
    pub use super::MB::CODE;
    pub use super::MB::DATA_BYTE_0;
    pub use super::MB::DATA_BYTE_1;
    pub use super::MB::DATA_BYTE_16;
    pub use super::MB::DATA_BYTE_17;
    pub use super::MB::DATA_BYTE_18;
    pub use super::MB::DATA_BYTE_19;
    pub use super::MB::DATA_BYTE_2;
    pub use super::MB::DATA_BYTE_3;
    pub use super::MB::DLC;
    pub use super::MB::EDL;
    pub use super::MB::ESI;
    pub use super::MB::IDE;
    pub use super::MB::RTR;
    pub use super::MB::SRR;
    pub use super::MB::TIME_STAMP;
}

/// MB12_32B_WORD5 and WORD131
/// MB12_32B_WORD5: MB12_32B_WORD5 and MB7_64B_ID
/// MB12_32B_WORD5: MB12_32B_WORD5 and MB31_8B_WORD1
/// MB12_32B_WORD5: MB12_32B_WORD5 and MB21_16B_ID
/// MB12_32B_WORD5: Message Buffer 12 WORD_32B Register
/// MB21_16B_ID: Message Buffer 21 ID Register
/// MB31_8B_WORD1: Message Buffer 31 WORD_8B Register
/// MB7_64B_ID: Message Buffer 7 ID Register
/// WORD131: Message Buffer 31 WORD1 Register
pub mod MB12_32B_WORD5 {
    pub use super::MB0_32B_WORD5::DATA_BYTE_20;
    pub use super::MB0_32B_WORD5::DATA_BYTE_21;
    pub use super::MB0_32B_WORD5::DATA_BYTE_22;
    pub use super::MB0_32B_WORD5::DATA_BYTE_23;
    pub use super::MB0_32B_WORD5::DATA_BYTE_4;
    pub use super::MB0_32B_WORD5::DATA_BYTE_5;
    pub use super::MB0_32B_WORD5::DATA_BYTE_6;
    pub use super::MB0_32B_WORD5::DATA_BYTE_7;
    pub use super::MB0_32B_WORD5::EXT;
    pub use super::MB0_32B_WORD5::PRIO;
    pub use super::MB0_32B_WORD5::STD;
}

/// CS32 and MB7_64B_WORD0
/// CS32: CS32 and MB32_8B_CS
/// CS32: CS32 and MB21_16B_WORD0
/// CS32: CS32 and MB12_32B_WORD6
/// CS32: Message Buffer 32 CS Register
/// MB12_32B_WORD6: Message Buffer 12 WORD_32B Register
/// MB21_16B_WORD0: Message Buffer 21 WORD_16B Register
/// MB32_8B_CS: Message Buffer 32 CS Register
/// MB7_64B_WORD0: Message Buffer 7 WORD_64B Register
pub mod CS32 {
    pub use super::CS2::BRS;
    pub use super::CS2::CODE;
    pub use super::CS2::DATA_BYTE_0;
    pub use super::CS2::DATA_BYTE_1;
    pub use super::CS2::DATA_BYTE_2;
    pub use super::CS2::DATA_BYTE_24;
    pub use super::CS2::DATA_BYTE_25;
    pub use super::CS2::DATA_BYTE_26;
    pub use super::CS2::DATA_BYTE_27;
    pub use super::CS2::DATA_BYTE_3;
    pub use super::CS2::DLC;
    pub use super::CS2::EDL;
    pub use super::CS2::ESI;
    pub use super::CS2::IDE;
    pub use super::CS2::RTR;
    pub use super::CS2::SRR;
    pub use super::CS2::TIME_STAMP;
}

/// ID32 and MB7_64B_WORD1
/// ID32: ID32 and MB32_8B_ID
/// ID32: ID32 and MB21_16B_WORD1
/// ID32: ID32 and MB12_32B_WORD7
/// ID32: Message Buffer 32 ID Register
/// MB12_32B_WORD7: Message Buffer 12 WORD_32B Register
/// MB21_16B_WORD1: Message Buffer 21 WORD_16B Register
/// MB32_8B_ID: Message Buffer 32 ID Register
/// MB7_64B_WORD1: Message Buffer 7 WORD_64B Register
pub mod ID32 {
    pub use super::ID2::DATA_BYTE_28;
    pub use super::ID2::DATA_BYTE_29;
    pub use super::ID2::DATA_BYTE_30;
    pub use super::ID2::DATA_BYTE_31;
    pub use super::ID2::DATA_BYTE_4;
    pub use super::ID2::DATA_BYTE_5;
    pub use super::ID2::DATA_BYTE_6;
    pub use super::ID2::DATA_BYTE_7;
    pub use super::ID2::EXT;
    pub use super::ID2::PRIO;
    pub use super::ID2::STD;
}

/// MB13_32B_CS and WORD032
/// MB13_32B_CS: MB13_32B_CS and MB7_64B_WORD2
/// MB13_32B_CS: MB13_32B_CS and MB32_8B_WORD0
/// MB13_32B_CS: MB13_32B_CS and MB21_16B_WORD2
/// MB13_32B_CS: Message Buffer 13 CS Register
/// MB21_16B_WORD2: Message Buffer 21 WORD_16B Register
/// MB32_8B_WORD0: Message Buffer 32 WORD_8B Register
/// MB7_64B_WORD2: Message Buffer 7 WORD_64B Register
/// WORD032: Message Buffer 32 WORD0 Register
pub mod MB13_32B_CS {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_32B_ID and WORD132
/// MB13_32B_ID: MB13_32B_ID and MB7_64B_WORD3
/// MB13_32B_ID: MB13_32B_ID and MB32_8B_WORD1
/// MB13_32B_ID: MB13_32B_ID and MB21_16B_WORD3
/// MB13_32B_ID: Message Buffer 13 ID Register
/// MB21_16B_WORD3: Message Buffer 21 WORD_16B Register
/// MB32_8B_WORD1: Message Buffer 32 WORD_8B Register
/// MB7_64B_WORD3: Message Buffer 7 WORD_64B Register
/// WORD132: Message Buffer 32 WORD1 Register
pub mod MB13_32B_ID {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS33 and MB7_64B_WORD4
/// CS33: CS33 and MB33_8B_CS
/// CS33: CS33 and MB22_16B_CS
/// CS33: CS33 and MB13_32B_WORD0
/// CS33: Message Buffer 33 CS Register
/// MB13_32B_WORD0: Message Buffer 13 WORD_32B Register
/// MB22_16B_CS: Message Buffer 22 CS Register
/// MB33_8B_CS: Message Buffer 33 CS Register
/// MB7_64B_WORD4: Message Buffer 7 WORD_64B Register
pub mod CS33 {
    pub use super::CS14::BRS;
    pub use super::CS14::CODE;
    pub use super::CS14::DATA_BYTE_0;
    pub use super::CS14::DATA_BYTE_1;
    pub use super::CS14::DATA_BYTE_16;
    pub use super::CS14::DATA_BYTE_17;
    pub use super::CS14::DATA_BYTE_18;
    pub use super::CS14::DATA_BYTE_19;
    pub use super::CS14::DATA_BYTE_2;
    pub use super::CS14::DATA_BYTE_3;
    pub use super::CS14::DLC;
    pub use super::CS14::EDL;
    pub use super::CS14::ESI;
    pub use super::CS14::IDE;
    pub use super::CS14::RTR;
    pub use super::CS14::SRR;
    pub use super::CS14::TIME_STAMP;
}

/// ID33 and MB7_64B_WORD5
/// ID33: ID33 and MB33_8B_ID
/// ID33: ID33 and MB22_16B_ID
/// ID33: ID33 and MB13_32B_WORD1
/// ID33: Message Buffer 33 ID Register
/// MB13_32B_WORD1: Message Buffer 13 WORD_32B Register
/// MB22_16B_ID: Message Buffer 22 ID Register
/// MB33_8B_ID: Message Buffer 33 ID Register
/// MB7_64B_WORD5: Message Buffer 7 WORD_64B Register
pub mod ID33 {
    pub use super::ID14::DATA_BYTE_20;
    pub use super::ID14::DATA_BYTE_21;
    pub use super::ID14::DATA_BYTE_22;
    pub use super::ID14::DATA_BYTE_23;
    pub use super::ID14::DATA_BYTE_4;
    pub use super::ID14::DATA_BYTE_5;
    pub use super::ID14::DATA_BYTE_6;
    pub use super::ID14::DATA_BYTE_7;
    pub use super::ID14::EXT;
    pub use super::ID14::PRIO;
    pub use super::ID14::STD;
}

/// MB13_32B_WORD2 and WORD033
/// MB13_32B_WORD2: MB13_32B_WORD2 and MB7_64B_WORD6
/// MB13_32B_WORD2: MB13_32B_WORD2 and MB33_8B_WORD0
/// MB13_32B_WORD2: MB13_32B_WORD2 and MB22_16B_WORD0
/// MB13_32B_WORD2: Message Buffer 13 WORD_32B Register
/// MB22_16B_WORD0: Message Buffer 22 WORD_16B Register
/// MB33_8B_WORD0: Message Buffer 33 WORD_8B Register
/// MB7_64B_WORD6: Message Buffer 7 WORD_64B Register
/// WORD033: Message Buffer 33 WORD0 Register
pub mod MB13_32B_WORD2 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_32B_WORD3 and WORD133
/// MB13_32B_WORD3: MB13_32B_WORD3 and MB7_64B_WORD7
/// MB13_32B_WORD3: MB13_32B_WORD3 and MB33_8B_WORD1
/// MB13_32B_WORD3: MB13_32B_WORD3 and MB22_16B_WORD1
/// MB13_32B_WORD3: Message Buffer 13 WORD_32B Register
/// MB22_16B_WORD1: Message Buffer 22 WORD_16B Register
/// MB33_8B_WORD1: Message Buffer 33 WORD_8B Register
/// MB7_64B_WORD7: Message Buffer 7 WORD_64B Register
/// WORD133: Message Buffer 33 WORD1 Register
pub mod MB13_32B_WORD3 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS34 and MB7_64B_WORD8
/// CS34: CS34 and MB34_8B_CS
/// CS34: CS34 and MB22_16B_WORD2
/// CS34: CS34 and MB13_32B_WORD4
/// CS34: Message Buffer 34 CS Register
/// MB13_32B_WORD4: Message Buffer 13 WORD_32B Register
/// MB22_16B_WORD2: Message Buffer 22 WORD_16B Register
/// MB34_8B_CS: Message Buffer 34 CS Register
/// MB7_64B_WORD8: Message Buffer 7 WORD_64B Register
pub mod CS34 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID34 and MB7_64B_WORD9
/// ID34: ID34 and MB34_8B_ID
/// ID34: ID34 and MB22_16B_WORD3
/// ID34: ID34 and MB13_32B_WORD5
/// ID34: Message Buffer 34 ID Register
/// MB13_32B_WORD5: Message Buffer 13 WORD_32B Register
/// MB22_16B_WORD3: Message Buffer 22 WORD_16B Register
/// MB34_8B_ID: Message Buffer 34 ID Register
/// MB7_64B_WORD9: Message Buffer 7 WORD_64B Register
pub mod ID34 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_32B_WORD6 and WORD034
/// MB13_32B_WORD6: MB13_32B_WORD6 and MB7_64B_WORD10
/// MB13_32B_WORD6: MB13_32B_WORD6 and MB34_8B_WORD0
/// MB13_32B_WORD6: MB13_32B_WORD6 and MB23_16B_CS
/// MB13_32B_WORD6: Message Buffer 13 WORD_32B Register
/// MB23_16B_CS: Message Buffer 23 CS Register
/// MB34_8B_WORD0: Message Buffer 34 WORD_8B Register
/// MB7_64B_WORD10: Message Buffer 7 WORD_64B Register
/// WORD034: Message Buffer 34 WORD0 Register
pub mod MB13_32B_WORD6 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_32B_WORD7 and WORD134
/// MB13_32B_WORD7: MB13_32B_WORD7 and MB7_64B_WORD11
/// MB13_32B_WORD7: MB13_32B_WORD7 and MB34_8B_WORD1
/// MB13_32B_WORD7: MB13_32B_WORD7 and MB23_16B_ID
/// MB13_32B_WORD7: Message Buffer 13 WORD_32B Register
/// MB23_16B_ID: Message Buffer 23 ID Register
/// MB34_8B_WORD1: Message Buffer 34 WORD_8B Register
/// MB7_64B_WORD11: Message Buffer 7 WORD_64B Register
/// WORD134: Message Buffer 34 WORD1 Register
pub mod MB13_32B_WORD7 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS35 and MB7_64B_WORD12
/// CS35: CS35 and MB35_8B_CS
/// CS35: CS35 and MB23_16B_WORD0
/// CS35: CS35 and MB14_32B_CS
/// CS35: Message Buffer 35 CS Register
/// MB14_32B_CS: Message Buffer 14 CS Register
/// MB23_16B_WORD0: Message Buffer 23 WORD_16B Register
/// MB35_8B_CS: Message Buffer 35 CS Register
/// MB7_64B_WORD12: Message Buffer 7 WORD_64B Register
pub mod CS35 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID35 and MB7_64B_WORD13
/// ID35: ID35 and MB35_8B_ID
/// ID35: ID35 and MB23_16B_WORD1
/// ID35: ID35 and MB14_32B_ID
/// ID35: Message Buffer 35 ID Register
/// MB14_32B_ID: Message Buffer 14 ID Register
/// MB23_16B_WORD1: Message Buffer 23 WORD_16B Register
/// MB35_8B_ID: Message Buffer 35 ID Register
/// MB7_64B_WORD13: Message Buffer 7 WORD_64B Register
pub mod ID35 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_32B_WORD0 and WORD035
/// MB14_32B_WORD0: MB14_32B_WORD0 and MB7_64B_WORD14
/// MB14_32B_WORD0: MB14_32B_WORD0 and MB35_8B_WORD0
/// MB14_32B_WORD0: MB14_32B_WORD0 and MB23_16B_WORD2
/// MB14_32B_WORD0: Message Buffer 14 WORD_32B Register
/// MB23_16B_WORD2: Message Buffer 23 WORD_16B Register
/// MB35_8B_WORD0: Message Buffer 35 WORD_8B Register
/// MB7_64B_WORD14: Message Buffer 7 WORD_64B Register
/// WORD035: Message Buffer 35 WORD0 Register
pub mod MB14_32B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_32B_WORD1 and WORD135
/// MB14_32B_WORD1: MB14_32B_WORD1 and MB7_64B_WORD15
/// MB14_32B_WORD1: MB14_32B_WORD1 and MB35_8B_WORD1
/// MB14_32B_WORD1: MB14_32B_WORD1 and MB23_16B_WORD3
/// MB14_32B_WORD1: Message Buffer 14 WORD_32B Register
/// MB23_16B_WORD3: Message Buffer 23 WORD_16B Register
/// MB35_8B_WORD1: Message Buffer 35 WORD_8B Register
/// MB7_64B_WORD15: Message Buffer 7 WORD_64B Register
/// WORD135: Message Buffer 35 WORD1 Register
pub mod MB14_32B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS36 and MB8_64B_CS
/// CS36: CS36 and MB36_8B_CS
/// CS36: CS36 and MB24_16B_CS
/// CS36: CS36 and MB14_32B_WORD2
/// CS36: Message Buffer 36 CS Register
/// MB14_32B_WORD2: Message Buffer 14 WORD_32B Register
/// MB24_16B_CS: Message Buffer 24 CS Register
/// MB36_8B_CS: Message Buffer 36 CS Register
/// MB8_64B_CS: Message Buffer 8 CS Register
pub mod CS36 {
    pub use super::CS1::BRS;
    pub use super::CS1::CODE;
    pub use super::CS1::DATA_BYTE_10;
    pub use super::CS1::DATA_BYTE_11;
    pub use super::CS1::DATA_BYTE_8;
    pub use super::CS1::DATA_BYTE_9;
    pub use super::CS1::DLC;
    pub use super::CS1::EDL;
    pub use super::CS1::ESI;
    pub use super::CS1::IDE;
    pub use super::CS1::RTR;
    pub use super::CS1::SRR;
    pub use super::CS1::TIME_STAMP;
}

/// ID36 and MB8_64B_ID
/// ID36: ID36 and MB36_8B_ID
/// ID36: ID36 and MB24_16B_ID
/// ID36: ID36 and MB14_32B_WORD3
/// ID36: Message Buffer 36 ID Register
/// MB14_32B_WORD3: Message Buffer 14 WORD_32B Register
/// MB24_16B_ID: Message Buffer 24 ID Register
/// MB36_8B_ID: Message Buffer 36 ID Register
/// MB8_64B_ID: Message Buffer 8 ID Register
pub mod ID36 {
    pub use super::ID1::DATA_BYTE_12;
    pub use super::ID1::DATA_BYTE_13;
    pub use super::ID1::DATA_BYTE_14;
    pub use super::ID1::DATA_BYTE_15;
    pub use super::ID1::EXT;
    pub use super::ID1::PRIO;
    pub use super::ID1::STD;
}

/// MB14_32B_WORD4 and WORD036
/// MB14_32B_WORD4: MB14_32B_WORD4 and MB8_64B_WORD0
/// MB14_32B_WORD4: MB14_32B_WORD4 and MB36_8B_WORD0
/// MB14_32B_WORD4: MB14_32B_WORD4 and MB24_16B_WORD0
/// MB14_32B_WORD4: Message Buffer 14 WORD_32B Register
/// MB24_16B_WORD0: Message Buffer 24 WORD_16B Register
/// MB36_8B_WORD0: Message Buffer 36 WORD_8B Register
/// MB8_64B_WORD0: Message Buffer 8 WORD_64B Register
/// WORD036: Message Buffer 36 WORD0 Register
pub mod MB14_32B_WORD4 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB14_32B_WORD5 and WORD136
/// MB14_32B_WORD5: MB14_32B_WORD5 and MB8_64B_WORD1
/// MB14_32B_WORD5: MB14_32B_WORD5 and MB36_8B_WORD1
/// MB14_32B_WORD5: MB14_32B_WORD5 and MB24_16B_WORD1
/// MB14_32B_WORD5: Message Buffer 14 WORD_32B Register
/// MB24_16B_WORD1: Message Buffer 24 WORD_16B Register
/// MB36_8B_WORD1: Message Buffer 36 WORD_8B Register
/// MB8_64B_WORD1: Message Buffer 8 WORD_64B Register
/// WORD136: Message Buffer 36 WORD1 Register
pub mod MB14_32B_WORD5 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS37 and MB8_64B_WORD2
/// CS37: CS37 and MB37_8B_CS
/// CS37: CS37 and MB24_16B_WORD2
/// CS37: CS37 and MB14_32B_WORD6
/// CS37: Message Buffer 37 CS Register
/// MB14_32B_WORD6: Message Buffer 14 WORD_32B Register
/// MB24_16B_WORD2: Message Buffer 24 WORD_16B Register
/// MB37_8B_CS: Message Buffer 37 CS Register
/// MB8_64B_WORD2: Message Buffer 8 WORD_64B Register
pub mod CS37 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID37 and MB8_64B_WORD3
/// ID37: ID37 and MB37_8B_ID
/// ID37: ID37 and MB24_16B_WORD3
/// ID37: ID37 and MB14_32B_WORD7
/// ID37: Message Buffer 37 ID Register
/// MB14_32B_WORD7: Message Buffer 14 WORD_32B Register
/// MB24_16B_WORD3: Message Buffer 24 WORD_16B Register
/// MB37_8B_ID: Message Buffer 37 ID Register
/// MB8_64B_WORD3: Message Buffer 8 WORD_64B Register
pub mod ID37 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB15_32B_CS and WORD037
/// MB15_32B_CS: MB15_32B_CS and MB8_64B_WORD4
/// MB15_32B_CS: MB15_32B_CS and MB37_8B_WORD0
/// MB15_32B_CS: MB15_32B_CS and MB25_16B_CS
/// MB15_32B_CS: Message Buffer 15 CS Register
/// MB25_16B_CS: Message Buffer 25 CS Register
/// MB37_8B_WORD0: Message Buffer 37 WORD_8B Register
/// MB8_64B_WORD4: Message Buffer 8 WORD_64B Register
/// WORD037: Message Buffer 37 WORD0 Register
pub mod MB15_32B_CS {
    pub use super::CS14::BRS;
    pub use super::CS14::CODE;
    pub use super::CS14::DATA_BYTE_0;
    pub use super::CS14::DATA_BYTE_1;
    pub use super::CS14::DATA_BYTE_16;
    pub use super::CS14::DATA_BYTE_17;
    pub use super::CS14::DATA_BYTE_18;
    pub use super::CS14::DATA_BYTE_19;
    pub use super::CS14::DATA_BYTE_2;
    pub use super::CS14::DATA_BYTE_3;
    pub use super::CS14::DLC;
    pub use super::CS14::EDL;
    pub use super::CS14::ESI;
    pub use super::CS14::IDE;
    pub use super::CS14::RTR;
    pub use super::CS14::SRR;
    pub use super::CS14::TIME_STAMP;
}

/// MB15_32B_ID and WORD137
/// MB15_32B_ID: MB15_32B_ID and MB8_64B_WORD5
/// MB15_32B_ID: MB15_32B_ID and MB37_8B_WORD1
/// MB15_32B_ID: MB15_32B_ID and MB25_16B_ID
/// MB15_32B_ID: Message Buffer 15 ID Register
/// MB25_16B_ID: Message Buffer 25 ID Register
/// MB37_8B_WORD1: Message Buffer 37 WORD_8B Register
/// MB8_64B_WORD5: Message Buffer 8 WORD_64B Register
/// WORD137: Message Buffer 37 WORD1 Register
pub mod MB15_32B_ID {
    pub use super::ID14::DATA_BYTE_20;
    pub use super::ID14::DATA_BYTE_21;
    pub use super::ID14::DATA_BYTE_22;
    pub use super::ID14::DATA_BYTE_23;
    pub use super::ID14::DATA_BYTE_4;
    pub use super::ID14::DATA_BYTE_5;
    pub use super::ID14::DATA_BYTE_6;
    pub use super::ID14::DATA_BYTE_7;
    pub use super::ID14::EXT;
    pub use super::ID14::PRIO;
    pub use super::ID14::STD;
}

/// CS38 and MB8_64B_WORD6
/// CS38: CS38 and MB38_8B_CS
/// CS38: CS38 and MB25_16B_WORD0
/// CS38: CS38 and MB15_32B_WORD0
/// CS38: Message Buffer 38 CS Register
/// MB15_32B_WORD0: Message Buffer 15 WORD_32B Register
/// MB25_16B_WORD0: Message Buffer 25 WORD_16B Register
/// MB38_8B_CS: Message Buffer 38 CS Register
/// MB8_64B_WORD6: Message Buffer 8 WORD_64B Register
pub mod CS38 {
    pub use super::CS20::BRS;
    pub use super::CS20::CODE;
    pub use super::CS20::DATA_BYTE_0;
    pub use super::CS20::DATA_BYTE_1;
    pub use super::CS20::DATA_BYTE_2;
    pub use super::CS20::DATA_BYTE_24;
    pub use super::CS20::DATA_BYTE_25;
    pub use super::CS20::DATA_BYTE_26;
    pub use super::CS20::DATA_BYTE_27;
    pub use super::CS20::DATA_BYTE_3;
    pub use super::CS20::DLC;
    pub use super::CS20::EDL;
    pub use super::CS20::ESI;
    pub use super::CS20::IDE;
    pub use super::CS20::RTR;
    pub use super::CS20::SRR;
    pub use super::CS20::TIME_STAMP;
}

/// ID38 and MB8_64B_WORD7
/// ID38: ID38 and MB38_8B_ID
/// ID38: ID38 and MB25_16B_WORD1
/// ID38: ID38 and MB15_32B_WORD1
/// ID38: Message Buffer 38 ID Register
/// MB15_32B_WORD1: Message Buffer 15 WORD_32B Register
/// MB25_16B_WORD1: Message Buffer 25 WORD_16B Register
/// MB38_8B_ID: Message Buffer 38 ID Register
/// MB8_64B_WORD7: Message Buffer 8 WORD_64B Register
pub mod ID38 {
    pub use super::ID20::DATA_BYTE_28;
    pub use super::ID20::DATA_BYTE_29;
    pub use super::ID20::DATA_BYTE_30;
    pub use super::ID20::DATA_BYTE_31;
    pub use super::ID20::DATA_BYTE_4;
    pub use super::ID20::DATA_BYTE_5;
    pub use super::ID20::DATA_BYTE_6;
    pub use super::ID20::DATA_BYTE_7;
    pub use super::ID20::EXT;
    pub use super::ID20::PRIO;
    pub use super::ID20::STD;
}

/// MB15_32B_WORD2 and WORD038
/// MB15_32B_WORD2: MB15_32B_WORD2 and MB8_64B_WORD8
/// MB15_32B_WORD2: MB15_32B_WORD2 and MB38_8B_WORD0
/// MB15_32B_WORD2: MB15_32B_WORD2 and MB25_16B_WORD2
/// MB15_32B_WORD2: Message Buffer 15 WORD_32B Register
/// MB25_16B_WORD2: Message Buffer 25 WORD_16B Register
/// MB38_8B_WORD0: Message Buffer 38 WORD_8B Register
/// MB8_64B_WORD8: Message Buffer 8 WORD_64B Register
/// WORD038: Message Buffer 38 WORD0 Register
pub mod MB15_32B_WORD2 {
    pub use super::MB13_16B_WORD2::DATA_BYTE_0;
    pub use super::MB13_16B_WORD2::DATA_BYTE_1;
    pub use super::MB13_16B_WORD2::DATA_BYTE_10;
    pub use super::MB13_16B_WORD2::DATA_BYTE_11;
    pub use super::MB13_16B_WORD2::DATA_BYTE_2;
    pub use super::MB13_16B_WORD2::DATA_BYTE_3;
    pub use super::MB13_16B_WORD2::DATA_BYTE_32;
    pub use super::MB13_16B_WORD2::DATA_BYTE_33;
    pub use super::MB13_16B_WORD2::DATA_BYTE_34;
    pub use super::MB13_16B_WORD2::DATA_BYTE_35;
    pub use super::MB13_16B_WORD2::DATA_BYTE_8;
    pub use super::MB13_16B_WORD2::DATA_BYTE_9;
}

/// MB15_32B_WORD3 and WORD138
/// MB15_32B_WORD3: MB15_32B_WORD3 and MB8_64B_WORD9
/// MB15_32B_WORD3: MB15_32B_WORD3 and MB38_8B_WORD1
/// MB15_32B_WORD3: MB15_32B_WORD3 and MB25_16B_WORD3
/// MB15_32B_WORD3: Message Buffer 15 WORD_32B Register
/// MB25_16B_WORD3: Message Buffer 25 WORD_16B Register
/// MB38_8B_WORD1: Message Buffer 38 WORD_8B Register
/// MB8_64B_WORD9: Message Buffer 8 WORD_64B Register
/// WORD138: Message Buffer 38 WORD1 Register
pub mod MB15_32B_WORD3 {
    pub use super::MB13_16B_WORD3::DATA_BYTE_12;
    pub use super::MB13_16B_WORD3::DATA_BYTE_13;
    pub use super::MB13_16B_WORD3::DATA_BYTE_14;
    pub use super::MB13_16B_WORD3::DATA_BYTE_15;
    pub use super::MB13_16B_WORD3::DATA_BYTE_36;
    pub use super::MB13_16B_WORD3::DATA_BYTE_37;
    pub use super::MB13_16B_WORD3::DATA_BYTE_38;
    pub use super::MB13_16B_WORD3::DATA_BYTE_39;
    pub use super::MB13_16B_WORD3::DATA_BYTE_4;
    pub use super::MB13_16B_WORD3::DATA_BYTE_5;
    pub use super::MB13_16B_WORD3::DATA_BYTE_6;
    pub use super::MB13_16B_WORD3::DATA_BYTE_7;
}

/// CS39 and MB8_64B_WORD10
/// CS39: CS39 and MB39_8B_CS
/// CS39: CS39 and MB26_16B_CS
/// CS39: CS39 and MB15_32B_WORD4
/// CS39: Message Buffer 39 CS Register
/// MB15_32B_WORD4: Message Buffer 15 WORD_32B Register
/// MB26_16B_CS: Message Buffer 26 CS Register
/// MB39_8B_CS: Message Buffer 39 CS Register
/// MB8_64B_WORD10: Message Buffer 8 WORD_64B Register
pub mod CS39 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID39 and MB8_64B_WORD11
/// ID39: ID39 and MB39_8B_ID
/// ID39: ID39 and MB26_16B_ID
/// ID39: ID39 and MB15_32B_WORD5
/// ID39: Message Buffer 39 ID Register
/// MB15_32B_WORD5: Message Buffer 15 WORD_32B Register
/// MB26_16B_ID: Message Buffer 26 ID Register
/// MB39_8B_ID: Message Buffer 39 ID Register
/// MB8_64B_WORD11: Message Buffer 8 WORD_64B Register
pub mod ID39 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB15_32B_WORD6 and WORD039
/// MB15_32B_WORD6: MB15_32B_WORD6 and MB8_64B_WORD12
/// MB15_32B_WORD6: MB15_32B_WORD6 and MB39_8B_WORD0
/// MB15_32B_WORD6: MB15_32B_WORD6 and MB26_16B_WORD0
/// MB15_32B_WORD6: Message Buffer 15 WORD_32B Register
/// MB26_16B_WORD0: Message Buffer 26 WORD_16B Register
/// MB39_8B_WORD0: Message Buffer 39 WORD_8B Register
/// MB8_64B_WORD12: Message Buffer 8 WORD_64B Register
/// WORD039: Message Buffer 39 WORD0 Register
pub mod MB15_32B_WORD6 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB15_32B_WORD7 and WORD139
/// MB15_32B_WORD7: MB15_32B_WORD7 and MB8_64B_WORD13
/// MB15_32B_WORD7: MB15_32B_WORD7 and MB39_8B_WORD1
/// MB15_32B_WORD7: MB15_32B_WORD7 and MB26_16B_WORD1
/// MB15_32B_WORD7: Message Buffer 15 WORD_32B Register
/// MB26_16B_WORD1: Message Buffer 26 WORD_16B Register
/// MB39_8B_WORD1: Message Buffer 39 WORD_8B Register
/// MB8_64B_WORD13: Message Buffer 8 WORD_64B Register
/// WORD139: Message Buffer 39 WORD1 Register
pub mod MB15_32B_WORD7 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS40 and MB8_64B_WORD14
/// CS40: CS40 and MB40_8B_CS
/// CS40: CS40 and MB26_16B_WORD2
/// CS40: CS40 and MB16_32B_CS
/// CS40: Message Buffer 40 CS Register
/// MB16_32B_CS: Message Buffer 16 CS Register
/// MB26_16B_WORD2: Message Buffer 26 WORD_16B Register
/// MB40_8B_CS: Message Buffer 40 CS Register
/// MB8_64B_WORD14: Message Buffer 8 WORD_64B Register
pub mod CS40 {
    pub use super::CS31::BRS;
    pub use super::CS31::CODE;
    pub use super::CS31::DATA_BYTE_10;
    pub use super::CS31::DATA_BYTE_11;
    pub use super::CS31::DATA_BYTE_56;
    pub use super::CS31::DATA_BYTE_57;
    pub use super::CS31::DATA_BYTE_58;
    pub use super::CS31::DATA_BYTE_59;
    pub use super::CS31::DATA_BYTE_8;
    pub use super::CS31::DATA_BYTE_9;
    pub use super::CS31::DLC;
    pub use super::CS31::EDL;
    pub use super::CS31::ESI;
    pub use super::CS31::IDE;
    pub use super::CS31::RTR;
    pub use super::CS31::SRR;
    pub use super::CS31::TIME_STAMP;
}

/// ID40 and MB8_64B_WORD15
/// ID40: ID40 and MB40_8B_ID
/// ID40: ID40 and MB26_16B_WORD3
/// ID40: ID40 and MB16_32B_ID
/// ID40: Message Buffer 40 ID Register
/// MB16_32B_ID: Message Buffer 16 ID Register
/// MB26_16B_WORD3: Message Buffer 26 WORD_16B Register
/// MB40_8B_ID: Message Buffer 40 ID Register
/// MB8_64B_WORD15: Message Buffer 8 WORD_64B Register
pub mod ID40 {
    pub use super::ID31::DATA_BYTE_12;
    pub use super::ID31::DATA_BYTE_13;
    pub use super::ID31::DATA_BYTE_14;
    pub use super::ID31::DATA_BYTE_15;
    pub use super::ID31::DATA_BYTE_60;
    pub use super::ID31::DATA_BYTE_61;
    pub use super::ID31::DATA_BYTE_62;
    pub use super::ID31::DATA_BYTE_63;
    pub use super::ID31::EXT;
    pub use super::ID31::PRIO;
    pub use super::ID31::STD;
}

/// MB16_32B_WORD0 and WORD040
/// MB16_32B_WORD0: MB16_32B_WORD0 and MB9_64B_CS
/// MB16_32B_WORD0: MB16_32B_WORD0 and MB40_8B_WORD0
/// MB16_32B_WORD0: MB16_32B_WORD0 and MB27_16B_CS
/// MB16_32B_WORD0: Message Buffer 16 WORD_32B Register
/// MB27_16B_CS: Message Buffer 27 CS Register
/// MB40_8B_WORD0: Message Buffer 40 WORD_8B Register
/// MB9_64B_CS: Message Buffer 9 CS Register
/// WORD040: Message Buffer 40 WORD0 Register
pub mod MB16_32B_WORD0 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB16_32B_WORD1 and WORD140
/// MB16_32B_WORD1: MB16_32B_WORD1 and MB9_64B_ID
/// MB16_32B_WORD1: MB16_32B_WORD1 and MB40_8B_WORD1
/// MB16_32B_WORD1: MB16_32B_WORD1 and MB27_16B_ID
/// MB16_32B_WORD1: Message Buffer 16 WORD_32B Register
/// MB27_16B_ID: Message Buffer 27 ID Register
/// MB40_8B_WORD1: Message Buffer 40 WORD_8B Register
/// MB9_64B_ID: Message Buffer 9 ID Register
/// WORD140: Message Buffer 40 WORD1 Register
pub mod MB16_32B_WORD1 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS41 and MB9_64B_WORD0
/// CS41: CS41 and MB41_8B_CS
/// CS41: CS41 and MB27_16B_WORD0
/// CS41: CS41 and MB16_32B_WORD2
/// CS41: Message Buffer 41 CS Register
/// MB16_32B_WORD2: Message Buffer 16 WORD_32B Register
/// MB27_16B_WORD0: Message Buffer 27 WORD_16B Register
/// MB41_8B_CS: Message Buffer 41 CS Register
/// MB9_64B_WORD0: Message Buffer 9 WORD_64B Register
pub mod CS41 {
    pub use super::MB13_32B_CS::BRS;
    pub use super::MB13_32B_CS::CODE;
    pub use super::MB13_32B_CS::DATA_BYTE_0;
    pub use super::MB13_32B_CS::DATA_BYTE_1;
    pub use super::MB13_32B_CS::DATA_BYTE_10;
    pub use super::MB13_32B_CS::DATA_BYTE_11;
    pub use super::MB13_32B_CS::DATA_BYTE_2;
    pub use super::MB13_32B_CS::DATA_BYTE_3;
    pub use super::MB13_32B_CS::DATA_BYTE_8;
    pub use super::MB13_32B_CS::DATA_BYTE_9;
    pub use super::MB13_32B_CS::DLC;
    pub use super::MB13_32B_CS::EDL;
    pub use super::MB13_32B_CS::ESI;
    pub use super::MB13_32B_CS::IDE;
    pub use super::MB13_32B_CS::RTR;
    pub use super::MB13_32B_CS::SRR;
    pub use super::MB13_32B_CS::TIME_STAMP;
}

/// ID41 and MB9_64B_WORD1
/// ID41: ID41 and MB41_8B_ID
/// ID41: ID41 and MB27_16B_WORD1
/// ID41: ID41 and MB16_32B_WORD3
/// ID41: Message Buffer 41 ID Register
/// MB16_32B_WORD3: Message Buffer 16 WORD_32B Register
/// MB27_16B_WORD1: Message Buffer 27 WORD_16B Register
/// MB41_8B_ID: Message Buffer 41 ID Register
/// MB9_64B_WORD1: Message Buffer 9 WORD_64B Register
pub mod ID41 {
    pub use super::MB13_32B_ID::DATA_BYTE_12;
    pub use super::MB13_32B_ID::DATA_BYTE_13;
    pub use super::MB13_32B_ID::DATA_BYTE_14;
    pub use super::MB13_32B_ID::DATA_BYTE_15;
    pub use super::MB13_32B_ID::DATA_BYTE_4;
    pub use super::MB13_32B_ID::DATA_BYTE_5;
    pub use super::MB13_32B_ID::DATA_BYTE_6;
    pub use super::MB13_32B_ID::DATA_BYTE_7;
    pub use super::MB13_32B_ID::EXT;
    pub use super::MB13_32B_ID::PRIO;
    pub use super::MB13_32B_ID::STD;
}

/// MB16_32B_WORD4 and WORD041
/// MB16_32B_WORD4: MB16_32B_WORD4 and MB9_64B_WORD2
/// MB16_32B_WORD4: MB16_32B_WORD4 and MB41_8B_WORD0
/// MB16_32B_WORD4: MB16_32B_WORD4 and MB27_16B_WORD2
/// MB16_32B_WORD4: Message Buffer 16 WORD_32B Register
/// MB27_16B_WORD2: Message Buffer 27 WORD_16B Register
/// MB41_8B_WORD0: Message Buffer 41 WORD_8B Register
/// MB9_64B_WORD2: Message Buffer 9 WORD_64B Register
/// WORD041: Message Buffer 41 WORD0 Register
pub mod MB16_32B_WORD4 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB16_32B_WORD5 and WORD141
/// MB16_32B_WORD5: MB16_32B_WORD5 and MB9_64B_WORD3
/// MB16_32B_WORD5: MB16_32B_WORD5 and MB41_8B_WORD1
/// MB16_32B_WORD5: MB16_32B_WORD5 and MB27_16B_WORD3
/// MB16_32B_WORD5: Message Buffer 16 WORD_32B Register
/// MB27_16B_WORD3: Message Buffer 27 WORD_16B Register
/// MB41_8B_WORD1: Message Buffer 41 WORD_8B Register
/// MB9_64B_WORD3: Message Buffer 9 WORD_64B Register
/// WORD141: Message Buffer 41 WORD1 Register
pub mod MB16_32B_WORD5 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS42 and MB9_64B_WORD4
/// CS42: CS42 and MB42_8B_CS
/// CS42: CS42 and MB28_16B_CS
/// CS42: CS42 and MB16_32B_WORD6
/// CS42: Message Buffer 42 CS Register
/// MB16_32B_WORD6: Message Buffer 16 WORD_32B Register
/// MB28_16B_CS: Message Buffer 28 CS Register
/// MB42_8B_CS: Message Buffer 42 CS Register
/// MB9_64B_WORD4: Message Buffer 9 WORD_64B Register
pub mod CS42 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID42 and MB9_64B_WORD5
/// ID42: ID42 and MB42_8B_ID
/// ID42: ID42 and MB28_16B_ID
/// ID42: ID42 and MB16_32B_WORD7
/// ID42: Message Buffer 42 ID Register
/// MB16_32B_WORD7: Message Buffer 16 WORD_32B Register
/// MB28_16B_ID: Message Buffer 28 ID Register
/// MB42_8B_ID: Message Buffer 42 ID Register
/// MB9_64B_WORD5: Message Buffer 9 WORD_64B Register
pub mod ID42 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB17_32B_CS and WORD042
/// MB17_32B_CS: MB17_32B_CS and MB9_64B_WORD6
/// MB17_32B_CS: MB17_32B_CS and MB42_8B_WORD0
/// MB17_32B_CS: MB17_32B_CS and MB28_16B_WORD0
/// MB17_32B_CS: Message Buffer 17 CS Register
/// MB28_16B_WORD0: Message Buffer 28 WORD_16B Register
/// MB42_8B_WORD0: Message Buffer 42 WORD_8B Register
/// MB9_64B_WORD6: Message Buffer 9 WORD_64B Register
/// WORD042: Message Buffer 42 WORD0 Register
pub mod MB17_32B_CS {
    pub use super::CS20::BRS;
    pub use super::CS20::CODE;
    pub use super::CS20::DATA_BYTE_0;
    pub use super::CS20::DATA_BYTE_1;
    pub use super::CS20::DATA_BYTE_2;
    pub use super::CS20::DATA_BYTE_24;
    pub use super::CS20::DATA_BYTE_25;
    pub use super::CS20::DATA_BYTE_26;
    pub use super::CS20::DATA_BYTE_27;
    pub use super::CS20::DATA_BYTE_3;
    pub use super::CS20::DLC;
    pub use super::CS20::EDL;
    pub use super::CS20::ESI;
    pub use super::CS20::IDE;
    pub use super::CS20::RTR;
    pub use super::CS20::SRR;
    pub use super::CS20::TIME_STAMP;
}

/// MB17_32B_ID and WORD142
/// MB17_32B_ID: MB17_32B_ID and MB9_64B_WORD7
/// MB17_32B_ID: MB17_32B_ID and MB42_8B_WORD1
/// MB17_32B_ID: MB17_32B_ID and MB28_16B_WORD1
/// MB17_32B_ID: Message Buffer 17 ID Register
/// MB28_16B_WORD1: Message Buffer 28 WORD_16B Register
/// MB42_8B_WORD1: Message Buffer 42 WORD_8B Register
/// MB9_64B_WORD7: Message Buffer 9 WORD_64B Register
/// WORD142: Message Buffer 42 WORD1 Register
pub mod MB17_32B_ID {
    pub use super::ID20::DATA_BYTE_28;
    pub use super::ID20::DATA_BYTE_29;
    pub use super::ID20::DATA_BYTE_30;
    pub use super::ID20::DATA_BYTE_31;
    pub use super::ID20::DATA_BYTE_4;
    pub use super::ID20::DATA_BYTE_5;
    pub use super::ID20::DATA_BYTE_6;
    pub use super::ID20::DATA_BYTE_7;
    pub use super::ID20::EXT;
    pub use super::ID20::PRIO;
    pub use super::ID20::STD;
}

/// CS43 and MB9_64B_WORD8
/// CS43: CS43 and MB43_8B_CS
/// CS43: CS43 and MB28_16B_WORD2
/// CS43: CS43 and MB17_32B_WORD0
/// CS43: Message Buffer 43 CS Register
/// MB17_32B_WORD0: Message Buffer 17 WORD_32B Register
/// MB28_16B_WORD2: Message Buffer 28 WORD_16B Register
/// MB43_8B_CS: Message Buffer 43 CS Register
/// MB9_64B_WORD8: Message Buffer 9 WORD_64B Register
pub mod CS43 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID43 and MB9_64B_WORD9
/// ID43: ID43 and MB43_8B_ID
/// ID43: ID43 and MB28_16B_WORD3
/// ID43: ID43 and MB17_32B_WORD1
/// ID43: Message Buffer 43 ID Register
/// MB17_32B_WORD1: Message Buffer 17 WORD_32B Register
/// MB28_16B_WORD3: Message Buffer 28 WORD_16B Register
/// MB43_8B_ID: Message Buffer 43 ID Register
/// MB9_64B_WORD9: Message Buffer 9 WORD_64B Register
pub mod ID43 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB17_32B_WORD2 and WORD043
/// MB17_32B_WORD2: MB17_32B_WORD2 and MB9_64B_WORD10
/// MB17_32B_WORD2: MB17_32B_WORD2 and MB43_8B_WORD0
/// MB17_32B_WORD2: MB17_32B_WORD2 and MB29_16B_CS
/// MB17_32B_WORD2: Message Buffer 17 WORD_32B Register
/// MB29_16B_CS: Message Buffer 29 CS Register
/// MB43_8B_WORD0: Message Buffer 43 WORD_8B Register
/// MB9_64B_WORD10: Message Buffer 9 WORD_64B Register
/// WORD043: Message Buffer 43 WORD0 Register
pub mod MB17_32B_WORD2 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_43 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_42 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_41 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_40 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB17_32B_WORD3 and WORD143
/// MB17_32B_WORD3: MB17_32B_WORD3 and MB9_64B_WORD11
/// MB17_32B_WORD3: MB17_32B_WORD3 and MB43_8B_WORD1
/// MB17_32B_WORD3: MB17_32B_WORD3 and MB29_16B_ID
/// MB17_32B_WORD3: Message Buffer 17 WORD_32B Register
/// MB29_16B_ID: Message Buffer 29 ID Register
/// MB43_8B_WORD1: Message Buffer 43 WORD_8B Register
/// MB9_64B_WORD11: Message Buffer 9 WORD_64B Register
/// WORD143: Message Buffer 43 WORD1 Register
pub mod MB17_32B_WORD3 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_47 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_46 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_45 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_44 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS44 and MB9_64B_WORD12
/// CS44: CS44 and MB44_8B_CS
/// CS44: CS44 and MB29_16B_WORD0
/// CS44: CS44 and MB17_32B_WORD4
/// CS44: Message Buffer 44 CS Register
/// MB17_32B_WORD4: Message Buffer 17 WORD_32B Register
/// MB29_16B_WORD0: Message Buffer 29 WORD_16B Register
/// MB44_8B_CS: Message Buffer 44 CS Register
/// MB9_64B_WORD12: Message Buffer 9 WORD_64B Register
pub mod CS44 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID44 and MB9_64B_WORD13
/// ID44: ID44 and MB44_8B_ID
/// ID44: ID44 and MB29_16B_WORD1
/// ID44: ID44 and MB17_32B_WORD5
/// ID44: Message Buffer 44 ID Register
/// MB17_32B_WORD5: Message Buffer 17 WORD_32B Register
/// MB29_16B_WORD1: Message Buffer 29 WORD_16B Register
/// MB44_8B_ID: Message Buffer 44 ID Register
/// MB9_64B_WORD13: Message Buffer 9 WORD_64B Register
pub mod ID44 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB17_32B_WORD6 and WORD044
/// MB17_32B_WORD6: MB17_32B_WORD6 and MB9_64B_WORD14
/// MB17_32B_WORD6: MB17_32B_WORD6 and MB44_8B_WORD0
/// MB17_32B_WORD6: MB17_32B_WORD6 and MB29_16B_WORD2
/// MB17_32B_WORD6: Message Buffer 17 WORD_32B Register
/// MB29_16B_WORD2: Message Buffer 29 WORD_16B Register
/// MB44_8B_WORD0: Message Buffer 44 WORD_8B Register
/// MB9_64B_WORD14: Message Buffer 9 WORD_64B Register
/// WORD044: Message Buffer 44 WORD0 Register
pub mod MB17_32B_WORD6 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_59 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_58 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_57 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_56 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB17_32B_WORD7 and WORD144
/// MB17_32B_WORD7: MB17_32B_WORD7 and MB9_64B_WORD15
/// MB17_32B_WORD7: MB17_32B_WORD7 and MB44_8B_WORD1
/// MB17_32B_WORD7: MB17_32B_WORD7 and MB29_16B_WORD3
/// MB17_32B_WORD7: Message Buffer 17 WORD_32B Register
/// MB29_16B_WORD3: Message Buffer 29 WORD_16B Register
/// MB44_8B_WORD1: Message Buffer 44 WORD_8B Register
/// MB9_64B_WORD15: Message Buffer 9 WORD_64B Register
/// WORD144: Message Buffer 44 WORD1 Register
pub mod MB17_32B_WORD7 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_63 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_62 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_61 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_60 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS45 and MB45_8B_CS
/// CS45: CS45 and MB30_16B_CS
/// CS45: CS45 and MB18_32B_CS
/// CS45: CS45 and MB10_64B_CS
/// CS45: Message Buffer 45 CS Register
/// MB10_64B_CS: Message Buffer 10 CS Register
/// MB18_32B_CS: Message Buffer 18 CS Register
/// MB30_16B_CS: Message Buffer 30 CS Register
/// MB45_8B_CS: Message Buffer 45 CS Register
pub mod CS45 {
    pub use super::CS0::BRS;
    pub use super::CS0::CODE;
    pub use super::CS0::DLC;
    pub use super::CS0::EDL;
    pub use super::CS0::ESI;
    pub use super::CS0::IDE;
    pub use super::CS0::RTR;
    pub use super::CS0::SRR;
    pub use super::CS0::TIME_STAMP;
}

/// ID45 and MB45_8B_ID
/// ID45: ID45 and MB30_16B_ID
/// ID45: ID45 and MB18_32B_ID
/// ID45: ID45 and MB10_64B_ID
/// ID45: Message Buffer 45 ID Register
/// MB10_64B_ID: Message Buffer 10 ID Register
/// MB18_32B_ID: Message Buffer 18 ID Register
/// MB30_16B_ID: Message Buffer 30 ID Register
/// MB45_8B_ID: Message Buffer 45 ID Register
pub mod ID45 {
    pub use super::ID0::EXT;
    pub use super::ID0::PRIO;
    pub use super::ID0::STD;
}

/// MB10_64B_WORD0 and WORD045
/// MB10_64B_WORD0: MB10_64B_WORD0 and MB45_8B_WORD0
/// MB10_64B_WORD0: MB10_64B_WORD0 and MB30_16B_WORD0
/// MB10_64B_WORD0: MB10_64B_WORD0 and MB18_32B_WORD0
/// MB10_64B_WORD0: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD0: Message Buffer 18 WORD_32B Register
/// MB30_16B_WORD0: Message Buffer 30 WORD_16B Register
/// MB45_8B_WORD0: Message Buffer 45 WORD_8B Register
/// WORD045: Message Buffer 45 WORD0 Register
pub mod MB10_64B_WORD0 {
    pub use super::MB0::DATA_BYTE_0;
    pub use super::MB0::DATA_BYTE_1;
    pub use super::MB0::DATA_BYTE_2;
    pub use super::MB0::DATA_BYTE_3;
}

/// MB10_64B_WORD1 and WORD145
/// MB10_64B_WORD1: MB10_64B_WORD1 and MB45_8B_WORD1
/// MB10_64B_WORD1: MB10_64B_WORD1 and MB30_16B_WORD1
/// MB10_64B_WORD1: MB10_64B_WORD1 and MB18_32B_WORD1
/// MB10_64B_WORD1: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD1: Message Buffer 18 WORD_32B Register
/// MB30_16B_WORD1: Message Buffer 30 WORD_16B Register
/// MB45_8B_WORD1: Message Buffer 45 WORD_8B Register
/// WORD145: Message Buffer 45 WORD1 Register
pub mod MB10_64B_WORD1 {
    pub use super::MB0_16B_WORD1::DATA_BYTE_4;
    pub use super::MB0_16B_WORD1::DATA_BYTE_5;
    pub use super::MB0_16B_WORD1::DATA_BYTE_6;
    pub use super::MB0_16B_WORD1::DATA_BYTE_7;
}

/// CS46 and MB46_8B_CS
/// CS46: CS46 and MB30_16B_WORD2
/// CS46: CS46 and MB18_32B_WORD2
/// CS46: CS46 and MB10_64B_WORD2
/// CS46: Message Buffer 46 CS Register
/// MB10_64B_WORD2: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD2: Message Buffer 18 WORD_32B Register
/// MB30_16B_WORD2: Message Buffer 30 WORD_16B Register
/// MB46_8B_CS: Message Buffer 46 CS Register
pub mod CS46 {
    pub use super::CS1::BRS;
    pub use super::CS1::CODE;
    pub use super::CS1::DATA_BYTE_10;
    pub use super::CS1::DATA_BYTE_11;
    pub use super::CS1::DATA_BYTE_8;
    pub use super::CS1::DATA_BYTE_9;
    pub use super::CS1::DLC;
    pub use super::CS1::EDL;
    pub use super::CS1::ESI;
    pub use super::CS1::IDE;
    pub use super::CS1::RTR;
    pub use super::CS1::SRR;
    pub use super::CS1::TIME_STAMP;
}

/// ID46 and MB46_8B_ID
/// ID46: ID46 and MB30_16B_WORD3
/// ID46: ID46 and MB18_32B_WORD3
/// ID46: ID46 and MB10_64B_WORD3
/// ID46: Message Buffer 46 ID Register
/// MB10_64B_WORD3: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD3: Message Buffer 18 WORD_32B Register
/// MB30_16B_WORD3: Message Buffer 30 WORD_16B Register
/// MB46_8B_ID: Message Buffer 46 ID Register
pub mod ID46 {
    pub use super::ID1::DATA_BYTE_12;
    pub use super::ID1::DATA_BYTE_13;
    pub use super::ID1::DATA_BYTE_14;
    pub use super::ID1::DATA_BYTE_15;
    pub use super::ID1::EXT;
    pub use super::ID1::PRIO;
    pub use super::ID1::STD;
}

/// MB10_64B_WORD4 and WORD046
/// MB10_64B_WORD4: MB10_64B_WORD4 and MB46_8B_WORD0
/// MB10_64B_WORD4: MB10_64B_WORD4 and MB31_16B_CS
/// MB10_64B_WORD4: MB10_64B_WORD4 and MB18_32B_WORD4
/// MB10_64B_WORD4: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD4: Message Buffer 18 WORD_32B Register
/// MB31_16B_CS: Message Buffer 31 CS Register
/// MB46_8B_WORD0: Message Buffer 46 WORD_8B Register
/// WORD046: Message Buffer 46 WORD0 Register
pub mod MB10_64B_WORD4 {
    pub use super::MB::BRS;
    pub use super::MB::CODE;
    pub use super::MB::DATA_BYTE_0;
    pub use super::MB::DATA_BYTE_1;
    pub use super::MB::DATA_BYTE_16;
    pub use super::MB::DATA_BYTE_17;
    pub use super::MB::DATA_BYTE_18;
    pub use super::MB::DATA_BYTE_19;
    pub use super::MB::DATA_BYTE_2;
    pub use super::MB::DATA_BYTE_3;
    pub use super::MB::DLC;
    pub use super::MB::EDL;
    pub use super::MB::ESI;
    pub use super::MB::IDE;
    pub use super::MB::RTR;
    pub use super::MB::SRR;
    pub use super::MB::TIME_STAMP;
}

/// MB10_64B_WORD5 and WORD146
/// MB10_64B_WORD5: MB10_64B_WORD5 and MB46_8B_WORD1
/// MB10_64B_WORD5: MB10_64B_WORD5 and MB31_16B_ID
/// MB10_64B_WORD5: MB10_64B_WORD5 and MB18_32B_WORD5
/// MB10_64B_WORD5: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD5: Message Buffer 18 WORD_32B Register
/// MB31_16B_ID: Message Buffer 31 ID Register
/// MB46_8B_WORD1: Message Buffer 46 WORD_8B Register
/// WORD146: Message Buffer 46 WORD1 Register
pub mod MB10_64B_WORD5 {
    pub use super::MB0_32B_WORD5::DATA_BYTE_20;
    pub use super::MB0_32B_WORD5::DATA_BYTE_21;
    pub use super::MB0_32B_WORD5::DATA_BYTE_22;
    pub use super::MB0_32B_WORD5::DATA_BYTE_23;
    pub use super::MB0_32B_WORD5::DATA_BYTE_4;
    pub use super::MB0_32B_WORD5::DATA_BYTE_5;
    pub use super::MB0_32B_WORD5::DATA_BYTE_6;
    pub use super::MB0_32B_WORD5::DATA_BYTE_7;
    pub use super::MB0_32B_WORD5::EXT;
    pub use super::MB0_32B_WORD5::PRIO;
    pub use super::MB0_32B_WORD5::STD;
}

/// CS47 and MB47_8B_CS
/// CS47: CS47 and MB31_16B_WORD0
/// CS47: CS47 and MB18_32B_WORD6
/// CS47: CS47 and MB10_64B_WORD6
/// CS47: Message Buffer 47 CS Register
/// MB10_64B_WORD6: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD6: Message Buffer 18 WORD_32B Register
/// MB31_16B_WORD0: Message Buffer 31 WORD_16B Register
/// MB47_8B_CS: Message Buffer 47 CS Register
pub mod CS47 {
    pub use super::CS2::BRS;
    pub use super::CS2::CODE;
    pub use super::CS2::DATA_BYTE_0;
    pub use super::CS2::DATA_BYTE_1;
    pub use super::CS2::DATA_BYTE_2;
    pub use super::CS2::DATA_BYTE_24;
    pub use super::CS2::DATA_BYTE_25;
    pub use super::CS2::DATA_BYTE_26;
    pub use super::CS2::DATA_BYTE_27;
    pub use super::CS2::DATA_BYTE_3;
    pub use super::CS2::DLC;
    pub use super::CS2::EDL;
    pub use super::CS2::ESI;
    pub use super::CS2::IDE;
    pub use super::CS2::RTR;
    pub use super::CS2::SRR;
    pub use super::CS2::TIME_STAMP;
}

/// ID47 and MB47_8B_ID
/// ID47: ID47 and MB31_16B_WORD1
/// ID47: ID47 and MB18_32B_WORD7
/// ID47: ID47 and MB10_64B_WORD7
/// ID47: Message Buffer 47 ID Register
/// MB10_64B_WORD7: Message Buffer 10 WORD_64B Register
/// MB18_32B_WORD7: Message Buffer 18 WORD_32B Register
/// MB31_16B_WORD1: Message Buffer 31 WORD_16B Register
/// MB47_8B_ID: Message Buffer 47 ID Register
pub mod ID47 {
    pub use super::ID2::DATA_BYTE_28;
    pub use super::ID2::DATA_BYTE_29;
    pub use super::ID2::DATA_BYTE_30;
    pub use super::ID2::DATA_BYTE_31;
    pub use super::ID2::DATA_BYTE_4;
    pub use super::ID2::DATA_BYTE_5;
    pub use super::ID2::DATA_BYTE_6;
    pub use super::ID2::DATA_BYTE_7;
    pub use super::ID2::EXT;
    pub use super::ID2::PRIO;
    pub use super::ID2::STD;
}

/// MB10_64B_WORD8 and WORD047
/// MB10_64B_WORD8: MB10_64B_WORD8 and MB47_8B_WORD0
/// MB10_64B_WORD8: MB10_64B_WORD8 and MB31_16B_WORD2
/// MB10_64B_WORD8: MB10_64B_WORD8 and MB19_32B_CS
/// MB10_64B_WORD8: Message Buffer 10 WORD_64B Register
/// MB19_32B_CS: Message Buffer 19 CS Register
/// MB31_16B_WORD2: Message Buffer 31 WORD_16B Register
/// MB47_8B_WORD0: Message Buffer 47 WORD_8B Register
/// WORD047: Message Buffer 47 WORD0 Register
pub mod MB10_64B_WORD8 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB10_64B_WORD9 and WORD147
/// MB10_64B_WORD9: MB10_64B_WORD9 and MB47_8B_WORD1
/// MB10_64B_WORD9: MB10_64B_WORD9 and MB31_16B_WORD3
/// MB10_64B_WORD9: MB10_64B_WORD9 and MB19_32B_ID
/// MB10_64B_WORD9: Message Buffer 10 WORD_64B Register
/// MB19_32B_ID: Message Buffer 19 ID Register
/// MB31_16B_WORD3: Message Buffer 31 WORD_16B Register
/// MB47_8B_WORD1: Message Buffer 47 WORD_8B Register
/// WORD147: Message Buffer 47 WORD1 Register
pub mod MB10_64B_WORD9 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS48 and MB48_8B_CS
/// CS48: CS48 and MB32_16B_CS
/// CS48: CS48 and MB19_32B_WORD0
/// CS48: CS48 and MB10_64B_WORD10
/// CS48: Message Buffer 48 CS Register
/// MB10_64B_WORD10: Message Buffer 10 WORD_64B Register
/// MB19_32B_WORD0: Message Buffer 19 WORD_32B Register
/// MB32_16B_CS: Message Buffer 32 CS Register
/// MB48_8B_CS: Message Buffer 48 CS Register
pub mod CS48 {
    pub use super::CS3::BRS;
    pub use super::CS3::CODE;
    pub use super::CS3::DATA_BYTE_0;
    pub use super::CS3::DATA_BYTE_1;
    pub use super::CS3::DATA_BYTE_2;
    pub use super::CS3::DATA_BYTE_3;
    pub use super::CS3::DATA_BYTE_40;
    pub use super::CS3::DATA_BYTE_41;
    pub use super::CS3::DATA_BYTE_42;
    pub use super::CS3::DATA_BYTE_43;
    pub use super::CS3::DLC;
    pub use super::CS3::EDL;
    pub use super::CS3::ESI;
    pub use super::CS3::IDE;
    pub use super::CS3::RTR;
    pub use super::CS3::SRR;
    pub use super::CS3::TIME_STAMP;
}

/// ID48 and MB48_8B_ID
/// ID48: ID48 and MB32_16B_ID
/// ID48: ID48 and MB19_32B_WORD1
/// ID48: ID48 and MB10_64B_WORD11
/// ID48: Message Buffer 48 ID Register
/// MB10_64B_WORD11: Message Buffer 10 WORD_64B Register
/// MB19_32B_WORD1: Message Buffer 19 WORD_32B Register
/// MB32_16B_ID: Message Buffer 32 ID Register
/// MB48_8B_ID: Message Buffer 48 ID Register
pub mod ID48 {
    pub use super::ID3::DATA_BYTE_4;
    pub use super::ID3::DATA_BYTE_44;
    pub use super::ID3::DATA_BYTE_45;
    pub use super::ID3::DATA_BYTE_46;
    pub use super::ID3::DATA_BYTE_47;
    pub use super::ID3::DATA_BYTE_5;
    pub use super::ID3::DATA_BYTE_6;
    pub use super::ID3::DATA_BYTE_7;
    pub use super::ID3::EXT;
    pub use super::ID3::PRIO;
    pub use super::ID3::STD;
}

/// MB10_64B_WORD12 and WORD048
/// MB10_64B_WORD12: MB10_64B_WORD12 and MB48_8B_WORD0
/// MB10_64B_WORD12: MB10_64B_WORD12 and MB32_16B_WORD0
/// MB10_64B_WORD12: MB10_64B_WORD12 and MB19_32B_WORD2
/// MB10_64B_WORD12: Message Buffer 10 WORD_64B Register
/// MB19_32B_WORD2: Message Buffer 19 WORD_32B Register
/// MB32_16B_WORD0: Message Buffer 32 WORD_16B Register
/// MB48_8B_WORD0: Message Buffer 48 WORD_8B Register
/// WORD048: Message Buffer 48 WORD0 Register
pub mod MB10_64B_WORD12 {
    pub use super::MB0_64B_WORD12::DATA_BYTE_0;
    pub use super::MB0_64B_WORD12::DATA_BYTE_1;
    pub use super::MB0_64B_WORD12::DATA_BYTE_10;
    pub use super::MB0_64B_WORD12::DATA_BYTE_11;
    pub use super::MB0_64B_WORD12::DATA_BYTE_2;
    pub use super::MB0_64B_WORD12::DATA_BYTE_3;
    pub use super::MB0_64B_WORD12::DATA_BYTE_48;
    pub use super::MB0_64B_WORD12::DATA_BYTE_49;
    pub use super::MB0_64B_WORD12::DATA_BYTE_50;
    pub use super::MB0_64B_WORD12::DATA_BYTE_51;
    pub use super::MB0_64B_WORD12::DATA_BYTE_8;
    pub use super::MB0_64B_WORD12::DATA_BYTE_9;
}

/// MB10_64B_WORD13 and WORD148
/// MB10_64B_WORD13: MB10_64B_WORD13 and MB48_8B_WORD1
/// MB10_64B_WORD13: MB10_64B_WORD13 and MB32_16B_WORD1
/// MB10_64B_WORD13: MB10_64B_WORD13 and MB19_32B_WORD3
/// MB10_64B_WORD13: Message Buffer 10 WORD_64B Register
/// MB19_32B_WORD3: Message Buffer 19 WORD_32B Register
/// MB32_16B_WORD1: Message Buffer 32 WORD_16B Register
/// MB48_8B_WORD1: Message Buffer 48 WORD_8B Register
/// WORD148: Message Buffer 48 WORD1 Register
pub mod MB10_64B_WORD13 {
    pub use super::MB0_64B_WORD13::DATA_BYTE_12;
    pub use super::MB0_64B_WORD13::DATA_BYTE_13;
    pub use super::MB0_64B_WORD13::DATA_BYTE_14;
    pub use super::MB0_64B_WORD13::DATA_BYTE_15;
    pub use super::MB0_64B_WORD13::DATA_BYTE_4;
    pub use super::MB0_64B_WORD13::DATA_BYTE_5;
    pub use super::MB0_64B_WORD13::DATA_BYTE_52;
    pub use super::MB0_64B_WORD13::DATA_BYTE_53;
    pub use super::MB0_64B_WORD13::DATA_BYTE_54;
    pub use super::MB0_64B_WORD13::DATA_BYTE_55;
    pub use super::MB0_64B_WORD13::DATA_BYTE_6;
    pub use super::MB0_64B_WORD13::DATA_BYTE_7;
}

/// CS49 and MB49_8B_CS
/// CS49: CS49 and MB32_16B_WORD2
/// CS49: CS49 and MB19_32B_WORD4
/// CS49: CS49 and MB10_64B_WORD14
/// CS49: Message Buffer 49 CS Register
/// MB10_64B_WORD14: Message Buffer 10 WORD_64B Register
/// MB19_32B_WORD4: Message Buffer 19 WORD_32B Register
/// MB32_16B_WORD2: Message Buffer 32 WORD_16B Register
/// MB49_8B_CS: Message Buffer 49 CS Register
pub mod CS49 {
    pub use super::CS4::BRS;
    pub use super::CS4::CODE;
    pub use super::CS4::DATA_BYTE_10;
    pub use super::CS4::DATA_BYTE_11;
    pub use super::CS4::DATA_BYTE_16;
    pub use super::CS4::DATA_BYTE_17;
    pub use super::CS4::DATA_BYTE_18;
    pub use super::CS4::DATA_BYTE_19;
    pub use super::CS4::DATA_BYTE_56;
    pub use super::CS4::DATA_BYTE_57;
    pub use super::CS4::DATA_BYTE_58;
    pub use super::CS4::DATA_BYTE_59;
    pub use super::CS4::DATA_BYTE_8;
    pub use super::CS4::DATA_BYTE_9;
    pub use super::CS4::DLC;
    pub use super::CS4::EDL;
    pub use super::CS4::ESI;
    pub use super::CS4::IDE;
    pub use super::CS4::RTR;
    pub use super::CS4::SRR;
    pub use super::CS4::TIME_STAMP;
}

/// ID49 and MB49_8B_ID
/// ID49: ID49 and MB32_16B_WORD3
/// ID49: ID49 and MB19_32B_WORD5
/// ID49: ID49 and MB10_64B_WORD15
/// ID49: Message Buffer 49 ID Register
/// MB10_64B_WORD15: Message Buffer 10 WORD_64B Register
/// MB19_32B_WORD5: Message Buffer 19 WORD_32B Register
/// MB32_16B_WORD3: Message Buffer 32 WORD_16B Register
/// MB49_8B_ID: Message Buffer 49 ID Register
pub mod ID49 {
    pub use super::ID4::DATA_BYTE_12;
    pub use super::ID4::DATA_BYTE_13;
    pub use super::ID4::DATA_BYTE_14;
    pub use super::ID4::DATA_BYTE_15;
    pub use super::ID4::DATA_BYTE_20;
    pub use super::ID4::DATA_BYTE_21;
    pub use super::ID4::DATA_BYTE_22;
    pub use super::ID4::DATA_BYTE_23;
    pub use super::ID4::DATA_BYTE_60;
    pub use super::ID4::DATA_BYTE_61;
    pub use super::ID4::DATA_BYTE_62;
    pub use super::ID4::DATA_BYTE_63;
    pub use super::ID4::EXT;
    pub use super::ID4::PRIO;
    pub use super::ID4::STD;
}

/// MB11_64B_CS and WORD049
/// MB11_64B_CS: MB11_64B_CS and MB49_8B_WORD0
/// MB11_64B_CS: MB11_64B_CS and MB33_16B_CS
/// MB11_64B_CS: MB11_64B_CS and MB19_32B_WORD6
/// MB11_64B_CS: Message Buffer 11 CS Register
/// MB19_32B_WORD6: Message Buffer 19 WORD_32B Register
/// MB33_16B_CS: Message Buffer 33 CS Register
/// MB49_8B_WORD0: Message Buffer 49 WORD_8B Register
/// WORD049: Message Buffer 49 WORD0 Register
pub mod MB11_64B_CS {
    pub use super::CS2::BRS;
    pub use super::CS2::CODE;
    pub use super::CS2::DATA_BYTE_0;
    pub use super::CS2::DATA_BYTE_1;
    pub use super::CS2::DATA_BYTE_2;
    pub use super::CS2::DATA_BYTE_24;
    pub use super::CS2::DATA_BYTE_25;
    pub use super::CS2::DATA_BYTE_26;
    pub use super::CS2::DATA_BYTE_27;
    pub use super::CS2::DATA_BYTE_3;
    pub use super::CS2::DLC;
    pub use super::CS2::EDL;
    pub use super::CS2::ESI;
    pub use super::CS2::IDE;
    pub use super::CS2::RTR;
    pub use super::CS2::SRR;
    pub use super::CS2::TIME_STAMP;
}

/// MB11_64B_ID and WORD149
/// MB11_64B_ID: MB11_64B_ID and MB49_8B_WORD1
/// MB11_64B_ID: MB11_64B_ID and MB33_16B_ID
/// MB11_64B_ID: MB11_64B_ID and MB19_32B_WORD7
/// MB11_64B_ID: Message Buffer 11 ID Register
/// MB19_32B_WORD7: Message Buffer 19 WORD_32B Register
/// MB33_16B_ID: Message Buffer 33 ID Register
/// MB49_8B_WORD1: Message Buffer 49 WORD_8B Register
/// WORD149: Message Buffer 49 WORD1 Register
pub mod MB11_64B_ID {
    pub use super::ID2::DATA_BYTE_28;
    pub use super::ID2::DATA_BYTE_29;
    pub use super::ID2::DATA_BYTE_30;
    pub use super::ID2::DATA_BYTE_31;
    pub use super::ID2::DATA_BYTE_4;
    pub use super::ID2::DATA_BYTE_5;
    pub use super::ID2::DATA_BYTE_6;
    pub use super::ID2::DATA_BYTE_7;
    pub use super::ID2::EXT;
    pub use super::ID2::PRIO;
    pub use super::ID2::STD;
}

/// CS50 and MB50_8B_CS
/// CS50: CS50 and MB33_16B_WORD0
/// CS50: CS50 and MB20_32B_CS
/// CS50: CS50 and MB11_64B_WORD0
/// CS50: Message Buffer 50 CS Register
/// MB11_64B_WORD0: Message Buffer 11 WORD_64B Register
/// MB20_32B_CS: Message Buffer 20 CS Register
/// MB33_16B_WORD0: Message Buffer 33 WORD_16B Register
/// MB50_8B_CS: Message Buffer 50 CS Register
pub mod CS50 {
    pub use super::CS5::BRS;
    pub use super::CS5::CODE;
    pub use super::CS5::DATA_BYTE_0;
    pub use super::CS5::DATA_BYTE_1;
    pub use super::CS5::DATA_BYTE_2;
    pub use super::CS5::DATA_BYTE_3;
    pub use super::CS5::DLC;
    pub use super::CS5::EDL;
    pub use super::CS5::ESI;
    pub use super::CS5::IDE;
    pub use super::CS5::RTR;
    pub use super::CS5::SRR;
    pub use super::CS5::TIME_STAMP;
}

/// ID50 and MB50_8B_ID
/// ID50: ID50 and MB33_16B_WORD1
/// ID50: ID50 and MB20_32B_ID
/// ID50: ID50 and MB11_64B_WORD1
/// ID50: Message Buffer 50 ID Register
/// MB11_64B_WORD1: Message Buffer 11 WORD_64B Register
/// MB20_32B_ID: Message Buffer 20 ID Register
/// MB33_16B_WORD1: Message Buffer 33 WORD_16B Register
/// MB50_8B_ID: Message Buffer 50 ID Register
pub mod ID50 {
    pub use super::ID5::DATA_BYTE_4;
    pub use super::ID5::DATA_BYTE_5;
    pub use super::ID5::DATA_BYTE_6;
    pub use super::ID5::DATA_BYTE_7;
    pub use super::ID5::EXT;
    pub use super::ID5::PRIO;
    pub use super::ID5::STD;
}

/// MB11_64B_WORD2 and WORD050
/// MB11_64B_WORD2: MB11_64B_WORD2 and MB50_8B_WORD0
/// MB11_64B_WORD2: MB11_64B_WORD2 and MB33_16B_WORD2
/// MB11_64B_WORD2: MB11_64B_WORD2 and MB20_32B_WORD0
/// MB11_64B_WORD2: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD0: Message Buffer 20 WORD_32B Register
/// MB33_16B_WORD2: Message Buffer 33 WORD_16B Register
/// MB50_8B_WORD0: Message Buffer 50 WORD_8B Register
/// WORD050: Message Buffer 50 WORD0 Register
pub mod MB11_64B_WORD2 {
    pub use super::MB1_64B_WORD2::DATA_BYTE_0;
    pub use super::MB1_64B_WORD2::DATA_BYTE_1;
    pub use super::MB1_64B_WORD2::DATA_BYTE_10;
    pub use super::MB1_64B_WORD2::DATA_BYTE_11;
    pub use super::MB1_64B_WORD2::DATA_BYTE_2;
    pub use super::MB1_64B_WORD2::DATA_BYTE_3;
    pub use super::MB1_64B_WORD2::DATA_BYTE_8;
    pub use super::MB1_64B_WORD2::DATA_BYTE_9;
}

/// MB11_64B_WORD3 and WORD150
/// MB11_64B_WORD3: MB11_64B_WORD3 and MB50_8B_WORD1
/// MB11_64B_WORD3: MB11_64B_WORD3 and MB33_16B_WORD3
/// MB11_64B_WORD3: MB11_64B_WORD3 and MB20_32B_WORD1
/// MB11_64B_WORD3: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD1: Message Buffer 20 WORD_32B Register
/// MB33_16B_WORD3: Message Buffer 33 WORD_16B Register
/// MB50_8B_WORD1: Message Buffer 50 WORD_8B Register
/// WORD150: Message Buffer 50 WORD1 Register
pub mod MB11_64B_WORD3 {
    pub use super::MB1_64B_WORD3::DATA_BYTE_12;
    pub use super::MB1_64B_WORD3::DATA_BYTE_13;
    pub use super::MB1_64B_WORD3::DATA_BYTE_14;
    pub use super::MB1_64B_WORD3::DATA_BYTE_15;
    pub use super::MB1_64B_WORD3::DATA_BYTE_4;
    pub use super::MB1_64B_WORD3::DATA_BYTE_5;
    pub use super::MB1_64B_WORD3::DATA_BYTE_6;
    pub use super::MB1_64B_WORD3::DATA_BYTE_7;
}

/// CS51 and MB51_8B_CS
/// CS51: CS51 and MB34_16B_CS
/// CS51: CS51 and MB20_32B_WORD2
/// CS51: CS51 and MB11_64B_WORD4
/// CS51: Message Buffer 51 CS Register
/// MB11_64B_WORD4: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD2: Message Buffer 20 WORD_32B Register
/// MB34_16B_CS: Message Buffer 34 CS Register
/// MB51_8B_CS: Message Buffer 51 CS Register
pub mod CS51 {
    pub use super::CS6::BRS;
    pub use super::CS6::CODE;
    pub use super::CS6::DATA_BYTE_10;
    pub use super::CS6::DATA_BYTE_11;
    pub use super::CS6::DATA_BYTE_16;
    pub use super::CS6::DATA_BYTE_17;
    pub use super::CS6::DATA_BYTE_18;
    pub use super::CS6::DATA_BYTE_19;
    pub use super::CS6::DATA_BYTE_8;
    pub use super::CS6::DATA_BYTE_9;
    pub use super::CS6::DLC;
    pub use super::CS6::EDL;
    pub use super::CS6::ESI;
    pub use super::CS6::IDE;
    pub use super::CS6::RTR;
    pub use super::CS6::SRR;
    pub use super::CS6::TIME_STAMP;
}

/// ID51 and MB51_8B_ID
/// ID51: ID51 and MB34_16B_ID
/// ID51: ID51 and MB20_32B_WORD3
/// ID51: ID51 and MB11_64B_WORD5
/// ID51: Message Buffer 51 ID Register
/// MB11_64B_WORD5: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD3: Message Buffer 20 WORD_32B Register
/// MB34_16B_ID: Message Buffer 34 ID Register
/// MB51_8B_ID: Message Buffer 51 ID Register
pub mod ID51 {
    pub use super::ID6::DATA_BYTE_12;
    pub use super::ID6::DATA_BYTE_13;
    pub use super::ID6::DATA_BYTE_14;
    pub use super::ID6::DATA_BYTE_15;
    pub use super::ID6::DATA_BYTE_20;
    pub use super::ID6::DATA_BYTE_21;
    pub use super::ID6::DATA_BYTE_22;
    pub use super::ID6::DATA_BYTE_23;
    pub use super::ID6::EXT;
    pub use super::ID6::PRIO;
    pub use super::ID6::STD;
}

/// MB11_64B_WORD6 and WORD051
/// MB11_64B_WORD6: MB11_64B_WORD6 and MB51_8B_WORD0
/// MB11_64B_WORD6: MB11_64B_WORD6 and MB34_16B_WORD0
/// MB11_64B_WORD6: MB11_64B_WORD6 and MB20_32B_WORD4
/// MB11_64B_WORD6: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD4: Message Buffer 20 WORD_32B Register
/// MB34_16B_WORD0: Message Buffer 34 WORD_16B Register
/// MB51_8B_WORD0: Message Buffer 51 WORD_8B Register
/// WORD051: Message Buffer 51 WORD0 Register
pub mod MB11_64B_WORD6 {
    pub use super::MB1_64B_WORD6::DATA_BYTE_0;
    pub use super::MB1_64B_WORD6::DATA_BYTE_1;
    pub use super::MB1_64B_WORD6::DATA_BYTE_16;
    pub use super::MB1_64B_WORD6::DATA_BYTE_17;
    pub use super::MB1_64B_WORD6::DATA_BYTE_18;
    pub use super::MB1_64B_WORD6::DATA_BYTE_19;
    pub use super::MB1_64B_WORD6::DATA_BYTE_2;
    pub use super::MB1_64B_WORD6::DATA_BYTE_24;
    pub use super::MB1_64B_WORD6::DATA_BYTE_25;
    pub use super::MB1_64B_WORD6::DATA_BYTE_26;
    pub use super::MB1_64B_WORD6::DATA_BYTE_27;
    pub use super::MB1_64B_WORD6::DATA_BYTE_3;
}

/// MB11_64B_WORD7 and WORD151
/// MB11_64B_WORD7: MB11_64B_WORD7 and MB51_8B_WORD1
/// MB11_64B_WORD7: MB11_64B_WORD7 and MB34_16B_WORD1
/// MB11_64B_WORD7: MB11_64B_WORD7 and MB20_32B_WORD5
/// MB11_64B_WORD7: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD5: Message Buffer 20 WORD_32B Register
/// MB34_16B_WORD1: Message Buffer 34 WORD_16B Register
/// MB51_8B_WORD1: Message Buffer 51 WORD_8B Register
/// WORD151: Message Buffer 51 WORD1 Register
pub mod MB11_64B_WORD7 {
    pub use super::MB1_64B_WORD7::DATA_BYTE_20;
    pub use super::MB1_64B_WORD7::DATA_BYTE_21;
    pub use super::MB1_64B_WORD7::DATA_BYTE_22;
    pub use super::MB1_64B_WORD7::DATA_BYTE_23;
    pub use super::MB1_64B_WORD7::DATA_BYTE_28;
    pub use super::MB1_64B_WORD7::DATA_BYTE_29;
    pub use super::MB1_64B_WORD7::DATA_BYTE_30;
    pub use super::MB1_64B_WORD7::DATA_BYTE_31;
    pub use super::MB1_64B_WORD7::DATA_BYTE_4;
    pub use super::MB1_64B_WORD7::DATA_BYTE_5;
    pub use super::MB1_64B_WORD7::DATA_BYTE_6;
    pub use super::MB1_64B_WORD7::DATA_BYTE_7;
}

/// CS52 and MB52_8B_CS
/// CS52: CS52 and MB34_16B_WORD2
/// CS52: CS52 and MB20_32B_WORD6
/// CS52: CS52 and MB11_64B_WORD8
/// CS52: Message Buffer 52 CS Register
/// MB11_64B_WORD8: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD6: Message Buffer 20 WORD_32B Register
/// MB34_16B_WORD2: Message Buffer 34 WORD_16B Register
/// MB52_8B_CS: Message Buffer 52 CS Register
pub mod CS52 {
    pub use super::CS7::BRS;
    pub use super::CS7::CODE;
    pub use super::CS7::DATA_BYTE_10;
    pub use super::CS7::DATA_BYTE_11;
    pub use super::CS7::DATA_BYTE_24;
    pub use super::CS7::DATA_BYTE_25;
    pub use super::CS7::DATA_BYTE_26;
    pub use super::CS7::DATA_BYTE_27;
    pub use super::CS7::DATA_BYTE_32;
    pub use super::CS7::DATA_BYTE_33;
    pub use super::CS7::DATA_BYTE_34;
    pub use super::CS7::DATA_BYTE_35;
    pub use super::CS7::DATA_BYTE_8;
    pub use super::CS7::DATA_BYTE_9;
    pub use super::CS7::DLC;
    pub use super::CS7::EDL;
    pub use super::CS7::ESI;
    pub use super::CS7::IDE;
    pub use super::CS7::RTR;
    pub use super::CS7::SRR;
    pub use super::CS7::TIME_STAMP;
}

/// ID52 and MB52_8B_ID
/// ID52: ID52 and MB34_16B_WORD3
/// ID52: ID52 and MB20_32B_WORD7
/// ID52: ID52 and MB11_64B_WORD9
/// ID52: Message Buffer 52 ID Register
/// MB11_64B_WORD9: Message Buffer 11 WORD_64B Register
/// MB20_32B_WORD7: Message Buffer 20 WORD_32B Register
/// MB34_16B_WORD3: Message Buffer 34 WORD_16B Register
/// MB52_8B_ID: Message Buffer 52 ID Register
pub mod ID52 {
    pub use super::ID7::DATA_BYTE_12;
    pub use super::ID7::DATA_BYTE_13;
    pub use super::ID7::DATA_BYTE_14;
    pub use super::ID7::DATA_BYTE_15;
    pub use super::ID7::DATA_BYTE_28;
    pub use super::ID7::DATA_BYTE_29;
    pub use super::ID7::DATA_BYTE_30;
    pub use super::ID7::DATA_BYTE_31;
    pub use super::ID7::DATA_BYTE_36;
    pub use super::ID7::DATA_BYTE_37;
    pub use super::ID7::DATA_BYTE_38;
    pub use super::ID7::DATA_BYTE_39;
    pub use super::ID7::EXT;
    pub use super::ID7::PRIO;
    pub use super::ID7::STD;
}

/// MB11_64B_WORD10 and WORD052
/// MB11_64B_WORD10: MB11_64B_WORD10 and MB52_8B_WORD0
/// MB11_64B_WORD10: MB11_64B_WORD10 and MB35_16B_CS
/// MB11_64B_WORD10: MB11_64B_WORD10 and MB21_32B_CS
/// MB11_64B_WORD10: Message Buffer 11 WORD_64B Register
/// MB21_32B_CS: Message Buffer 21 CS Register
/// MB35_16B_CS: Message Buffer 35 CS Register
/// MB52_8B_WORD0: Message Buffer 52 WORD_8B Register
/// WORD052: Message Buffer 52 WORD0 Register
pub mod MB11_64B_WORD10 {
    pub use super::MB1_64B_WORD10::BRS;
    pub use super::MB1_64B_WORD10::CODE;
    pub use super::MB1_64B_WORD10::DATA_BYTE_0;
    pub use super::MB1_64B_WORD10::DATA_BYTE_1;
    pub use super::MB1_64B_WORD10::DATA_BYTE_2;
    pub use super::MB1_64B_WORD10::DATA_BYTE_3;
    pub use super::MB1_64B_WORD10::DATA_BYTE_40;
    pub use super::MB1_64B_WORD10::DATA_BYTE_41;
    pub use super::MB1_64B_WORD10::DATA_BYTE_42;
    pub use super::MB1_64B_WORD10::DATA_BYTE_43;
    pub use super::MB1_64B_WORD10::DLC;
    pub use super::MB1_64B_WORD10::EDL;
    pub use super::MB1_64B_WORD10::ESI;
    pub use super::MB1_64B_WORD10::IDE;
    pub use super::MB1_64B_WORD10::RTR;
    pub use super::MB1_64B_WORD10::SRR;
    pub use super::MB1_64B_WORD10::TIME_STAMP;
}

/// MB11_64B_WORD11 and WORD152
/// MB11_64B_WORD11: MB11_64B_WORD11 and MB52_8B_WORD1
/// MB11_64B_WORD11: MB11_64B_WORD11 and MB35_16B_ID
/// MB11_64B_WORD11: MB11_64B_WORD11 and MB21_32B_ID
/// MB11_64B_WORD11: Message Buffer 11 WORD_64B Register
/// MB21_32B_ID: Message Buffer 21 ID Register
/// MB35_16B_ID: Message Buffer 35 ID Register
/// MB52_8B_WORD1: Message Buffer 52 WORD_8B Register
/// WORD152: Message Buffer 52 WORD1 Register
pub mod MB11_64B_WORD11 {
    pub use super::MB1_64B_WORD11::DATA_BYTE_4;
    pub use super::MB1_64B_WORD11::DATA_BYTE_44;
    pub use super::MB1_64B_WORD11::DATA_BYTE_45;
    pub use super::MB1_64B_WORD11::DATA_BYTE_46;
    pub use super::MB1_64B_WORD11::DATA_BYTE_47;
    pub use super::MB1_64B_WORD11::DATA_BYTE_5;
    pub use super::MB1_64B_WORD11::DATA_BYTE_6;
    pub use super::MB1_64B_WORD11::DATA_BYTE_7;
    pub use super::MB1_64B_WORD11::EXT;
    pub use super::MB1_64B_WORD11::PRIO;
    pub use super::MB1_64B_WORD11::STD;
}

/// CS53 and MB53_8B_CS
/// CS53: CS53 and MB35_16B_WORD0
/// CS53: CS53 and MB21_32B_WORD0
/// CS53: CS53 and MB11_64B_WORD12
/// CS53: Message Buffer 53 CS Register
/// MB11_64B_WORD12: Message Buffer 11 WORD_64B Register
/// MB21_32B_WORD0: Message Buffer 21 WORD_32B Register
/// MB35_16B_WORD0: Message Buffer 35 WORD_16B Register
/// MB53_8B_CS: Message Buffer 53 CS Register
pub mod CS53 {
    pub use super::CS8::BRS;
    pub use super::CS8::CODE;
    pub use super::CS8::DATA_BYTE_0;
    pub use super::CS8::DATA_BYTE_1;
    pub use super::CS8::DATA_BYTE_2;
    pub use super::CS8::DATA_BYTE_3;
    pub use super::CS8::DATA_BYTE_48;
    pub use super::CS8::DATA_BYTE_49;
    pub use super::CS8::DATA_BYTE_50;
    pub use super::CS8::DATA_BYTE_51;
    pub use super::CS8::DLC;
    pub use super::CS8::EDL;
    pub use super::CS8::ESI;
    pub use super::CS8::IDE;
    pub use super::CS8::RTR;
    pub use super::CS8::SRR;
    pub use super::CS8::TIME_STAMP;
}

/// ID53 and MB53_8B_ID
/// ID53: ID53 and MB35_16B_WORD1
/// ID53: ID53 and MB21_32B_WORD1
/// ID53: ID53 and MB11_64B_WORD13
/// ID53: Message Buffer 53 ID Register
/// MB11_64B_WORD13: Message Buffer 11 WORD_64B Register
/// MB21_32B_WORD1: Message Buffer 21 WORD_32B Register
/// MB35_16B_WORD1: Message Buffer 35 WORD_16B Register
/// MB53_8B_ID: Message Buffer 53 ID Register
pub mod ID53 {
    pub use super::ID8::DATA_BYTE_4;
    pub use super::ID8::DATA_BYTE_5;
    pub use super::ID8::DATA_BYTE_52;
    pub use super::ID8::DATA_BYTE_53;
    pub use super::ID8::DATA_BYTE_54;
    pub use super::ID8::DATA_BYTE_55;
    pub use super::ID8::DATA_BYTE_6;
    pub use super::ID8::DATA_BYTE_7;
    pub use super::ID8::EXT;
    pub use super::ID8::PRIO;
    pub use super::ID8::STD;
}

/// MB11_64B_WORD14 and WORD053
/// MB11_64B_WORD14: MB11_64B_WORD14 and MB53_8B_WORD0
/// MB11_64B_WORD14: MB11_64B_WORD14 and MB35_16B_WORD2
/// MB11_64B_WORD14: MB11_64B_WORD14 and MB21_32B_WORD2
/// MB11_64B_WORD14: Message Buffer 11 WORD_64B Register
/// MB21_32B_WORD2: Message Buffer 21 WORD_32B Register
/// MB35_16B_WORD2: Message Buffer 35 WORD_16B Register
/// MB53_8B_WORD0: Message Buffer 53 WORD_8B Register
/// WORD053: Message Buffer 53 WORD0 Register
pub mod MB11_64B_WORD14 {
    pub use super::MB1_64B_WORD14::DATA_BYTE_0;
    pub use super::MB1_64B_WORD14::DATA_BYTE_1;
    pub use super::MB1_64B_WORD14::DATA_BYTE_10;
    pub use super::MB1_64B_WORD14::DATA_BYTE_11;
    pub use super::MB1_64B_WORD14::DATA_BYTE_2;
    pub use super::MB1_64B_WORD14::DATA_BYTE_3;
    pub use super::MB1_64B_WORD14::DATA_BYTE_56;
    pub use super::MB1_64B_WORD14::DATA_BYTE_57;
    pub use super::MB1_64B_WORD14::DATA_BYTE_58;
    pub use super::MB1_64B_WORD14::DATA_BYTE_59;
    pub use super::MB1_64B_WORD14::DATA_BYTE_8;
    pub use super::MB1_64B_WORD14::DATA_BYTE_9;
}

/// MB11_64B_WORD15 and WORD153
/// MB11_64B_WORD15: MB11_64B_WORD15 and MB53_8B_WORD1
/// MB11_64B_WORD15: MB11_64B_WORD15 and MB35_16B_WORD3
/// MB11_64B_WORD15: MB11_64B_WORD15 and MB21_32B_WORD3
/// MB11_64B_WORD15: Message Buffer 11 WORD_64B Register
/// MB21_32B_WORD3: Message Buffer 21 WORD_32B Register
/// MB35_16B_WORD3: Message Buffer 35 WORD_16B Register
/// MB53_8B_WORD1: Message Buffer 53 WORD_8B Register
/// WORD153: Message Buffer 53 WORD1 Register
pub mod MB11_64B_WORD15 {
    pub use super::MB1_64B_WORD15::DATA_BYTE_12;
    pub use super::MB1_64B_WORD15::DATA_BYTE_13;
    pub use super::MB1_64B_WORD15::DATA_BYTE_14;
    pub use super::MB1_64B_WORD15::DATA_BYTE_15;
    pub use super::MB1_64B_WORD15::DATA_BYTE_4;
    pub use super::MB1_64B_WORD15::DATA_BYTE_5;
    pub use super::MB1_64B_WORD15::DATA_BYTE_6;
    pub use super::MB1_64B_WORD15::DATA_BYTE_60;
    pub use super::MB1_64B_WORD15::DATA_BYTE_61;
    pub use super::MB1_64B_WORD15::DATA_BYTE_62;
    pub use super::MB1_64B_WORD15::DATA_BYTE_63;
    pub use super::MB1_64B_WORD15::DATA_BYTE_7;
}

/// CS54 and MB54_8B_CS
/// CS54: CS54 and MB36_16B_CS
/// CS54: CS54 and MB21_32B_WORD4
/// CS54: CS54 and MB12_64B_CS
/// CS54: Message Buffer 54 CS Register
/// MB12_64B_CS: Message Buffer 12 CS Register
/// MB21_32B_WORD4: Message Buffer 21 WORD_32B Register
/// MB36_16B_CS: Message Buffer 36 CS Register
/// MB54_8B_CS: Message Buffer 54 CS Register
pub mod CS54 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID54 and MB54_8B_ID
/// ID54: ID54 and MB36_16B_ID
/// ID54: ID54 and MB21_32B_WORD5
/// ID54: ID54 and MB12_64B_ID
/// ID54: Message Buffer 54 ID Register
/// MB12_64B_ID: Message Buffer 12 ID Register
/// MB21_32B_WORD5: Message Buffer 21 WORD_32B Register
/// MB36_16B_ID: Message Buffer 36 ID Register
/// MB54_8B_ID: Message Buffer 54 ID Register
pub mod ID54 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB12_64B_WORD0 and WORD054
/// MB12_64B_WORD0: MB12_64B_WORD0 and MB54_8B_WORD0
/// MB12_64B_WORD0: MB12_64B_WORD0 and MB36_16B_WORD0
/// MB12_64B_WORD0: MB12_64B_WORD0 and MB21_32B_WORD6
/// MB12_64B_WORD0: Message Buffer 12 WORD_64B Register
/// MB21_32B_WORD6: Message Buffer 21 WORD_32B Register
/// MB36_16B_WORD0: Message Buffer 36 WORD_16B Register
/// MB54_8B_WORD0: Message Buffer 54 WORD_8B Register
/// WORD054: Message Buffer 54 WORD0 Register
pub mod MB12_64B_WORD0 {
    pub use super::MB2_64B_WORD0::DATA_BYTE_0;
    pub use super::MB2_64B_WORD0::DATA_BYTE_1;
    pub use super::MB2_64B_WORD0::DATA_BYTE_2;
    pub use super::MB2_64B_WORD0::DATA_BYTE_24;
    pub use super::MB2_64B_WORD0::DATA_BYTE_25;
    pub use super::MB2_64B_WORD0::DATA_BYTE_26;
    pub use super::MB2_64B_WORD0::DATA_BYTE_27;
    pub use super::MB2_64B_WORD0::DATA_BYTE_3;
}

/// MB12_64B_WORD1 and WORD154
/// MB12_64B_WORD1: MB12_64B_WORD1 and MB54_8B_WORD1
/// MB12_64B_WORD1: MB12_64B_WORD1 and MB36_16B_WORD1
/// MB12_64B_WORD1: MB12_64B_WORD1 and MB21_32B_WORD7
/// MB12_64B_WORD1: Message Buffer 12 WORD_64B Register
/// MB21_32B_WORD7: Message Buffer 21 WORD_32B Register
/// MB36_16B_WORD1: Message Buffer 36 WORD_16B Register
/// MB54_8B_WORD1: Message Buffer 54 WORD_8B Register
/// WORD154: Message Buffer 54 WORD1 Register
pub mod MB12_64B_WORD1 {
    pub use super::MB2_64B_WORD1::DATA_BYTE_28;
    pub use super::MB2_64B_WORD1::DATA_BYTE_29;
    pub use super::MB2_64B_WORD1::DATA_BYTE_30;
    pub use super::MB2_64B_WORD1::DATA_BYTE_31;
    pub use super::MB2_64B_WORD1::DATA_BYTE_4;
    pub use super::MB2_64B_WORD1::DATA_BYTE_5;
    pub use super::MB2_64B_WORD1::DATA_BYTE_6;
    pub use super::MB2_64B_WORD1::DATA_BYTE_7;
}

/// CS55 and MB55_8B_CS
/// CS55: CS55 and MB36_16B_WORD2
/// CS55: CS55 and MB22_32B_CS
/// CS55: CS55 and MB12_64B_WORD2
/// CS55: Message Buffer 55 CS Register
/// MB12_64B_WORD2: Message Buffer 12 WORD_64B Register
/// MB22_32B_CS: Message Buffer 22 CS Register
/// MB36_16B_WORD2: Message Buffer 36 WORD_16B Register
/// MB55_8B_CS: Message Buffer 55 CS Register
pub mod CS55 {
    pub use super::CS1::BRS;
    pub use super::CS1::CODE;
    pub use super::CS1::DATA_BYTE_10;
    pub use super::CS1::DATA_BYTE_11;
    pub use super::CS1::DATA_BYTE_8;
    pub use super::CS1::DATA_BYTE_9;
    pub use super::CS1::DLC;
    pub use super::CS1::EDL;
    pub use super::CS1::ESI;
    pub use super::CS1::IDE;
    pub use super::CS1::RTR;
    pub use super::CS1::SRR;
    pub use super::CS1::TIME_STAMP;
}

/// ID55 and MB55_8B_ID
/// ID55: ID55 and MB36_16B_WORD3
/// ID55: ID55 and MB22_32B_ID
/// ID55: ID55 and MB12_64B_WORD3
/// ID55: Message Buffer 55 ID Register
/// MB12_64B_WORD3: Message Buffer 12 WORD_64B Register
/// MB22_32B_ID: Message Buffer 22 ID Register
/// MB36_16B_WORD3: Message Buffer 36 WORD_16B Register
/// MB55_8B_ID: Message Buffer 55 ID Register
pub mod ID55 {
    pub use super::ID1::DATA_BYTE_12;
    pub use super::ID1::DATA_BYTE_13;
    pub use super::ID1::DATA_BYTE_14;
    pub use super::ID1::DATA_BYTE_15;
    pub use super::ID1::EXT;
    pub use super::ID1::PRIO;
    pub use super::ID1::STD;
}

/// MB12_64B_WORD4 and WORD055
/// MB12_64B_WORD4: MB12_64B_WORD4 and MB55_8B_WORD0
/// MB12_64B_WORD4: MB12_64B_WORD4 and MB37_16B_CS
/// MB12_64B_WORD4: MB12_64B_WORD4 and MB22_32B_WORD0
/// MB12_64B_WORD4: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD0: Message Buffer 22 WORD_32B Register
/// MB37_16B_CS: Message Buffer 37 CS Register
/// MB55_8B_WORD0: Message Buffer 55 WORD_8B Register
/// WORD055: Message Buffer 55 WORD0 Register
pub mod MB12_64B_WORD4 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_64B_WORD5 and WORD155
/// MB12_64B_WORD5: MB12_64B_WORD5 and MB55_8B_WORD1
/// MB12_64B_WORD5: MB12_64B_WORD5 and MB37_16B_ID
/// MB12_64B_WORD5: MB12_64B_WORD5 and MB22_32B_WORD1
/// MB12_64B_WORD5: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD1: Message Buffer 22 WORD_32B Register
/// MB37_16B_ID: Message Buffer 37 ID Register
/// MB55_8B_WORD1: Message Buffer 55 WORD_8B Register
/// WORD155: Message Buffer 55 WORD1 Register
pub mod MB12_64B_WORD5 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS56 and MB56_8B_CS
/// CS56: CS56 and MB37_16B_WORD0
/// CS56: CS56 and MB22_32B_WORD2
/// CS56: CS56 and MB12_64B_WORD6
/// CS56: Message Buffer 56 CS Register
/// MB12_64B_WORD6: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD2: Message Buffer 22 WORD_32B Register
/// MB37_16B_WORD0: Message Buffer 37 WORD_16B Register
/// MB56_8B_CS: Message Buffer 56 CS Register
pub mod CS56 {
    pub use super::CS11::BRS;
    pub use super::CS11::CODE;
    pub use super::CS11::DATA_BYTE_0;
    pub use super::CS11::DATA_BYTE_1;
    pub use super::CS11::DATA_BYTE_10;
    pub use super::CS11::DATA_BYTE_11;
    pub use super::CS11::DATA_BYTE_2;
    pub use super::CS11::DATA_BYTE_24;
    pub use super::CS11::DATA_BYTE_25;
    pub use super::CS11::DATA_BYTE_26;
    pub use super::CS11::DATA_BYTE_27;
    pub use super::CS11::DATA_BYTE_3;
    pub use super::CS11::DATA_BYTE_8;
    pub use super::CS11::DATA_BYTE_9;
    pub use super::CS11::DLC;
    pub use super::CS11::EDL;
    pub use super::CS11::ESI;
    pub use super::CS11::IDE;
    pub use super::CS11::RTR;
    pub use super::CS11::SRR;
    pub use super::CS11::TIME_STAMP;
}

/// ID56 and MB56_8B_ID
/// ID56: ID56 and MB37_16B_WORD1
/// ID56: ID56 and MB22_32B_WORD3
/// ID56: ID56 and MB12_64B_WORD7
/// ID56: Message Buffer 56 ID Register
/// MB12_64B_WORD7: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD3: Message Buffer 22 WORD_32B Register
/// MB37_16B_WORD1: Message Buffer 37 WORD_16B Register
/// MB56_8B_ID: Message Buffer 56 ID Register
pub mod ID56 {
    pub use super::ID11::DATA_BYTE_12;
    pub use super::ID11::DATA_BYTE_13;
    pub use super::ID11::DATA_BYTE_14;
    pub use super::ID11::DATA_BYTE_15;
    pub use super::ID11::DATA_BYTE_28;
    pub use super::ID11::DATA_BYTE_29;
    pub use super::ID11::DATA_BYTE_30;
    pub use super::ID11::DATA_BYTE_31;
    pub use super::ID11::DATA_BYTE_4;
    pub use super::ID11::DATA_BYTE_5;
    pub use super::ID11::DATA_BYTE_6;
    pub use super::ID11::DATA_BYTE_7;
    pub use super::ID11::EXT;
    pub use super::ID11::PRIO;
    pub use super::ID11::STD;
}

/// MB12_64B_WORD8 and WORD056
/// MB12_64B_WORD8: MB12_64B_WORD8 and MB56_8B_WORD0
/// MB12_64B_WORD8: MB12_64B_WORD8 and MB37_16B_WORD2
/// MB12_64B_WORD8: MB12_64B_WORD8 and MB22_32B_WORD4
/// MB12_64B_WORD8: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD4: Message Buffer 22 WORD_32B Register
/// MB37_16B_WORD2: Message Buffer 37 WORD_16B Register
/// MB56_8B_WORD0: Message Buffer 56 WORD_8B Register
/// WORD056: Message Buffer 56 WORD0 Register
pub mod MB12_64B_WORD8 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_19 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_18 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_17 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_16 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_64B_WORD9 and WORD156
/// MB12_64B_WORD9: MB12_64B_WORD9 and MB56_8B_WORD1
/// MB12_64B_WORD9: MB12_64B_WORD9 and MB37_16B_WORD3
/// MB12_64B_WORD9: MB12_64B_WORD9 and MB22_32B_WORD5
/// MB12_64B_WORD9: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD5: Message Buffer 22 WORD_32B Register
/// MB37_16B_WORD3: Message Buffer 37 WORD_16B Register
/// MB56_8B_WORD1: Message Buffer 56 WORD_8B Register
/// WORD156: Message Buffer 56 WORD1 Register
pub mod MB12_64B_WORD9 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_23 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_22 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_21 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_20 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS57 and MB57_8B_CS
/// CS57: CS57 and MB38_16B_CS
/// CS57: CS57 and MB22_32B_WORD6
/// CS57: CS57 and MB12_64B_WORD10
/// CS57: Message Buffer 57 CS Register
/// MB12_64B_WORD10: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD6: Message Buffer 22 WORD_32B Register
/// MB38_16B_CS: Message Buffer 38 CS Register
/// MB57_8B_CS: Message Buffer 57 CS Register
pub mod CS57 {
    pub use super::CS12::BRS;
    pub use super::CS12::CODE;
    pub use super::CS12::DATA_BYTE_24;
    pub use super::CS12::DATA_BYTE_25;
    pub use super::CS12::DATA_BYTE_26;
    pub use super::CS12::DATA_BYTE_27;
    pub use super::CS12::DATA_BYTE_40;
    pub use super::CS12::DATA_BYTE_41;
    pub use super::CS12::DATA_BYTE_42;
    pub use super::CS12::DATA_BYTE_43;
    pub use super::CS12::DLC;
    pub use super::CS12::EDL;
    pub use super::CS12::ESI;
    pub use super::CS12::IDE;
    pub use super::CS12::RTR;
    pub use super::CS12::SRR;
    pub use super::CS12::TIME_STAMP;
}

/// ID57 and MB57_8B_ID
/// ID57: ID57 and MB38_16B_ID
/// ID57: ID57 and MB22_32B_WORD7
/// ID57: ID57 and MB12_64B_WORD11
/// ID57: Message Buffer 57 ID Register
/// MB12_64B_WORD11: Message Buffer 12 WORD_64B Register
/// MB22_32B_WORD7: Message Buffer 22 WORD_32B Register
/// MB38_16B_ID: Message Buffer 38 ID Register
/// MB57_8B_ID: Message Buffer 57 ID Register
pub mod ID57 {
    pub use super::ID12::DATA_BYTE_28;
    pub use super::ID12::DATA_BYTE_29;
    pub use super::ID12::DATA_BYTE_30;
    pub use super::ID12::DATA_BYTE_31;
    pub use super::ID12::DATA_BYTE_44;
    pub use super::ID12::DATA_BYTE_45;
    pub use super::ID12::DATA_BYTE_46;
    pub use super::ID12::DATA_BYTE_47;
    pub use super::ID12::EXT;
    pub use super::ID12::PRIO;
    pub use super::ID12::STD;
}

/// MB12_64B_WORD12 and WORD057
/// MB12_64B_WORD12: MB12_64B_WORD12 and MB57_8B_WORD0
/// MB12_64B_WORD12: MB12_64B_WORD12 and MB38_16B_WORD0
/// MB12_64B_WORD12: MB12_64B_WORD12 and MB23_32B_CS
/// MB12_64B_WORD12: Message Buffer 12 WORD_64B Register
/// MB23_32B_CS: Message Buffer 23 CS Register
/// MB38_16B_WORD0: Message Buffer 38 WORD_16B Register
/// MB57_8B_WORD0: Message Buffer 57 WORD_8B Register
/// WORD057: Message Buffer 57 WORD0 Register
pub mod MB12_64B_WORD12 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_51 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_50 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_49 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_48 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB12_64B_WORD13 and WORD157
/// MB12_64B_WORD13: MB12_64B_WORD13 and MB57_8B_WORD1
/// MB12_64B_WORD13: MB12_64B_WORD13 and MB38_16B_WORD1
/// MB12_64B_WORD13: MB12_64B_WORD13 and MB23_32B_ID
/// MB12_64B_WORD13: Message Buffer 12 WORD_64B Register
/// MB23_32B_ID: Message Buffer 23 ID Register
/// MB38_16B_WORD1: Message Buffer 38 WORD_16B Register
/// MB57_8B_WORD1: Message Buffer 57 WORD_8B Register
/// WORD157: Message Buffer 57 WORD1 Register
pub mod MB12_64B_WORD13 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_55 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_54 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_53 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_52 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS58 and MB58_8B_CS
/// CS58: CS58 and MB38_16B_WORD2
/// CS58: CS58 and MB23_32B_WORD0
/// CS58: CS58 and MB12_64B_WORD14
/// CS58: Message Buffer 58 CS Register
/// MB12_64B_WORD14: Message Buffer 12 WORD_64B Register
/// MB23_32B_WORD0: Message Buffer 23 WORD_32B Register
/// MB38_16B_WORD2: Message Buffer 38 WORD_16B Register
/// MB58_8B_CS: Message Buffer 58 CS Register
pub mod CS58 {
    pub use super::CS13::BRS;
    pub use super::CS13::CODE;
    pub use super::CS13::DATA_BYTE_0;
    pub use super::CS13::DATA_BYTE_1;
    pub use super::CS13::DATA_BYTE_10;
    pub use super::CS13::DATA_BYTE_11;
    pub use super::CS13::DATA_BYTE_2;
    pub use super::CS13::DATA_BYTE_3;
    pub use super::CS13::DATA_BYTE_56;
    pub use super::CS13::DATA_BYTE_57;
    pub use super::CS13::DATA_BYTE_58;
    pub use super::CS13::DATA_BYTE_59;
    pub use super::CS13::DATA_BYTE_8;
    pub use super::CS13::DATA_BYTE_9;
    pub use super::CS13::DLC;
    pub use super::CS13::EDL;
    pub use super::CS13::ESI;
    pub use super::CS13::IDE;
    pub use super::CS13::RTR;
    pub use super::CS13::SRR;
    pub use super::CS13::TIME_STAMP;
}

/// ID58 and MB58_8B_ID
/// ID58: ID58 and MB38_16B_WORD3
/// ID58: ID58 and MB23_32B_WORD1
/// ID58: ID58 and MB12_64B_WORD15
/// ID58: Message Buffer 58 ID Register
/// MB12_64B_WORD15: Message Buffer 12 WORD_64B Register
/// MB23_32B_WORD1: Message Buffer 23 WORD_32B Register
/// MB38_16B_WORD3: Message Buffer 38 WORD_16B Register
/// MB58_8B_ID: Message Buffer 58 ID Register
pub mod ID58 {
    pub use super::ID13::DATA_BYTE_12;
    pub use super::ID13::DATA_BYTE_13;
    pub use super::ID13::DATA_BYTE_14;
    pub use super::ID13::DATA_BYTE_15;
    pub use super::ID13::DATA_BYTE_4;
    pub use super::ID13::DATA_BYTE_5;
    pub use super::ID13::DATA_BYTE_6;
    pub use super::ID13::DATA_BYTE_60;
    pub use super::ID13::DATA_BYTE_61;
    pub use super::ID13::DATA_BYTE_62;
    pub use super::ID13::DATA_BYTE_63;
    pub use super::ID13::DATA_BYTE_7;
    pub use super::ID13::EXT;
    pub use super::ID13::PRIO;
    pub use super::ID13::STD;
}

/// MB13_64B_CS and WORD058
/// MB13_64B_CS: MB13_64B_CS and MB58_8B_WORD0
/// MB13_64B_CS: MB13_64B_CS and MB39_16B_CS
/// MB13_64B_CS: MB13_64B_CS and MB23_32B_WORD2
/// MB13_64B_CS: Message Buffer 13 CS Register
/// MB23_32B_WORD2: Message Buffer 23 WORD_32B Register
/// MB39_16B_CS: Message Buffer 39 CS Register
/// MB58_8B_WORD0: Message Buffer 58 WORD_8B Register
/// WORD058: Message Buffer 58 WORD0 Register
pub mod MB13_64B_CS {
    pub use super::MB13_32B_CS::BRS;
    pub use super::MB13_32B_CS::CODE;
    pub use super::MB13_32B_CS::DATA_BYTE_0;
    pub use super::MB13_32B_CS::DATA_BYTE_1;
    pub use super::MB13_32B_CS::DATA_BYTE_10;
    pub use super::MB13_32B_CS::DATA_BYTE_11;
    pub use super::MB13_32B_CS::DATA_BYTE_2;
    pub use super::MB13_32B_CS::DATA_BYTE_3;
    pub use super::MB13_32B_CS::DATA_BYTE_8;
    pub use super::MB13_32B_CS::DATA_BYTE_9;
    pub use super::MB13_32B_CS::DLC;
    pub use super::MB13_32B_CS::EDL;
    pub use super::MB13_32B_CS::ESI;
    pub use super::MB13_32B_CS::IDE;
    pub use super::MB13_32B_CS::RTR;
    pub use super::MB13_32B_CS::SRR;
    pub use super::MB13_32B_CS::TIME_STAMP;
}

/// MB13_64B_ID and WORD158
/// MB13_64B_ID: MB13_64B_ID and MB58_8B_WORD1
/// MB13_64B_ID: MB13_64B_ID and MB39_16B_ID
/// MB13_64B_ID: MB13_64B_ID and MB23_32B_WORD3
/// MB13_64B_ID: Message Buffer 13 ID Register
/// MB23_32B_WORD3: Message Buffer 23 WORD_32B Register
/// MB39_16B_ID: Message Buffer 39 ID Register
/// MB58_8B_WORD1: Message Buffer 58 WORD_8B Register
/// WORD158: Message Buffer 58 WORD1 Register
pub mod MB13_64B_ID {
    pub use super::MB13_32B_ID::DATA_BYTE_12;
    pub use super::MB13_32B_ID::DATA_BYTE_13;
    pub use super::MB13_32B_ID::DATA_BYTE_14;
    pub use super::MB13_32B_ID::DATA_BYTE_15;
    pub use super::MB13_32B_ID::DATA_BYTE_4;
    pub use super::MB13_32B_ID::DATA_BYTE_5;
    pub use super::MB13_32B_ID::DATA_BYTE_6;
    pub use super::MB13_32B_ID::DATA_BYTE_7;
    pub use super::MB13_32B_ID::EXT;
    pub use super::MB13_32B_ID::PRIO;
    pub use super::MB13_32B_ID::STD;
}

/// CS59 and MB59_8B_CS
/// CS59: CS59 and MB39_16B_WORD0
/// CS59: CS59 and MB23_32B_WORD4
/// CS59: CS59 and MB13_64B_WORD0
/// CS59: Message Buffer 59 CS Register
/// MB13_64B_WORD0: Message Buffer 13 WORD_64B Register
/// MB23_32B_WORD4: Message Buffer 23 WORD_32B Register
/// MB39_16B_WORD0: Message Buffer 39 WORD_16B Register
/// MB59_8B_CS: Message Buffer 59 CS Register
pub mod CS59 {
    pub use super::CS14::BRS;
    pub use super::CS14::CODE;
    pub use super::CS14::DATA_BYTE_0;
    pub use super::CS14::DATA_BYTE_1;
    pub use super::CS14::DATA_BYTE_16;
    pub use super::CS14::DATA_BYTE_17;
    pub use super::CS14::DATA_BYTE_18;
    pub use super::CS14::DATA_BYTE_19;
    pub use super::CS14::DATA_BYTE_2;
    pub use super::CS14::DATA_BYTE_3;
    pub use super::CS14::DLC;
    pub use super::CS14::EDL;
    pub use super::CS14::ESI;
    pub use super::CS14::IDE;
    pub use super::CS14::RTR;
    pub use super::CS14::SRR;
    pub use super::CS14::TIME_STAMP;
}

/// ID59 and MB59_8B_ID
/// ID59: ID59 and MB39_16B_WORD1
/// ID59: ID59 and MB23_32B_WORD5
/// ID59: ID59 and MB13_64B_WORD1
/// ID59: Message Buffer 59 ID Register
/// MB13_64B_WORD1: Message Buffer 13 WORD_64B Register
/// MB23_32B_WORD5: Message Buffer 23 WORD_32B Register
/// MB39_16B_WORD1: Message Buffer 39 WORD_16B Register
/// MB59_8B_ID: Message Buffer 59 ID Register
pub mod ID59 {
    pub use super::ID14::DATA_BYTE_20;
    pub use super::ID14::DATA_BYTE_21;
    pub use super::ID14::DATA_BYTE_22;
    pub use super::ID14::DATA_BYTE_23;
    pub use super::ID14::DATA_BYTE_4;
    pub use super::ID14::DATA_BYTE_5;
    pub use super::ID14::DATA_BYTE_6;
    pub use super::ID14::DATA_BYTE_7;
    pub use super::ID14::EXT;
    pub use super::ID14::PRIO;
    pub use super::ID14::STD;
}

/// MB13_64B_WORD2 and WORD059
/// MB13_64B_WORD2: MB13_64B_WORD2 and MB59_8B_WORD0
/// MB13_64B_WORD2: MB13_64B_WORD2 and MB39_16B_WORD2
/// MB13_64B_WORD2: MB13_64B_WORD2 and MB23_32B_WORD6
/// MB13_64B_WORD2: Message Buffer 13 WORD_64B Register
/// MB23_32B_WORD6: Message Buffer 23 WORD_32B Register
/// MB39_16B_WORD2: Message Buffer 39 WORD_16B Register
/// MB59_8B_WORD0: Message Buffer 59 WORD_8B Register
/// WORD059: Message Buffer 59 WORD0 Register
pub mod MB13_64B_WORD2 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_64B_WORD3 and WORD159
/// MB13_64B_WORD3: MB13_64B_WORD3 and MB59_8B_WORD1
/// MB13_64B_WORD3: MB13_64B_WORD3 and MB39_16B_WORD3
/// MB13_64B_WORD3: MB13_64B_WORD3 and MB23_32B_WORD7
/// MB13_64B_WORD3: Message Buffer 13 WORD_64B Register
/// MB23_32B_WORD7: Message Buffer 23 WORD_32B Register
/// MB39_16B_WORD3: Message Buffer 39 WORD_16B Register
/// MB59_8B_WORD1: Message Buffer 59 WORD_8B Register
/// WORD159: Message Buffer 59 WORD1 Register
pub mod MB13_64B_WORD3 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS60 and MB60_8B_CS
/// CS60: CS60 and MB40_16B_CS
/// CS60: CS60 and MB13_64B_WORD4
/// CS60: Message Buffer 60 CS Register
/// MB13_64B_WORD4: Message Buffer 13 WORD_64B Register
/// MB40_16B_CS: Message Buffer 40 CS Register
/// MB60_8B_CS: Message Buffer 60 CS Register
pub mod CS60 {
    pub use super::CS9::BRS;
    pub use super::CS9::CODE;
    pub use super::CS9::DATA_BYTE_16;
    pub use super::CS9::DATA_BYTE_17;
    pub use super::CS9::DATA_BYTE_18;
    pub use super::CS9::DATA_BYTE_19;
    pub use super::CS9::DLC;
    pub use super::CS9::EDL;
    pub use super::CS9::ESI;
    pub use super::CS9::IDE;
    pub use super::CS9::RTR;
    pub use super::CS9::SRR;
    pub use super::CS9::TIME_STAMP;
}

/// ID60 and MB60_8B_ID
/// ID60: ID60 and MB40_16B_ID
/// ID60: ID60 and MB13_64B_WORD5
/// ID60: Message Buffer 60 ID Register
/// MB13_64B_WORD5: Message Buffer 13 WORD_64B Register
/// MB40_16B_ID: Message Buffer 40 ID Register
/// MB60_8B_ID: Message Buffer 60 ID Register
pub mod ID60 {
    pub use super::ID9::DATA_BYTE_20;
    pub use super::ID9::DATA_BYTE_21;
    pub use super::ID9::DATA_BYTE_22;
    pub use super::ID9::DATA_BYTE_23;
    pub use super::ID9::EXT;
    pub use super::ID9::PRIO;
    pub use super::ID9::STD;
}

/// MB13_64B_WORD6 and WORD060
/// MB13_64B_WORD6: MB13_64B_WORD6 and MB60_8B_WORD0
/// MB13_64B_WORD6: MB13_64B_WORD6 and MB40_16B_WORD0
/// MB13_64B_WORD6: Message Buffer 13 WORD_64B Register
/// MB40_16B_WORD0: Message Buffer 40 WORD_16B Register
/// MB60_8B_WORD0: Message Buffer 60 WORD_8B Register
/// WORD060: Message Buffer 60 WORD0 Register
pub mod MB13_64B_WORD6 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_27 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_26 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_25 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_24 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_3 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_2 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_1 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_0 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_64B_WORD7 and WORD160
/// MB13_64B_WORD7: MB13_64B_WORD7 and MB60_8B_WORD1
/// MB13_64B_WORD7: MB13_64B_WORD7 and MB40_16B_WORD1
/// MB13_64B_WORD7: Message Buffer 13 WORD_64B Register
/// MB40_16B_WORD1: Message Buffer 40 WORD_16B Register
/// MB60_8B_WORD1: Message Buffer 60 WORD_8B Register
/// WORD160: Message Buffer 60 WORD1 Register
pub mod MB13_64B_WORD7 {

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_31 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_30 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_29 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_28 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_7 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_6 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_5 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_4 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CS61 and MB61_8B_CS
/// CS61: CS61 and MB40_16B_WORD2
/// CS61: CS61 and MB13_64B_WORD8
/// CS61: Message Buffer 61 CS Register
/// MB13_64B_WORD8: Message Buffer 13 WORD_64B Register
/// MB40_16B_WORD2: Message Buffer 40 WORD_16B Register
/// MB61_8B_CS: Message Buffer 61 CS Register
pub mod CS61 {

    /// Free-Running Counter Time stamp. This 16-bit field is a copy of the Free-Running Timer, captured for Tx and Rx frames at the time when the beginning of the Identifier field appears on the CAN bus.
    pub mod TIME_STAMP {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (16 bits: 0xffff << 0)
        pub const mask: u32 = 0xffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Length of the data to be stored/transmitted.
    pub mod DLC {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (4 bits: 0b1111 << 16)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Remote Transmission Request. One/zero for remote/data frame.
    pub mod RTR {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (1 bit: 1 << 20)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// ID Extended. One/zero for extended/standard format frame.
    pub mod IDE {
        /// Offset (21 bits)
        pub const offset: u32 = 21;
        /// Mask (1 bit: 1 << 21)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Substitute Remote Request. Contains a fixed recessive bit.
    pub mod SRR {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (1 bit: 1 << 22)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Message Buffer Code. This 4-bit field can be accessed (read or write) by the CPU and by the FlexCAN module itself, as part of the message buffer matching and arbitration process.
    pub mod CODE {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (4 bits: 0b1111 << 24)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Error State Indicator. This bit indicates if the transmitting node is error active or error passive.
    pub mod ESI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Bit Rate Switch. This bit defines whether the bit rate is switched inside a CAN FD format frame.
    pub mod BRS {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Length. This bit distinguishes between CAN format and CAN FD format frames. The EDL bit must not be set for Message Buffers configured to RANSWER with code field 0b1010.
    pub mod EDL {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_35 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_34 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_33 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_32 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_11 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_10 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_9 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_8 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// ID61 and MB61_8B_ID
/// ID61: ID61 and MB40_16B_WORD3
/// ID61: ID61 and MB13_64B_WORD9
/// ID61: Message Buffer 61 ID Register
/// MB13_64B_WORD9: Message Buffer 13 WORD_64B Register
/// MB40_16B_WORD3: Message Buffer 40 WORD_16B Register
/// MB61_8B_ID: Message Buffer 61 ID Register
pub mod ID61 {

    /// Contains extended (LOW word) identifier of message buffer.
    pub mod EXT {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (18 bits: 0x3ffff << 0)
        pub const mask: u32 = 0x3ffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Contains standard/extended (HIGH word) identifier of message buffer.
    pub mod STD {
        /// Offset (18 bits)
        pub const offset: u32 = 18;
        /// Mask (11 bits: 0x7ff << 18)
        pub const mask: u32 = 0x7ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Local priority. This 3-bit fieldis only used when LPRIO_EN bit is set in MCR and it only makes sense for Tx buffers. These bits are not transmitted. They are appended to the regular ID to define the transmission priority.
    pub mod PRIO {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (3 bits: 0b111 << 29)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_39 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_38 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_37 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_36 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 0 of Rx/Tx frame.
    pub mod DATA_BYTE_15 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 1 of Rx/Tx frame.
    pub mod DATA_BYTE_14 {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (8 bits: 0xff << 8)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 2 of Rx/Tx frame.
    pub mod DATA_BYTE_13 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (8 bits: 0xff << 16)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data byte 3 of Rx/Tx frame.
    pub mod DATA_BYTE_12 {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (8 bits: 0xff << 24)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// MB13_64B_WORD10 and WORD061
/// MB13_64B_WORD10: MB13_64B_WORD10 and MB61_8B_WORD0
/// MB13_64B_WORD10: MB13_64B_WORD10 and MB41_16B_CS
/// MB13_64B_WORD10: Message Buffer 13 WORD_64B Register
/// MB41_16B_CS: Message Buffer 41 CS Register
/// MB61_8B_WORD0: Message Buffer 61 WORD_8B Register
/// WORD061: Message Buffer 61 WORD0 Register
pub mod MB13_64B_WORD10 {
    pub use super::MB1_64B_WORD10::BRS;
    pub use super::MB1_64B_WORD10::CODE;
    pub use super::MB1_64B_WORD10::DATA_BYTE_0;
    pub use super::MB1_64B_WORD10::DATA_BYTE_1;
    pub use super::MB1_64B_WORD10::DATA_BYTE_2;
    pub use super::MB1_64B_WORD10::DATA_BYTE_3;
    pub use super::MB1_64B_WORD10::DATA_BYTE_40;
    pub use super::MB1_64B_WORD10::DATA_BYTE_41;
    pub use super::MB1_64B_WORD10::DATA_BYTE_42;
    pub use super::MB1_64B_WORD10::DATA_BYTE_43;
    pub use super::MB1_64B_WORD10::DLC;
    pub use super::MB1_64B_WORD10::EDL;
    pub use super::MB1_64B_WORD10::ESI;
    pub use super::MB1_64B_WORD10::IDE;
    pub use super::MB1_64B_WORD10::RTR;
    pub use super::MB1_64B_WORD10::SRR;
    pub use super::MB1_64B_WORD10::TIME_STAMP;
}

/// MB13_64B_WORD11 and WORD161
/// MB13_64B_WORD11: MB13_64B_WORD11 and MB61_8B_WORD1
/// MB13_64B_WORD11: MB13_64B_WORD11 and MB41_16B_ID
/// MB13_64B_WORD11: Message Buffer 13 WORD_64B Register
/// MB41_16B_ID: Message Buffer 41 ID Register
/// MB61_8B_WORD1: Message Buffer 61 WORD_8B Register
/// WORD161: Message Buffer 61 WORD1 Register
pub mod MB13_64B_WORD11 {
    pub use super::MB1_64B_WORD11::DATA_BYTE_4;
    pub use super::MB1_64B_WORD11::DATA_BYTE_44;
    pub use super::MB1_64B_WORD11::DATA_BYTE_45;
    pub use super::MB1_64B_WORD11::DATA_BYTE_46;
    pub use super::MB1_64B_WORD11::DATA_BYTE_47;
    pub use super::MB1_64B_WORD11::DATA_BYTE_5;
    pub use super::MB1_64B_WORD11::DATA_BYTE_6;
    pub use super::MB1_64B_WORD11::DATA_BYTE_7;
    pub use super::MB1_64B_WORD11::EXT;
    pub use super::MB1_64B_WORD11::PRIO;
    pub use super::MB1_64B_WORD11::STD;
}

/// CS62 and MB62_8B_CS
/// CS62: CS62 and MB41_16B_WORD0
/// CS62: CS62 and MB13_64B_WORD12
/// CS62: Message Buffer 62 CS Register
/// MB13_64B_WORD12: Message Buffer 13 WORD_64B Register
/// MB41_16B_WORD0: Message Buffer 41 WORD_16B Register
/// MB62_8B_CS: Message Buffer 62 CS Register
pub mod CS62 {
    pub use super::CS8::BRS;
    pub use super::CS8::CODE;
    pub use super::CS8::DATA_BYTE_0;
    pub use super::CS8::DATA_BYTE_1;
    pub use super::CS8::DATA_BYTE_2;
    pub use super::CS8::DATA_BYTE_3;
    pub use super::CS8::DATA_BYTE_48;
    pub use super::CS8::DATA_BYTE_49;
    pub use super::CS8::DATA_BYTE_50;
    pub use super::CS8::DATA_BYTE_51;
    pub use super::CS8::DLC;
    pub use super::CS8::EDL;
    pub use super::CS8::ESI;
    pub use super::CS8::IDE;
    pub use super::CS8::RTR;
    pub use super::CS8::SRR;
    pub use super::CS8::TIME_STAMP;
}

/// ID62 and MB62_8B_ID
/// ID62: ID62 and MB41_16B_WORD1
/// ID62: ID62 and MB13_64B_WORD13
/// ID62: Message Buffer 62 ID Register
/// MB13_64B_WORD13: Message Buffer 13 WORD_64B Register
/// MB41_16B_WORD1: Message Buffer 41 WORD_16B Register
/// MB62_8B_ID: Message Buffer 62 ID Register
pub mod ID62 {
    pub use super::ID8::DATA_BYTE_4;
    pub use super::ID8::DATA_BYTE_5;
    pub use super::ID8::DATA_BYTE_52;
    pub use super::ID8::DATA_BYTE_53;
    pub use super::ID8::DATA_BYTE_54;
    pub use super::ID8::DATA_BYTE_55;
    pub use super::ID8::DATA_BYTE_6;
    pub use super::ID8::DATA_BYTE_7;
    pub use super::ID8::EXT;
    pub use super::ID8::PRIO;
    pub use super::ID8::STD;
}

/// MB13_64B_WORD14 and WORD062
/// MB13_64B_WORD14: MB13_64B_WORD14 and MB62_8B_WORD0
/// MB13_64B_WORD14: MB13_64B_WORD14 and MB41_16B_WORD2
/// MB13_64B_WORD14: Message Buffer 13 WORD_64B Register
/// MB41_16B_WORD2: Message Buffer 41 WORD_16B Register
/// MB62_8B_WORD0: Message Buffer 62 WORD_8B Register
/// WORD062: Message Buffer 62 WORD0 Register
pub mod MB13_64B_WORD14 {
    pub use super::MB1_64B_WORD14::DATA_BYTE_0;
    pub use super::MB1_64B_WORD14::DATA_BYTE_1;
    pub use super::MB1_64B_WORD14::DATA_BYTE_10;
    pub use super::MB1_64B_WORD14::DATA_BYTE_11;
    pub use super::MB1_64B_WORD14::DATA_BYTE_2;
    pub use super::MB1_64B_WORD14::DATA_BYTE_3;
    pub use super::MB1_64B_WORD14::DATA_BYTE_56;
    pub use super::MB1_64B_WORD14::DATA_BYTE_57;
    pub use super::MB1_64B_WORD14::DATA_BYTE_58;
    pub use super::MB1_64B_WORD14::DATA_BYTE_59;
    pub use super::MB1_64B_WORD14::DATA_BYTE_8;
    pub use super::MB1_64B_WORD14::DATA_BYTE_9;
}

/// MB13_64B_WORD15 and WORD162
/// MB13_64B_WORD15: MB13_64B_WORD15 and MB62_8B_WORD1
/// MB13_64B_WORD15: MB13_64B_WORD15 and MB41_16B_WORD3
/// MB13_64B_WORD15: Message Buffer 13 WORD_64B Register
/// MB41_16B_WORD3: Message Buffer 41 WORD_16B Register
/// MB62_8B_WORD1: Message Buffer 62 WORD_8B Register
/// WORD162: Message Buffer 62 WORD1 Register
pub mod MB13_64B_WORD15 {
    pub use super::MB1_64B_WORD15::DATA_BYTE_12;
    pub use super::MB1_64B_WORD15::DATA_BYTE_13;
    pub use super::MB1_64B_WORD15::DATA_BYTE_14;
    pub use super::MB1_64B_WORD15::DATA_BYTE_15;
    pub use super::MB1_64B_WORD15::DATA_BYTE_4;
    pub use super::MB1_64B_WORD15::DATA_BYTE_5;
    pub use super::MB1_64B_WORD15::DATA_BYTE_6;
    pub use super::MB1_64B_WORD15::DATA_BYTE_60;
    pub use super::MB1_64B_WORD15::DATA_BYTE_61;
    pub use super::MB1_64B_WORD15::DATA_BYTE_62;
    pub use super::MB1_64B_WORD15::DATA_BYTE_63;
    pub use super::MB1_64B_WORD15::DATA_BYTE_7;
}

/// CS63 and MB63_8B_CS
/// CS63: Message Buffer 63 CS Register
/// MB63_8B_CS: Message Buffer 63 CS Register
pub mod CS63 {
    pub use super::CS0::BRS;
    pub use super::CS0::CODE;
    pub use super::CS0::DLC;
    pub use super::CS0::EDL;
    pub use super::CS0::ESI;
    pub use super::CS0::IDE;
    pub use super::CS0::RTR;
    pub use super::CS0::SRR;
    pub use super::CS0::TIME_STAMP;
}

/// ID63 and MB63_8B_ID
/// ID63: Message Buffer 63 ID Register
/// MB63_8B_ID: Message Buffer 63 ID Register
pub mod ID63 {
    pub use super::ID0::EXT;
    pub use super::ID0::PRIO;
    pub use super::ID0::STD;
}

/// MB63_8B_WORD0 and WORD063
/// MB63_8B_WORD0: Message Buffer 63 WORD_8B Register
/// WORD063: Message Buffer 63 WORD0 Register
pub mod MB63_8B_WORD0 {
    pub use super::MB0::DATA_BYTE_0;
    pub use super::MB0::DATA_BYTE_1;
    pub use super::MB0::DATA_BYTE_2;
    pub use super::MB0::DATA_BYTE_3;
}

/// MB63_8B_WORD1 and WORD163
/// MB63_8B_WORD1: Message Buffer 63 WORD_8B Register
/// WORD163: Message Buffer 63 WORD1 Register
pub mod MB63_8B_WORD1 {
    pub use super::MB0_16B_WORD1::DATA_BYTE_4;
    pub use super::MB0_16B_WORD1::DATA_BYTE_5;
    pub use super::MB0_16B_WORD1::DATA_BYTE_6;
    pub use super::MB0_16B_WORD1::DATA_BYTE_7;
}

/// Rx Individual Mask Registers
pub mod RXIMR0 {

    /// Individual Mask Bits
    pub mod MI {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Rx Individual Mask Registers
pub mod RXIMR1 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR2 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR3 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR4 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR5 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR6 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR7 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR8 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR9 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR10 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR11 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR12 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR13 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR14 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR15 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR16 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR17 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR18 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR19 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR20 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR21 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR22 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR23 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR24 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR25 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR26 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR27 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR28 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR29 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR30 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR31 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR32 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR33 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR34 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR35 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR36 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR37 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR38 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR39 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR40 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR41 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR42 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR43 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR44 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR45 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR46 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR47 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR48 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR49 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR50 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR51 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR52 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR53 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR54 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR55 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR56 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR57 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR58 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR59 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR60 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR61 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR62 {
    pub use super::RXIMR0::MI;
}

/// Rx Individual Mask Registers
pub mod RXIMR63 {
    pub use super::RXIMR0::MI;
}

/// Enhanced CAN Bit Timing Prescalers
pub mod EPRS {

    /// Extended Nominal Prescaler Division Factor
    pub mod ENPRESDIV {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (10 bits: 0x3ff << 0)
        pub const mask: u32 = 0x3ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Extended Data Phase Prescaler Division Factor
    pub mod EDPRESDIV {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (10 bits: 0x3ff << 16)
        pub const mask: u32 = 0x3ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Enhanced Nominal CAN Bit Timing
pub mod ENCBT {

    /// Nominal Time Segment 1
    pub mod NTSEG1 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Nominal Time Segment 2
    pub mod NTSEG2 {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (7 bits: 0x7f << 12)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Nominal Resynchronization Jump Width
    pub mod NRJW {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (7 bits: 0x7f << 22)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Enhanced Data Phase CAN bit Timing
pub mod EDCBT {

    /// Data Phase Segment 1
    pub mod DTSEG1 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data Phase Time Segment 2
    pub mod DTSEG2 {
        /// Offset (12 bits)
        pub const offset: u32 = 12;
        /// Mask (4 bits: 0b1111 << 12)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Data Phase Resynchronization Jump Width
    pub mod DRJW {
        /// Offset (22 bits)
        pub const offset: u32 = 22;
        /// Mask (4 bits: 0b1111 << 22)
        pub const mask: u32 = 0b1111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Enhanced Transceiver Delay Compensation
pub mod ETDC {

    /// Enhanced Transceiver Delay Compensation Value
    pub mod ETDCVAL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (8 bits: 0xff << 0)
        pub const mask: u32 = 0xff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Enhanced Transceiver Delay Compensation Offset
    pub mod ETDCOFF {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (7 bits: 0x7f << 16)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Transceiver Delay Measurement Disable
    pub mod TDMDIS {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: TDC measurement is enabled
            pub const TDMDIS_0: u32 = 0b0;

            /// 0b1: TDC measurement is disabled
            pub const TDMDIS_1: u32 = 0b1;
        }
    }
}

/// CAN FD Control Register
pub mod FDCTRL {

    /// Transceiver Delay Compensation Value
    pub mod TDCVAL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (6 bits: 0x3f << 0)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Transceiver Delay Compensation Offset
    pub mod TDCOFF {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (5 bits: 0b11111 << 8)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Transceiver Delay Compensation Fail
    pub mod TDCFAIL {
        /// Offset (14 bits)
        pub const offset: u32 = 14;
        /// Mask (1 bit: 1 << 14)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Measured loop delay is in range.
            pub const TDCFAIL_0: u32 = 0b0;

            /// 0b1: Measured loop delay is out of range.
            pub const TDCFAIL_1: u32 = 0b1;
        }
    }

    /// Transceiver Delay Compensation Enable
    pub mod TDCEN {
        /// Offset (15 bits)
        pub const offset: u32 = 15;
        /// Mask (1 bit: 1 << 15)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: TDC is disabled
            pub const TDCEN_0: u32 = 0b0;

            /// 0b1: TDC is enabled
            pub const TDCEN_1: u32 = 0b1;
        }
    }

    /// Message Buffer Data Size for Region 0
    pub mod MBDSR0 {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (2 bits: 0b11 << 16)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Selects 8 bytes per Message Buffer.
            pub const MBDSR0_0: u32 = 0b00;

            /// 0b01: Selects 16 bytes per Message Buffer.
            pub const MBDSR0_1: u32 = 0b01;

            /// 0b10: Selects 32 bytes per Message Buffer.
            pub const MBDSR0_2: u32 = 0b10;

            /// 0b11: Selects 64 bytes per Message Buffer.
            pub const MBDSR0_3: u32 = 0b11;
        }
    }

    /// Message Buffer Data Size for Region 1
    pub mod MBDSR1 {
        /// Offset (19 bits)
        pub const offset: u32 = 19;
        /// Mask (2 bits: 0b11 << 19)
        pub const mask: u32 = 0b11 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b00: Selects 8 bytes per Message Buffer.
            pub const MBDSR1_0: u32 = 0b00;

            /// 0b01: Selects 16 bytes per Message Buffer.
            pub const MBDSR1_1: u32 = 0b01;

            /// 0b10: Selects 32 bytes per Message Buffer.
            pub const MBDSR1_2: u32 = 0b10;

            /// 0b11: Selects 64 bytes per Message Buffer.
            pub const MBDSR1_3: u32 = 0b11;
        }
    }

    /// Bit Rate Switch Enable
    pub mod FDRATE {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Transmit a frame in nominal rate. The BRS bit in the Tx MB has no effect.
            pub const FDRATE_0: u32 = 0b0;

            /// 0b1: Transmit a frame with bit rate switching if the BRS bit in the Tx MB is recessive.
            pub const FDRATE_1: u32 = 0b1;
        }
    }
}

/// CAN FD Bit Timing Register
pub mod FDCBT {

    /// Fast Phase Segment 2
    pub mod FPSEG2 {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (3 bits: 0b111 << 0)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Phase Segment 1
    pub mod FPSEG1 {
        /// Offset (5 bits)
        pub const offset: u32 = 5;
        /// Mask (3 bits: 0b111 << 5)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Propagation Segment
    pub mod FPROPSEG {
        /// Offset (10 bits)
        pub const offset: u32 = 10;
        /// Mask (5 bits: 0b11111 << 10)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Resync Jump Width
    pub mod FRJW {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (3 bits: 0b111 << 16)
        pub const mask: u32 = 0b111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Fast Prescaler Division Factor
    pub mod FPRESDIV {
        /// Offset (20 bits)
        pub const offset: u32 = 20;
        /// Mask (10 bits: 0x3ff << 20)
        pub const mask: u32 = 0x3ff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// CAN FD CRC Register
pub mod FDCRC {

    /// Extended Transmitted CRC value
    pub mod FD_TXCRC {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (21 bits: 0x1fffff << 0)
        pub const mask: u32 = 0x1fffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// CRC Mailbox Number for FD_TXCRC
    pub mod FD_MBCRC {
        /// Offset (24 bits)
        pub const offset: u32 = 24;
        /// Mask (7 bits: 0x7f << 24)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Enhanced Rx FIFO Control Register
pub mod ERFCR {

    /// Enhanced Rx FIFO Watermark
    pub mod ERFWM {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (5 bits: 0b11111 << 0)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Number of Enhanced Rx FIFO Filter Elements
    pub mod NFE {
        /// Offset (8 bits)
        pub const offset: u32 = 8;
        /// Mask (6 bits: 0x3f << 8)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Number of Extended ID Filter Elements
    pub mod NEXIF {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (7 bits: 0x7f << 16)
        pub const mask: u32 = 0x7f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// DMA Last Word
    pub mod DMALW {
        /// Offset (26 bits)
        pub const offset: u32 = 26;
        /// Mask (5 bits: 0b11111 << 26)
        pub const mask: u32 = 0b11111 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Enhanced Rx FIFO enable
    pub mod ERFEN {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enhanced Rx FIFO is disabled
            pub const ERFEN_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO is enabled
            pub const ERFEN_1: u32 = 0b1;
        }
    }
}

/// Enhanced Rx FIFO Interrupt Enable register
pub mod ERFIER {

    /// Enhanced Rx FIFO Data Available Interrupt Enable
    pub mod ERFDAIE {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (1 bit: 1 << 28)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enhanced Rx FIFO Data Available Interrupt is disabled
            pub const ERFDAIE_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO Data Available Interrupt is enabled
            pub const ERFDAIE_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Watermark Indication Interrupt Enable
    pub mod ERFWMIIE {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enhanced Rx FIFO Watermark Interrupt is disabled
            pub const ERFWMIIE_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO Watermark Interrupt is enabled
            pub const ERFWMIIE_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Overflow Interrupt Enable
    pub mod ERFOVFIE {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enhanced Rx FIFO Overflow is disabled
            pub const ERFOVFIE_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO Overflow is enabled
            pub const ERFOVFIE_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Underflow Interrupt Enable
    pub mod ERFUFWIE {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enhanced Rx FIFO Underflow interrupt is disabled
            pub const ERFUFWIE_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO Underflow interrupt is enabled
            pub const ERFUFWIE_1: u32 = 0b1;
        }
    }
}

/// Enhanced Rx FIFO Status Register
pub mod ERFSR {

    /// Enhanced Rx FIFO Elements
    pub mod ERFEL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (6 bits: 0x3f << 0)
        pub const mask: u32 = 0x3f << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }

    /// Enhanced Rx FIFO full
    pub mod ERFF {
        /// Offset (16 bits)
        pub const offset: u32 = 16;
        /// Mask (1 bit: 1 << 16)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enhanced Rx FIFO is not full
            pub const ERFF_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO is full
            pub const ERFF_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO empty
    pub mod ERFE {
        /// Offset (17 bits)
        pub const offset: u32 = 17;
        /// Mask (1 bit: 1 << 17)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: Enhanced Rx FIFO is not empty
            pub const ERFE_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO is empty
            pub const ERFE_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Clear
    pub mod ERFCLR {
        /// Offset (27 bits)
        pub const offset: u32 = 27;
        /// Mask (1 bit: 1 << 27)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No effect
            pub const ERFCLR_0: u32 = 0b0;

            /// 0b1: Clear Enhanced Rx FIFO content
            pub const ERFCLR_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Data Available
    pub mod ERFDA {
        /// Offset (28 bits)
        pub const offset: u32 = 28;
        /// Mask (1 bit: 1 << 28)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence
            pub const ERFDA_0: u32 = 0b0;

            /// 0b1: There is at least one message stored in Enhanced Rx FIFO
            pub const ERFDA_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Watermark Indication
    pub mod ERFWMI {
        /// Offset (29 bits)
        pub const offset: u32 = 29;
        /// Mask (1 bit: 1 << 29)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence
            pub const ERFWMI_0: u32 = 0b0;

            /// 0b1: The number of messages in FIFO is greater than the watermark
            pub const ERFWMI_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Overflow
    pub mod ERFOVF {
        /// Offset (30 bits)
        pub const offset: u32 = 30;
        /// Mask (1 bit: 1 << 30)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence
            pub const ERFOVF_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO overflow
            pub const ERFOVF_1: u32 = 0b1;
        }
    }

    /// Enhanced Rx FIFO Underflow
    pub mod ERFUFW {
        /// Offset (31 bits)
        pub const offset: u32 = 31;
        /// Mask (1 bit: 1 << 31)
        pub const mask: u32 = 1 << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values
        pub mod RW {

            /// 0b0: No such occurrence
            pub const ERFUFW_0: u32 = 0b0;

            /// 0b1: Enhanced Rx FIFO underflow
            pub const ERFUFW_1: u32 = 0b1;
        }
    }
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP0 {

    /// High Resolution Time Stamp
    pub mod TS {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP1 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP2 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP3 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP4 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP5 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP6 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP7 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP8 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP9 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP10 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP11 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP12 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP13 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP14 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP15 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP16 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP17 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP18 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP19 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP20 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP21 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP22 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP23 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP24 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP25 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP26 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP27 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP28 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP29 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP30 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP31 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP32 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP33 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP34 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP35 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP36 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP37 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP38 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP39 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP40 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP41 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP42 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP43 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP44 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP45 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP46 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP47 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP48 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP49 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP50 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP51 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP52 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP53 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP54 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP55 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP56 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP57 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP58 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP59 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP60 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP61 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP62 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// High Resolution Time Stamp
pub mod HR_TIME_STAMP63 {
    pub use super::HR_TIME_STAMP0::TS;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL0 {

    /// Filter Element Bits
    pub mod FEL {
        /// Offset (0 bits)
        pub const offset: u32 = 0;
        /// Mask (32 bits: 0xffffffff << 0)
        pub const mask: u32 = 0xffffffff << offset;
        /// Read-only values (empty)
        pub mod R {}
        /// Write-only values (empty)
        pub mod W {}
        /// Read-write values (empty)
        pub mod RW {}
    }
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL1 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL2 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL3 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL4 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL5 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL6 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL7 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL8 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL9 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL10 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL11 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL12 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL13 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL14 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL15 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL16 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL17 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL18 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL19 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL20 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL21 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL22 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL23 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL24 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL25 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL26 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL27 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL28 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL29 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL30 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL31 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL32 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL33 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL34 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL35 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL36 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL37 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL38 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL39 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL40 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL41 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL42 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL43 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL44 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL45 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL46 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL47 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL48 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL49 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL50 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL51 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL52 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL53 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL54 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL55 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL56 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL57 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL58 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL59 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL60 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL61 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL62 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL63 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL64 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL65 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL66 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL67 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL68 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL69 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL70 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL71 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL72 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL73 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL74 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL75 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL76 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL77 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL78 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL79 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL80 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL81 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL82 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL83 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL84 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL85 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL86 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL87 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL88 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL89 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL90 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL91 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL92 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL93 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL94 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL95 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL96 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL97 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL98 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL99 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL100 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL101 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL102 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL103 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL104 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL105 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL106 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL107 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL108 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL109 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL110 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL111 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL112 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL113 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL114 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL115 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL116 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL117 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL118 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL119 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL120 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL121 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL122 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL123 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL124 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL125 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL126 {
    pub use super::ERFFEL0::FEL;
}

/// Enhanced Rx FIFO Filter Element
pub mod ERFFEL127 {
    pub use super::ERFFEL0::FEL;
}
#[repr(C)]
pub struct RegisterBlock {
    /// Module Configuration Register
    pub MCR: RWRegister<u32>,

    /// Control 1 register
    pub CTRL1: RWRegister<u32>,

    /// Free Running Timer
    pub TIMER: RWRegister<u32>,

    _reserved1: [u32; 1],

    /// Rx Mailboxes Global Mask Register
    pub RXMGMASK: RWRegister<u32>,

    /// Rx 14 Mask register
    pub RX14MASK: RWRegister<u32>,

    /// Rx 15 Mask register
    pub RX15MASK: RWRegister<u32>,

    /// Error Counter
    pub ECR: RWRegister<u32>,

    /// Error and Status 1 register
    pub ESR1: RWRegister<u32>,

    /// Interrupt Masks 2 register
    pub IMASK2: RWRegister<u32>,

    /// Interrupt Masks 1 register
    pub IMASK1: RWRegister<u32>,

    /// Interrupt Flags 2 register
    pub IFLAG2: RWRegister<u32>,

    /// Interrupt Flags 1 register
    pub IFLAG1: RWRegister<u32>,

    /// Control 2 register
    pub CTRL2: RWRegister<u32>,

    /// Error and Status 2 register
    pub ESR2: RORegister<u32>,

    _reserved2: [u32; 2],

    /// CRC Register
    pub CRCR: RORegister<u32>,

    /// Legacy Rx FIFO Global Mask register
    pub RXFGMASK: RWRegister<u32>,

    /// Legacy Rx FIFO Information Register
    pub RXFIR: RORegister<u32>,

    /// CAN Bit Timing Register
    pub CBT: RWRegister<u32>,

    _reserved3: [u32; 11],

    /// CS0 and MB0_8B_CS
    /// CS0: CS0 and MB0_64B_CS
    /// CS0: CS0 and MB0_32B_CS
    /// CS0: CS0 and MB0_16B_CS
    /// CS0: Message Buffer 0 CS Register
    /// MB0_16B_CS: Message Buffer 0 CS Register
    /// MB0_32B_CS: Message Buffer 0 CS Register
    /// MB0_64B_CS: Message Buffer 0 CS Register
    /// MB0_8B_CS: Message Buffer 0 CS Register
    pub CS0: RWRegister<u32>,

    /// ID0 and MB0_8B_ID
    /// ID0: ID0 and MB0_64B_ID
    /// ID0: ID0 and MB0_32B_ID
    /// ID0: ID0 and MB0_16B_ID
    /// ID0: Message Buffer 0 ID Register
    /// MB0_16B_ID: Message Buffer 0 ID Register
    /// MB0_32B_ID: Message Buffer 0 ID Register
    /// MB0_64B_ID: Message Buffer 0 ID Register
    /// MB0_8B_ID: Message Buffer 0 ID Register
    pub ID0: RWRegister<u32>,

    /// MB0 and WORD00
    /// MB0: MB0 and MB0_8B_WORD0
    /// MB0: MB0 and MB0_64B_WORD0
    /// MB0: MB0_16B_WORD0 and MB0_32B_WORD0
    /// MB0_16B_WORD0: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD0: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD0: Message Buffer 0 WORD_64B Register
    /// MB0_8B_WORD0: Message Buffer 0 WORD_8B Register
    /// WORD00: Message Buffer 0 WORD0 Register
    pub MB0: RWRegister<u32>,

    /// MB0_16B_WORD1 and WORD10
    /// MB0_16B_WORD1: MB0_16B_WORD1 and MB0_8B_WORD1
    /// MB0_16B_WORD1: MB0_16B_WORD1 and MB0_64B_WORD1
    /// MB0_16B_WORD1: MB0_16B_WORD1 and MB0_32B_WORD1
    /// MB0_16B_WORD1: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD1: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD1: Message Buffer 0 WORD_64B Register
    /// MB0_8B_WORD1: Message Buffer 0 WORD_8B Register
    /// WORD10: Message Buffer 0 WORD1 Register
    pub MB0_16B_WORD1: RWRegister<u32>,

    /// CS1 and MB1_8B_CS
    /// CS1: CS1 and MB0_64B_WORD2
    /// CS1: CS1 and MB0_32B_WORD2
    /// CS1: CS1 and MB0_16B_WORD2
    /// CS1: Message Buffer 1 CS Register
    /// MB0_16B_WORD2: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD2: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD2: Message Buffer 0 WORD_64B Register
    /// MB1_8B_CS: Message Buffer 1 CS Register
    pub CS1: RWRegister<u32>,

    /// ID1 and MB1_8B_ID
    /// ID1: ID1 and MB0_64B_WORD3
    /// ID1: ID1 and MB0_32B_WORD3
    /// ID1: ID1 and MB0_16B_WORD3
    /// ID1: Message Buffer 1 ID Register
    /// MB0_16B_WORD3: Message Buffer 0 WORD_16B Register
    /// MB0_32B_WORD3: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD3: Message Buffer 0 WORD_64B Register
    /// MB1_8B_ID: Message Buffer 1 ID Register
    pub ID1: RWRegister<u32>,

    /// MB and WORD01
    /// MB: MB and MB1_8B_WORD0
    /// MB: MB0_32B_WORD4 and MB1_16B_CS
    /// MB0_32B_WORD4: MB0_32B_WORD4 and MB0_64B_WORD4
    /// MB0_32B_WORD4: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD4: Message Buffer 0 WORD_64B Register
    /// MB1_16B_CS: Message Buffer 1 CS Register
    /// MB1_8B_WORD0: Message Buffer 1 WORD_8B Register
    /// WORD01: Message Buffer 1 WORD0 Register
    pub MB: RWRegister<u32>,

    /// MB0_32B_WORD5 and WORD11
    /// MB0_32B_WORD5: MB0_32B_WORD5 and MB1_8B_WORD1
    /// MB0_32B_WORD5: MB0_32B_WORD5 and MB1_16B_ID
    /// MB0_32B_WORD5: MB0_32B_WORD5 and MB0_64B_WORD5
    /// MB0_32B_WORD5: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD5: Message Buffer 0 WORD_64B Register
    /// MB1_16B_ID: Message Buffer 1 ID Register
    /// MB1_8B_WORD1: Message Buffer 1 WORD_8B Register
    /// WORD11: Message Buffer 1 WORD1 Register
    pub MB0_32B_WORD5: RWRegister<u32>,

    /// CS2 and MB2_8B_CS
    /// CS2: CS2 and MB1_16B_WORD0
    /// CS2: CS2 and MB0_64B_WORD6
    /// CS2: CS2 and MB0_32B_WORD6
    /// CS2: Message Buffer 2 CS Register
    /// MB0_32B_WORD6: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD6: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD0: Message Buffer 1 WORD_16B Register
    /// MB2_8B_CS: Message Buffer 2 CS Register
    pub CS2: RWRegister<u32>,

    /// ID2 and MB2_8B_ID
    /// ID2: ID2 and MB1_16B_WORD1
    /// ID2: ID2 and MB0_64B_WORD7
    /// ID2: ID2 and MB0_32B_WORD7
    /// ID2: Message Buffer 2 ID Register
    /// MB0_32B_WORD7: Message Buffer 0 WORD_32B Register
    /// MB0_64B_WORD7: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD1: Message Buffer 1 WORD_16B Register
    /// MB2_8B_ID: Message Buffer 2 ID Register
    pub ID2: RWRegister<u32>,

    /// MB0_64B_WORD8 and WORD02
    /// MB0_64B_WORD8: MB0_64B_WORD8 and MB2_8B_WORD0
    /// MB0_64B_WORD8: MB0_64B_WORD8 and MB1_32B_CS
    /// MB0_64B_WORD8: MB0_64B_WORD8 and MB1_16B_WORD2
    /// MB0_64B_WORD8: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD2: Message Buffer 1 WORD_16B Register
    /// MB1_32B_CS: Message Buffer 1 CS Register
    /// MB2_8B_WORD0: Message Buffer 2 WORD_8B Register
    /// WORD02: Message Buffer 2 WORD0 Register
    pub MB0_64B_WORD8: RWRegister<u32>,

    /// MB0_64B_WORD9 and WORD12
    /// MB0_64B_WORD9: MB0_64B_WORD9 and MB2_8B_WORD1
    /// MB0_64B_WORD9: MB0_64B_WORD9 and MB1_32B_ID
    /// MB0_64B_WORD9: MB0_64B_WORD9 and MB1_16B_WORD3
    /// MB0_64B_WORD9: Message Buffer 0 WORD_64B Register
    /// MB1_16B_WORD3: Message Buffer 1 WORD_16B Register
    /// MB1_32B_ID: Message Buffer 1 ID Register
    /// MB2_8B_WORD1: Message Buffer 2 WORD_8B Register
    /// WORD12: Message Buffer 2 WORD1 Register
    pub MB0_64B_WORD9: RWRegister<u32>,

    /// CS3 and MB3_8B_CS
    /// CS3: CS3 and MB2_16B_CS
    /// CS3: CS3 and MB1_32B_WORD0
    /// CS3: CS3 and MB0_64B_WORD10
    /// CS3: Message Buffer 3 CS Register
    /// MB0_64B_WORD10: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD0: Message Buffer 1 WORD_32B Register
    /// MB2_16B_CS: Message Buffer 2 CS Register
    /// MB3_8B_CS: Message Buffer 3 CS Register
    pub CS3: RWRegister<u32>,

    /// ID3 and MB3_8B_ID
    /// ID3: ID3 and MB2_16B_ID
    /// ID3: ID3 and MB1_32B_WORD1
    /// ID3: ID3 and MB0_64B_WORD11
    /// ID3: Message Buffer 3 ID Register
    /// MB0_64B_WORD11: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD1: Message Buffer 1 WORD_32B Register
    /// MB2_16B_ID: Message Buffer 2 ID Register
    /// MB3_8B_ID: Message Buffer 3 ID Register
    pub ID3: RWRegister<u32>,

    /// MB0_64B_WORD12 and WORD03
    /// MB0_64B_WORD12: MB0_64B_WORD12 and MB3_8B_WORD0
    /// MB0_64B_WORD12: MB0_64B_WORD12 and MB2_16B_WORD0
    /// MB0_64B_WORD12: MB0_64B_WORD12 and MB1_32B_WORD2
    /// MB0_64B_WORD12: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD2: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD0: Message Buffer 2 WORD_16B Register
    /// MB3_8B_WORD0: Message Buffer 3 WORD_8B Register
    /// WORD03: Message Buffer 3 WORD0 Register
    pub MB0_64B_WORD12: RWRegister<u32>,

    /// MB0_64B_WORD13 and WORD13
    /// MB0_64B_WORD13: MB0_64B_WORD13 and MB3_8B_WORD1
    /// MB0_64B_WORD13: MB0_64B_WORD13 and MB2_16B_WORD1
    /// MB0_64B_WORD13: MB0_64B_WORD13 and MB1_32B_WORD3
    /// MB0_64B_WORD13: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD3: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD1: Message Buffer 2 WORD_16B Register
    /// MB3_8B_WORD1: Message Buffer 3 WORD_8B Register
    /// WORD13: Message Buffer 3 WORD1 Register
    pub MB0_64B_WORD13: RWRegister<u32>,

    /// CS4 and MB4_8B_CS
    /// CS4: CS4 and MB2_16B_WORD2
    /// CS4: CS4 and MB1_32B_WORD4
    /// CS4: CS4 and MB0_64B_WORD14
    /// CS4: Message Buffer 4 CS Register
    /// MB0_64B_WORD14: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD4: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD2: Message Buffer 2 WORD_16B Register
    /// MB4_8B_CS: Message Buffer 4 CS Register
    pub CS4: RWRegister<u32>,

    /// ID4 and MB4_8B_ID
    /// ID4: ID4 and MB2_16B_WORD3
    /// ID4: ID4 and MB1_32B_WORD5
    /// ID4: ID4 and MB0_64B_WORD15
    /// ID4: Message Buffer 4 ID Register
    /// MB0_64B_WORD15: Message Buffer 0 WORD_64B Register
    /// MB1_32B_WORD5: Message Buffer 1 WORD_32B Register
    /// MB2_16B_WORD3: Message Buffer 2 WORD_16B Register
    /// MB4_8B_ID: Message Buffer 4 ID Register
    pub ID4: RWRegister<u32>,

    /// MB1 and WORD04
    /// MB1: MB1 and MB4_8B_WORD0
    /// MB1: MB1 and MB3_16B_CS
    /// MB1: MB1_32B_WORD6 and MB1_64B_CS
    /// MB1_32B_WORD6: Message Buffer 1 WORD_32B Register
    /// MB1_64B_CS: Message Buffer 1 CS Register
    /// MB3_16B_CS: Message Buffer 3 CS Register
    /// MB4_8B_WORD0: Message Buffer 4 WORD_8B Register
    /// WORD04: Message Buffer 4 WORD0 Register
    pub MB1: RWRegister<u32>,

    /// MB1_32B_WORD7 and WORD14
    /// MB1_32B_WORD7: MB1_32B_WORD7 and MB4_8B_WORD1
    /// MB1_32B_WORD7: MB1_32B_WORD7 and MB3_16B_ID
    /// MB1_32B_WORD7: MB1_32B_WORD7 and MB1_64B_ID
    /// MB1_32B_WORD7: Message Buffer 1 WORD_32B Register
    /// MB1_64B_ID: Message Buffer 1 ID Register
    /// MB3_16B_ID: Message Buffer 3 ID Register
    /// MB4_8B_WORD1: Message Buffer 4 WORD_8B Register
    /// WORD14: Message Buffer 4 WORD1 Register
    pub MB1_32B_WORD7: RWRegister<u32>,

    /// CS5 and MB5_8B_CS
    /// CS5: CS5 and MB3_16B_WORD0
    /// CS5: CS5 and MB2_32B_CS
    /// CS5: CS5 and MB1_64B_WORD0
    /// CS5: Message Buffer 5 CS Register
    /// MB1_64B_WORD0: Message Buffer 1 WORD_64B Register
    /// MB2_32B_CS: Message Buffer 2 CS Register
    /// MB3_16B_WORD0: Message Buffer 3 WORD_16B Register
    /// MB5_8B_CS: Message Buffer 5 CS Register
    pub CS5: RWRegister<u32>,

    /// ID5 and MB5_8B_ID
    /// ID5: ID5 and MB3_16B_WORD1
    /// ID5: ID5 and MB2_32B_ID
    /// ID5: ID5 and MB1_64B_WORD1
    /// ID5: Message Buffer 5 ID Register
    /// MB1_64B_WORD1: Message Buffer 1 WORD_64B Register
    /// MB2_32B_ID: Message Buffer 2 ID Register
    /// MB3_16B_WORD1: Message Buffer 3 WORD_16B Register
    /// MB5_8B_ID: Message Buffer 5 ID Register
    pub ID5: RWRegister<u32>,

    /// MB1_64B_WORD2 and WORD05
    /// MB1_64B_WORD2: MB1_64B_WORD2 and MB5_8B_WORD0
    /// MB1_64B_WORD2: MB1_64B_WORD2 and MB3_16B_WORD2
    /// MB1_64B_WORD2: MB1_64B_WORD2 and MB2_32B_WORD0
    /// MB1_64B_WORD2: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD0: Message Buffer 2 WORD_32B Register
    /// MB3_16B_WORD2: Message Buffer 3 WORD_16B Register
    /// MB5_8B_WORD0: Message Buffer 5 WORD_8B Register
    /// WORD05: Message Buffer 5 WORD0 Register
    pub MB1_64B_WORD2: RWRegister<u32>,

    /// MB1_64B_WORD3 and WORD15
    /// MB1_64B_WORD3: MB1_64B_WORD3 and MB5_8B_WORD1
    /// MB1_64B_WORD3: MB1_64B_WORD3 and MB3_16B_WORD3
    /// MB1_64B_WORD3: MB1_64B_WORD3 and MB2_32B_WORD1
    /// MB1_64B_WORD3: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD1: Message Buffer 2 WORD_32B Register
    /// MB3_16B_WORD3: Message Buffer 3 WORD_16B Register
    /// MB5_8B_WORD1: Message Buffer 5 WORD_8B Register
    /// WORD15: Message Buffer 5 WORD1 Register
    pub MB1_64B_WORD3: RWRegister<u32>,

    /// CS6 and MB6_8B_CS
    /// CS6: CS6 and MB4_16B_CS
    /// CS6: CS6 and MB2_32B_WORD2
    /// CS6: CS6 and MB1_64B_WORD4
    /// CS6: Message Buffer 6 CS Register
    /// MB1_64B_WORD4: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD2: Message Buffer 2 WORD_32B Register
    /// MB4_16B_CS: Message Buffer 4 CS Register
    /// MB6_8B_CS: Message Buffer 6 CS Register
    pub CS6: RWRegister<u32>,

    /// ID6 and MB6_8B_ID
    /// ID6: ID6 and MB4_16B_ID
    /// ID6: ID6 and MB2_32B_WORD3
    /// ID6: ID6 and MB1_64B_WORD5
    /// ID6: Message Buffer 6 ID Register
    /// MB1_64B_WORD5: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD3: Message Buffer 2 WORD_32B Register
    /// MB4_16B_ID: Message Buffer 4 ID Register
    /// MB6_8B_ID: Message Buffer 6 ID Register
    pub ID6: RWRegister<u32>,

    /// MB1_64B_WORD6 and WORD06
    /// MB1_64B_WORD6: MB1_64B_WORD6 and MB6_8B_WORD0
    /// MB1_64B_WORD6: MB1_64B_WORD6 and MB4_16B_WORD0
    /// MB1_64B_WORD6: MB1_64B_WORD6 and MB2_32B_WORD4
    /// MB1_64B_WORD6: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD4: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD0: Message Buffer 4 WORD_16B Register
    /// MB6_8B_WORD0: Message Buffer 6 WORD_8B Register
    /// WORD06: Message Buffer 6 WORD0 Register
    pub MB1_64B_WORD6: RWRegister<u32>,

    /// MB1_64B_WORD7 and WORD16
    /// MB1_64B_WORD7: MB1_64B_WORD7 and MB6_8B_WORD1
    /// MB1_64B_WORD7: MB1_64B_WORD7 and MB4_16B_WORD1
    /// MB1_64B_WORD7: MB1_64B_WORD7 and MB2_32B_WORD5
    /// MB1_64B_WORD7: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD5: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD1: Message Buffer 4 WORD_16B Register
    /// MB6_8B_WORD1: Message Buffer 6 WORD_8B Register
    /// WORD16: Message Buffer 6 WORD1 Register
    pub MB1_64B_WORD7: RWRegister<u32>,

    /// CS7 and MB7_8B_CS
    /// CS7: CS7 and MB4_16B_WORD2
    /// CS7: CS7 and MB2_32B_WORD6
    /// CS7: CS7 and MB1_64B_WORD8
    /// CS7: Message Buffer 7 CS Register
    /// MB1_64B_WORD8: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD6: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD2: Message Buffer 4 WORD_16B Register
    /// MB7_8B_CS: Message Buffer 7 CS Register
    pub CS7: RWRegister<u32>,

    /// ID7 and MB7_8B_ID
    /// ID7: ID7 and MB4_16B_WORD3
    /// ID7: ID7 and MB2_32B_WORD7
    /// ID7: ID7 and MB1_64B_WORD9
    /// ID7: Message Buffer 7 ID Register
    /// MB1_64B_WORD9: Message Buffer 1 WORD_64B Register
    /// MB2_32B_WORD7: Message Buffer 2 WORD_32B Register
    /// MB4_16B_WORD3: Message Buffer 4 WORD_16B Register
    /// MB7_8B_ID: Message Buffer 7 ID Register
    pub ID7: RWRegister<u32>,

    /// MB1_64B_WORD10 and WORD07
    /// MB1_64B_WORD10: MB1_64B_WORD10 and MB7_8B_WORD0
    /// MB1_64B_WORD10: MB1_64B_WORD10 and MB5_16B_CS
    /// MB1_64B_WORD10: MB1_64B_WORD10 and MB3_32B_CS
    /// MB1_64B_WORD10: Message Buffer 1 WORD_64B Register
    /// MB3_32B_CS: Message Buffer 3 CS Register
    /// MB5_16B_CS: Message Buffer 5 CS Register
    /// MB7_8B_WORD0: Message Buffer 7 WORD_8B Register
    /// WORD07: Message Buffer 7 WORD0 Register
    pub MB1_64B_WORD10: RWRegister<u32>,

    /// MB1_64B_WORD11 and WORD17
    /// MB1_64B_WORD11: MB1_64B_WORD11 and MB7_8B_WORD1
    /// MB1_64B_WORD11: MB1_64B_WORD11 and MB5_16B_ID
    /// MB1_64B_WORD11: MB1_64B_WORD11 and MB3_32B_ID
    /// MB1_64B_WORD11: Message Buffer 1 WORD_64B Register
    /// MB3_32B_ID: Message Buffer 3 ID Register
    /// MB5_16B_ID: Message Buffer 5 ID Register
    /// MB7_8B_WORD1: Message Buffer 7 WORD_8B Register
    /// WORD17: Message Buffer 7 WORD1 Register
    pub MB1_64B_WORD11: RWRegister<u32>,

    /// CS8 and MB8_8B_CS
    /// CS8: CS8 and MB5_16B_WORD0
    /// CS8: CS8 and MB3_32B_WORD0
    /// CS8: CS8 and MB1_64B_WORD12
    /// CS8: Message Buffer 8 CS Register
    /// MB1_64B_WORD12: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD0: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD0: Message Buffer 5 WORD_16B Register
    /// MB8_8B_CS: Message Buffer 8 CS Register
    pub CS8: RWRegister<u32>,

    /// ID8 and MB8_8B_ID
    /// ID8: ID8 and MB5_16B_WORD1
    /// ID8: ID8 and MB3_32B_WORD1
    /// ID8: ID8 and MB1_64B_WORD13
    /// ID8: Message Buffer 8 ID Register
    /// MB1_64B_WORD13: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD1: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD1: Message Buffer 5 WORD_16B Register
    /// MB8_8B_ID: Message Buffer 8 ID Register
    pub ID8: RWRegister<u32>,

    /// MB1_64B_WORD14 and WORD08
    /// MB1_64B_WORD14: MB1_64B_WORD14 and MB8_8B_WORD0
    /// MB1_64B_WORD14: MB1_64B_WORD14 and MB5_16B_WORD2
    /// MB1_64B_WORD14: MB1_64B_WORD14 and MB3_32B_WORD2
    /// MB1_64B_WORD14: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD2: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD2: Message Buffer 5 WORD_16B Register
    /// MB8_8B_WORD0: Message Buffer 8 WORD_8B Register
    /// WORD08: Message Buffer 8 WORD0 Register
    pub MB1_64B_WORD14: RWRegister<u32>,

    /// MB1_64B_WORD15 and WORD18
    /// MB1_64B_WORD15: MB1_64B_WORD15 and MB8_8B_WORD1
    /// MB1_64B_WORD15: MB1_64B_WORD15 and MB5_16B_WORD3
    /// MB1_64B_WORD15: MB1_64B_WORD15 and MB3_32B_WORD3
    /// MB1_64B_WORD15: Message Buffer 1 WORD_64B Register
    /// MB3_32B_WORD3: Message Buffer 3 WORD_32B Register
    /// MB5_16B_WORD3: Message Buffer 5 WORD_16B Register
    /// MB8_8B_WORD1: Message Buffer 8 WORD_8B Register
    /// WORD18: Message Buffer 8 WORD1 Register
    pub MB1_64B_WORD15: RWRegister<u32>,

    /// CS9 and MB9_8B_CS
    /// CS9: CS9 and MB6_16B_CS
    /// CS9: CS9 and MB3_32B_WORD4
    /// CS9: CS9 and MB2_64B_CS
    /// CS9: Message Buffer 9 CS Register
    /// MB2_64B_CS: Message Buffer 2 CS Register
    /// MB3_32B_WORD4: Message Buffer 3 WORD_32B Register
    /// MB6_16B_CS: Message Buffer 6 CS Register
    /// MB9_8B_CS: Message Buffer 9 CS Register
    pub CS9: RWRegister<u32>,

    /// ID9 and MB9_8B_ID
    /// ID9: ID9 and MB6_16B_ID
    /// ID9: ID9 and MB3_32B_WORD5
    /// ID9: ID9 and MB2_64B_ID
    /// ID9: Message Buffer 9 ID Register
    /// MB2_64B_ID: Message Buffer 2 ID Register
    /// MB3_32B_WORD5: Message Buffer 3 WORD_32B Register
    /// MB6_16B_ID: Message Buffer 6 ID Register
    /// MB9_8B_ID: Message Buffer 9 ID Register
    pub ID9: RWRegister<u32>,

    /// MB2_64B_WORD0 and WORD09
    /// MB2_64B_WORD0: MB2_64B_WORD0 and MB9_8B_WORD0
    /// MB2_64B_WORD0: MB2_64B_WORD0 and MB6_16B_WORD0
    /// MB2_64B_WORD0: MB2_64B_WORD0 and MB3_32B_WORD6
    /// MB2_64B_WORD0: Message Buffer 2 WORD_64B Register
    /// MB3_32B_WORD6: Message Buffer 3 WORD_32B Register
    /// MB6_16B_WORD0: Message Buffer 6 WORD_16B Register
    /// MB9_8B_WORD0: Message Buffer 9 WORD_8B Register
    /// WORD09: Message Buffer 9 WORD0 Register
    pub MB2_64B_WORD0: RWRegister<u32>,

    /// MB2_64B_WORD1 and WORD19
    /// MB2_64B_WORD1: MB2_64B_WORD1 and MB9_8B_WORD1
    /// MB2_64B_WORD1: MB2_64B_WORD1 and MB6_16B_WORD1
    /// MB2_64B_WORD1: MB2_64B_WORD1 and MB3_32B_WORD7
    /// MB2_64B_WORD1: Message Buffer 2 WORD_64B Register
    /// MB3_32B_WORD7: Message Buffer 3 WORD_32B Register
    /// MB6_16B_WORD1: Message Buffer 6 WORD_16B Register
    /// MB9_8B_WORD1: Message Buffer 9 WORD_8B Register
    /// WORD19: Message Buffer 9 WORD1 Register
    pub MB2_64B_WORD1: RWRegister<u32>,

    /// CS10 and MB6_16B_WORD2
    /// CS10: CS10 and MB4_32B_CS
    /// CS10: CS10 and MB2_64B_WORD2
    /// CS10: CS10 and MB10_8B_CS
    /// CS10: Message Buffer 10 CS Register
    /// MB10_8B_CS: Message Buffer 10 CS Register
    /// MB2_64B_WORD2: Message Buffer 2 WORD_64B Register
    /// MB4_32B_CS: Message Buffer 4 CS Register
    /// MB6_16B_WORD2: Message Buffer 6 WORD_16B Register
    pub CS10: RWRegister<u32>,

    /// ID10 and MB6_16B_WORD3
    /// ID10: ID10 and MB4_32B_ID
    /// ID10: ID10 and MB2_64B_WORD3
    /// ID10: ID10 and MB10_8B_ID
    /// ID10: Message Buffer 10 ID Register
    /// MB10_8B_ID: Message Buffer 10 ID Register
    /// MB2_64B_WORD3: Message Buffer 2 WORD_64B Register
    /// MB4_32B_ID: Message Buffer 4 ID Register
    /// MB6_16B_WORD3: Message Buffer 6 WORD_16B Register
    pub ID10: RWRegister<u32>,

    /// MB10_8B_WORD0 and WORD010
    /// MB10_8B_WORD0: MB10_8B_WORD0 and MB7_16B_CS
    /// MB10_8B_WORD0: MB10_8B_WORD0 and MB4_32B_WORD0
    /// MB10_8B_WORD0: MB10_8B_WORD0 and MB2_64B_WORD4
    /// MB10_8B_WORD0: Message Buffer 10 WORD_8B Register
    /// MB2_64B_WORD4: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD0: Message Buffer 4 WORD_32B Register
    /// MB7_16B_CS: Message Buffer 7 CS Register
    /// WORD010: Message Buffer 10 WORD0 Register
    pub MB10_8B_WORD0: RWRegister<u32>,

    /// MB10_8B_WORD1 and WORD110
    /// MB10_8B_WORD1: MB10_8B_WORD1 and MB7_16B_ID
    /// MB10_8B_WORD1: MB10_8B_WORD1 and MB4_32B_WORD1
    /// MB10_8B_WORD1: MB10_8B_WORD1 and MB2_64B_WORD5
    /// MB10_8B_WORD1: Message Buffer 10 WORD_8B Register
    /// MB2_64B_WORD5: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD1: Message Buffer 4 WORD_32B Register
    /// MB7_16B_ID: Message Buffer 7 ID Register
    /// WORD110: Message Buffer 10 WORD1 Register
    pub MB10_8B_WORD1: RWRegister<u32>,

    /// CS11 and MB7_16B_WORD0
    /// CS11: CS11 and MB4_32B_WORD2
    /// CS11: CS11 and MB2_64B_WORD6
    /// CS11: CS11 and MB11_8B_CS
    /// CS11: Message Buffer 11 CS Register
    /// MB11_8B_CS: Message Buffer 11 CS Register
    /// MB2_64B_WORD6: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD2: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD0: Message Buffer 7 WORD_16B Register
    pub CS11: RWRegister<u32>,

    /// ID11 and MB7_16B_WORD1
    /// ID11: ID11 and MB4_32B_WORD3
    /// ID11: ID11 and MB2_64B_WORD7
    /// ID11: ID11 and MB11_8B_ID
    /// ID11: Message Buffer 11 ID Register
    /// MB11_8B_ID: Message Buffer 11 ID Register
    /// MB2_64B_WORD7: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD3: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD1: Message Buffer 7 WORD_16B Register
    pub ID11: RWRegister<u32>,

    /// MB11_8B_WORD0 and WORD011
    /// MB11_8B_WORD0: MB11_8B_WORD0 and MB7_16B_WORD2
    /// MB11_8B_WORD0: MB11_8B_WORD0 and MB4_32B_WORD4
    /// MB11_8B_WORD0: MB11_8B_WORD0 and MB2_64B_WORD8
    /// MB11_8B_WORD0: Message Buffer 11 WORD_8B Register
    /// MB2_64B_WORD8: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD4: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD2: Message Buffer 7 WORD_16B Register
    /// WORD011: Message Buffer 11 WORD0 Register
    pub MB11_8B_WORD0: RWRegister<u32>,

    /// MB11_8B_WORD1 and WORD111
    /// MB11_8B_WORD1: MB11_8B_WORD1 and MB7_16B_WORD3
    /// MB11_8B_WORD1: MB11_8B_WORD1 and MB4_32B_WORD5
    /// MB11_8B_WORD1: MB11_8B_WORD1 and MB2_64B_WORD9
    /// MB11_8B_WORD1: Message Buffer 11 WORD_8B Register
    /// MB2_64B_WORD9: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD5: Message Buffer 4 WORD_32B Register
    /// MB7_16B_WORD3: Message Buffer 7 WORD_16B Register
    /// WORD111: Message Buffer 11 WORD1 Register
    pub MB11_8B_WORD1: RWRegister<u32>,

    /// CS12 and MB8_16B_CS
    /// CS12: CS12 and MB4_32B_WORD6
    /// CS12: CS12 and MB2_64B_WORD10
    /// CS12: CS12 and MB12_8B_CS
    /// CS12: Message Buffer 12 CS Register
    /// MB12_8B_CS: Message Buffer 12 CS Register
    /// MB2_64B_WORD10: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD6: Message Buffer 4 WORD_32B Register
    /// MB8_16B_CS: Message Buffer 8 CS Register
    pub CS12: RWRegister<u32>,

    /// ID12 and MB8_16B_ID
    /// ID12: ID12 and MB4_32B_WORD7
    /// ID12: ID12 and MB2_64B_WORD11
    /// ID12: ID12 and MB12_8B_ID
    /// ID12: Message Buffer 12 ID Register
    /// MB12_8B_ID: Message Buffer 12 ID Register
    /// MB2_64B_WORD11: Message Buffer 2 WORD_64B Register
    /// MB4_32B_WORD7: Message Buffer 4 WORD_32B Register
    /// MB8_16B_ID: Message Buffer 8 ID Register
    pub ID12: RWRegister<u32>,

    /// MB12_8B_WORD0 and WORD012
    /// MB12_8B_WORD0: MB12_8B_WORD0 and MB8_16B_WORD0
    /// MB12_8B_WORD0: MB12_8B_WORD0 and MB5_32B_CS
    /// MB12_8B_WORD0: MB12_8B_WORD0 and MB2_64B_WORD12
    /// MB12_8B_WORD0: Message Buffer 12 WORD_8B Register
    /// MB2_64B_WORD12: Message Buffer 2 WORD_64B Register
    /// MB5_32B_CS: Message Buffer 5 CS Register
    /// MB8_16B_WORD0: Message Buffer 8 WORD_16B Register
    /// WORD012: Message Buffer 12 WORD0 Register
    pub MB12_8B_WORD0: RWRegister<u32>,

    /// MB12_8B_WORD1 and WORD112
    /// MB12_8B_WORD1: MB12_8B_WORD1 and MB8_16B_WORD1
    /// MB12_8B_WORD1: MB12_8B_WORD1 and MB5_32B_ID
    /// MB12_8B_WORD1: MB12_8B_WORD1 and MB2_64B_WORD13
    /// MB12_8B_WORD1: Message Buffer 12 WORD_8B Register
    /// MB2_64B_WORD13: Message Buffer 2 WORD_64B Register
    /// MB5_32B_ID: Message Buffer 5 ID Register
    /// MB8_16B_WORD1: Message Buffer 8 WORD_16B Register
    /// WORD112: Message Buffer 12 WORD1 Register
    pub MB12_8B_WORD1: RWRegister<u32>,

    /// CS13 and MB8_16B_WORD2
    /// CS13: CS13 and MB5_32B_WORD0
    /// CS13: CS13 and MB2_64B_WORD14
    /// CS13: CS13 and MB13_8B_CS
    /// CS13: Message Buffer 13 CS Register
    /// MB13_8B_CS: Message Buffer 13 CS Register
    /// MB2_64B_WORD14: Message Buffer 2 WORD_64B Register
    /// MB5_32B_WORD0: Message Buffer 5 WORD_32B Register
    /// MB8_16B_WORD2: Message Buffer 8 WORD_16B Register
    pub CS13: RWRegister<u32>,

    /// ID13 and MB8_16B_WORD3
    /// ID13: ID13 and MB5_32B_WORD1
    /// ID13: ID13 and MB2_64B_WORD15
    /// ID13: ID13 and MB13_8B_ID
    /// ID13: Message Buffer 13 ID Register
    /// MB13_8B_ID: Message Buffer 13 ID Register
    /// MB2_64B_WORD15: Message Buffer 2 WORD_64B Register
    /// MB5_32B_WORD1: Message Buffer 5 WORD_32B Register
    /// MB8_16B_WORD3: Message Buffer 8 WORD_16B Register
    pub ID13: RWRegister<u32>,

    /// MB13_8B_WORD0 and WORD013
    /// MB13_8B_WORD0: MB13_8B_WORD0 and MB9_16B_CS
    /// MB13_8B_WORD0: MB13_8B_WORD0 and MB5_32B_WORD2
    /// MB13_8B_WORD0: MB13_8B_WORD0 and MB3_64B_CS
    /// MB13_8B_WORD0: Message Buffer 13 WORD_8B Register
    /// MB3_64B_CS: Message Buffer 3 CS Register
    /// MB5_32B_WORD2: Message Buffer 5 WORD_32B Register
    /// MB9_16B_CS: Message Buffer 9 CS Register
    /// WORD013: Message Buffer 13 WORD0 Register
    pub MB13_8B_WORD0: RWRegister<u32>,

    /// MB13_8B_WORD1 and WORD113
    /// MB13_8B_WORD1: MB13_8B_WORD1 and MB9_16B_ID
    /// MB13_8B_WORD1: MB13_8B_WORD1 and MB5_32B_WORD3
    /// MB13_8B_WORD1: MB13_8B_WORD1 and MB3_64B_ID
    /// MB13_8B_WORD1: Message Buffer 13 WORD_8B Register
    /// MB3_64B_ID: Message Buffer 3 ID Register
    /// MB5_32B_WORD3: Message Buffer 5 WORD_32B Register
    /// MB9_16B_ID: Message Buffer 9 ID Register
    /// WORD113: Message Buffer 13 WORD1 Register
    pub MB13_8B_WORD1: RWRegister<u32>,

    /// CS14 and MB9_16B_WORD0
    /// CS14: CS14 and MB5_32B_WORD4
    /// CS14: CS14 and MB3_64B_WORD0
    /// CS14: CS14 and MB14_8B_CS
    /// CS14: Message Buffer 14 CS Register
    /// MB14_8B_CS: Message Buffer 14 CS Register
    /// MB3_64B_WORD0: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD4: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD0: Message Buffer 9 WORD_16B Register
    pub CS14: RWRegister<u32>,

    /// ID14 and MB9_16B_WORD1
    /// ID14: ID14 and MB5_32B_WORD5
    /// ID14: ID14 and MB3_64B_WORD1
    /// ID14: ID14 and MB14_8B_ID
    /// ID14: Message Buffer 14 ID Register
    /// MB14_8B_ID: Message Buffer 14 ID Register
    /// MB3_64B_WORD1: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD5: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD1: Message Buffer 9 WORD_16B Register
    pub ID14: RWRegister<u32>,

    /// MB14_8B_WORD0 and WORD014
    /// MB14_8B_WORD0: MB14_8B_WORD0 and MB9_16B_WORD2
    /// MB14_8B_WORD0: MB14_8B_WORD0 and MB5_32B_WORD6
    /// MB14_8B_WORD0: MB14_8B_WORD0 and MB3_64B_WORD2
    /// MB14_8B_WORD0: Message Buffer 14 WORD_8B Register
    /// MB3_64B_WORD2: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD6: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD2: Message Buffer 9 WORD_16B Register
    /// WORD014: Message Buffer 14 WORD0 Register
    pub MB14_8B_WORD0: RWRegister<u32>,

    /// MB14_8B_WORD1 and WORD114
    /// MB14_8B_WORD1: MB14_8B_WORD1 and MB9_16B_WORD3
    /// MB14_8B_WORD1: MB14_8B_WORD1 and MB5_32B_WORD7
    /// MB14_8B_WORD1: MB14_8B_WORD1 and MB3_64B_WORD3
    /// MB14_8B_WORD1: Message Buffer 14 WORD_8B Register
    /// MB3_64B_WORD3: Message Buffer 3 WORD_64B Register
    /// MB5_32B_WORD7: Message Buffer 5 WORD_32B Register
    /// MB9_16B_WORD3: Message Buffer 9 WORD_16B Register
    /// WORD114: Message Buffer 14 WORD1 Register
    pub MB14_8B_WORD1: RWRegister<u32>,

    /// CS15 and MB6_32B_CS
    /// CS15: CS15 and MB3_64B_WORD4
    /// CS15: CS15 and MB15_8B_CS
    /// CS15: CS15 and MB10_16B_CS
    /// CS15: Message Buffer 15 CS Register
    /// MB10_16B_CS: Message Buffer 10 CS Register
    /// MB15_8B_CS: Message Buffer 15 CS Register
    /// MB3_64B_WORD4: Message Buffer 3 WORD_64B Register
    /// MB6_32B_CS: Message Buffer 6 CS Register
    pub CS15: RWRegister<u32>,

    /// ID15 and MB6_32B_ID
    /// ID15: ID15 and MB3_64B_WORD5
    /// ID15: ID15 and MB15_8B_ID
    /// ID15: ID15 and MB10_16B_ID
    /// ID15: Message Buffer 15 ID Register
    /// MB10_16B_ID: Message Buffer 10 ID Register
    /// MB15_8B_ID: Message Buffer 15 ID Register
    /// MB3_64B_WORD5: Message Buffer 3 WORD_64B Register
    /// MB6_32B_ID: Message Buffer 6 ID Register
    pub ID15: RWRegister<u32>,

    /// MB10_16B_WORD0 and WORD015
    /// MB10_16B_WORD0: MB10_16B_WORD0 and MB6_32B_WORD0
    /// MB10_16B_WORD0: MB10_16B_WORD0 and MB3_64B_WORD6
    /// MB10_16B_WORD0: MB10_16B_WORD0 and MB15_8B_WORD0
    /// MB10_16B_WORD0: Message Buffer 10 WORD_16B Register
    /// MB15_8B_WORD0: Message Buffer 15 WORD_8B Register
    /// MB3_64B_WORD6: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD0: Message Buffer 6 WORD_32B Register
    /// WORD015: Message Buffer 15 WORD0 Register
    pub MB10_16B_WORD0: RWRegister<u32>,

    /// MB10_16B_WORD1 and WORD115
    /// MB10_16B_WORD1: MB10_16B_WORD1 and MB6_32B_WORD1
    /// MB10_16B_WORD1: MB10_16B_WORD1 and MB3_64B_WORD7
    /// MB10_16B_WORD1: MB10_16B_WORD1 and MB15_8B_WORD1
    /// MB10_16B_WORD1: Message Buffer 10 WORD_16B Register
    /// MB15_8B_WORD1: Message Buffer 15 WORD_8B Register
    /// MB3_64B_WORD7: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD1: Message Buffer 6 WORD_32B Register
    /// WORD115: Message Buffer 15 WORD1 Register
    pub MB10_16B_WORD1: RWRegister<u32>,

    /// CS16 and MB6_32B_WORD2
    /// CS16: CS16 and MB3_64B_WORD8
    /// CS16: CS16 and MB16_8B_CS
    /// CS16: CS16 and MB10_16B_WORD2
    /// CS16: Message Buffer 16 CS Register
    /// MB10_16B_WORD2: Message Buffer 10 WORD_16B Register
    /// MB16_8B_CS: Message Buffer 16 CS Register
    /// MB3_64B_WORD8: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD2: Message Buffer 6 WORD_32B Register
    pub CS16: RWRegister<u32>,

    /// ID16 and MB6_32B_WORD3
    /// ID16: ID16 and MB3_64B_WORD9
    /// ID16: ID16 and MB16_8B_ID
    /// ID16: ID16 and MB10_16B_WORD3
    /// ID16: Message Buffer 16 ID Register
    /// MB10_16B_WORD3: Message Buffer 10 WORD_16B Register
    /// MB16_8B_ID: Message Buffer 16 ID Register
    /// MB3_64B_WORD9: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD3: Message Buffer 6 WORD_32B Register
    pub ID16: RWRegister<u32>,

    /// MB11_16B_CS and WORD016
    /// MB11_16B_CS: MB11_16B_CS and MB6_32B_WORD4
    /// MB11_16B_CS: MB11_16B_CS and MB3_64B_WORD10
    /// MB11_16B_CS: MB11_16B_CS and MB16_8B_WORD0
    /// MB11_16B_CS: Message Buffer 11 CS Register
    /// MB16_8B_WORD0: Message Buffer 16 WORD_8B Register
    /// MB3_64B_WORD10: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD4: Message Buffer 6 WORD_32B Register
    /// WORD016: Message Buffer 16 WORD0 Register
    pub MB11_16B_CS: RWRegister<u32>,

    /// MB11_16B_ID and WORD116
    /// MB11_16B_ID: MB11_16B_ID and MB6_32B_WORD5
    /// MB11_16B_ID: MB11_16B_ID and MB3_64B_WORD11
    /// MB11_16B_ID: MB11_16B_ID and MB16_8B_WORD1
    /// MB11_16B_ID: Message Buffer 11 ID Register
    /// MB16_8B_WORD1: Message Buffer 16 WORD_8B Register
    /// MB3_64B_WORD11: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD5: Message Buffer 6 WORD_32B Register
    /// WORD116: Message Buffer 16 WORD1 Register
    pub MB11_16B_ID: RWRegister<u32>,

    /// CS17 and MB6_32B_WORD6
    /// CS17: CS17 and MB3_64B_WORD12
    /// CS17: CS17 and MB17_8B_CS
    /// CS17: CS17 and MB11_16B_WORD0
    /// CS17: Message Buffer 17 CS Register
    /// MB11_16B_WORD0: Message Buffer 11 WORD_16B Register
    /// MB17_8B_CS: Message Buffer 17 CS Register
    /// MB3_64B_WORD12: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD6: Message Buffer 6 WORD_32B Register
    pub CS17: RWRegister<u32>,

    /// ID17 and MB6_32B_WORD7
    /// ID17: ID17 and MB3_64B_WORD13
    /// ID17: ID17 and MB17_8B_ID
    /// ID17: ID17 and MB11_16B_WORD1
    /// ID17: Message Buffer 17 ID Register
    /// MB11_16B_WORD1: Message Buffer 11 WORD_16B Register
    /// MB17_8B_ID: Message Buffer 17 ID Register
    /// MB3_64B_WORD13: Message Buffer 3 WORD_64B Register
    /// MB6_32B_WORD7: Message Buffer 6 WORD_32B Register
    pub ID17: RWRegister<u32>,

    /// MB11_16B_WORD2 and WORD017
    /// MB11_16B_WORD2: MB11_16B_WORD2 and MB7_32B_CS
    /// MB11_16B_WORD2: MB11_16B_WORD2 and MB3_64B_WORD14
    /// MB11_16B_WORD2: MB11_16B_WORD2 and MB17_8B_WORD0
    /// MB11_16B_WORD2: Message Buffer 11 WORD_16B Register
    /// MB17_8B_WORD0: Message Buffer 17 WORD_8B Register
    /// MB3_64B_WORD14: Message Buffer 3 WORD_64B Register
    /// MB7_32B_CS: Message Buffer 7 CS Register
    /// WORD017: Message Buffer 17 WORD0 Register
    pub MB11_16B_WORD2: RWRegister<u32>,

    /// MB11_16B_WORD3 and WORD117
    /// MB11_16B_WORD3: MB11_16B_WORD3 and MB7_32B_ID
    /// MB11_16B_WORD3: MB11_16B_WORD3 and MB3_64B_WORD15
    /// MB11_16B_WORD3: MB11_16B_WORD3 and MB17_8B_WORD1
    /// MB11_16B_WORD3: Message Buffer 11 WORD_16B Register
    /// MB17_8B_WORD1: Message Buffer 17 WORD_8B Register
    /// MB3_64B_WORD15: Message Buffer 3 WORD_64B Register
    /// MB7_32B_ID: Message Buffer 7 ID Register
    /// WORD117: Message Buffer 17 WORD1 Register
    pub MB11_16B_WORD3: RWRegister<u32>,

    /// CS18 and MB7_32B_WORD0
    /// CS18: CS18 and MB4_64B_CS
    /// CS18: CS18 and MB18_8B_CS
    /// CS18: CS18 and MB12_16B_CS
    /// CS18: Message Buffer 18 CS Register
    /// MB12_16B_CS: Message Buffer 12 CS Register
    /// MB18_8B_CS: Message Buffer 18 CS Register
    /// MB4_64B_CS: Message Buffer 4 CS Register
    /// MB7_32B_WORD0: Message Buffer 7 WORD_32B Register
    pub CS18: RWRegister<u32>,

    /// ID18 and MB7_32B_WORD1
    /// ID18: ID18 and MB4_64B_ID
    /// ID18: ID18 and MB18_8B_ID
    /// ID18: ID18 and MB12_16B_ID
    /// ID18: Message Buffer 18 ID Register
    /// MB12_16B_ID: Message Buffer 12 ID Register
    /// MB18_8B_ID: Message Buffer 18 ID Register
    /// MB4_64B_ID: Message Buffer 4 ID Register
    /// MB7_32B_WORD1: Message Buffer 7 WORD_32B Register
    pub ID18: RWRegister<u32>,

    /// MB12_16B_WORD0 and WORD018
    /// MB12_16B_WORD0: MB12_16B_WORD0 and MB7_32B_WORD2
    /// MB12_16B_WORD0: MB12_16B_WORD0 and MB4_64B_WORD0
    /// MB12_16B_WORD0: MB12_16B_WORD0 and MB18_8B_WORD0
    /// MB12_16B_WORD0: Message Buffer 12 WORD_16B Register
    /// MB18_8B_WORD0: Message Buffer 18 WORD_8B Register
    /// MB4_64B_WORD0: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD2: Message Buffer 7 WORD_32B Register
    /// WORD018: Message Buffer 18 WORD0 Register
    pub MB12_16B_WORD0: RWRegister<u32>,

    /// MB12_16B_WORD1 and WORD118
    /// MB12_16B_WORD1: MB12_16B_WORD1 and MB7_32B_WORD3
    /// MB12_16B_WORD1: MB12_16B_WORD1 and MB4_64B_WORD1
    /// MB12_16B_WORD1: MB12_16B_WORD1 and MB18_8B_WORD1
    /// MB12_16B_WORD1: Message Buffer 12 WORD_16B Register
    /// MB18_8B_WORD1: Message Buffer 18 WORD_8B Register
    /// MB4_64B_WORD1: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD3: Message Buffer 7 WORD_32B Register
    /// WORD118: Message Buffer 18 WORD1 Register
    pub MB12_16B_WORD1: RWRegister<u32>,

    /// CS19 and MB7_32B_WORD4
    /// CS19: CS19 and MB4_64B_WORD2
    /// CS19: CS19 and MB19_8B_CS
    /// CS19: CS19 and MB12_16B_WORD2
    /// CS19: Message Buffer 19 CS Register
    /// MB12_16B_WORD2: Message Buffer 12 WORD_16B Register
    /// MB19_8B_CS: Message Buffer 19 CS Register
    /// MB4_64B_WORD2: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD4: Message Buffer 7 WORD_32B Register
    pub CS19: RWRegister<u32>,

    /// ID19 and MB7_32B_WORD5
    /// ID19: ID19 and MB4_64B_WORD3
    /// ID19: ID19 and MB19_8B_ID
    /// ID19: ID19 and MB12_16B_WORD3
    /// ID19: Message Buffer 19 ID Register
    /// MB12_16B_WORD3: Message Buffer 12 WORD_16B Register
    /// MB19_8B_ID: Message Buffer 19 ID Register
    /// MB4_64B_WORD3: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD5: Message Buffer 7 WORD_32B Register
    pub ID19: RWRegister<u32>,

    /// MB13_16B_CS and WORD019
    /// MB13_16B_CS: MB13_16B_CS and MB7_32B_WORD6
    /// MB13_16B_CS: MB13_16B_CS and MB4_64B_WORD4
    /// MB13_16B_CS: MB13_16B_CS and MB19_8B_WORD0
    /// MB13_16B_CS: Message Buffer 13 CS Register
    /// MB19_8B_WORD0: Message Buffer 19 WORD_8B Register
    /// MB4_64B_WORD4: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD6: Message Buffer 7 WORD_32B Register
    /// WORD019: Message Buffer 19 WORD0 Register
    pub MB13_16B_CS: RWRegister<u32>,

    /// MB13_16B_ID and WORD119
    /// MB13_16B_ID: MB13_16B_ID and MB7_32B_WORD7
    /// MB13_16B_ID: MB13_16B_ID and MB4_64B_WORD5
    /// MB13_16B_ID: MB13_16B_ID and MB19_8B_WORD1
    /// MB13_16B_ID: Message Buffer 13 ID Register
    /// MB19_8B_WORD1: Message Buffer 19 WORD_8B Register
    /// MB4_64B_WORD5: Message Buffer 4 WORD_64B Register
    /// MB7_32B_WORD7: Message Buffer 7 WORD_32B Register
    /// WORD119: Message Buffer 19 WORD1 Register
    pub MB13_16B_ID: RWRegister<u32>,

    /// CS20 and MB8_32B_CS
    /// CS20: CS20 and MB4_64B_WORD6
    /// CS20: CS20 and MB20_8B_CS
    /// CS20: CS20 and MB13_16B_WORD0
    /// CS20: Message Buffer 20 CS Register
    /// MB13_16B_WORD0: Message Buffer 13 WORD_16B Register
    /// MB20_8B_CS: Message Buffer 20 CS Register
    /// MB4_64B_WORD6: Message Buffer 4 WORD_64B Register
    /// MB8_32B_CS: Message Buffer 8 CS Register
    pub CS20: RWRegister<u32>,

    /// ID20 and MB8_32B_ID
    /// ID20: ID20 and MB4_64B_WORD7
    /// ID20: ID20 and MB20_8B_ID
    /// ID20: ID20 and MB13_16B_WORD1
    /// ID20: Message Buffer 20 ID Register
    /// MB13_16B_WORD1: Message Buffer 13 WORD_16B Register
    /// MB20_8B_ID: Message Buffer 20 ID Register
    /// MB4_64B_WORD7: Message Buffer 4 WORD_64B Register
    /// MB8_32B_ID: Message Buffer 8 ID Register
    pub ID20: RWRegister<u32>,

    /// MB13_16B_WORD2 and WORD020
    /// MB13_16B_WORD2: MB13_16B_WORD2 and MB8_32B_WORD0
    /// MB13_16B_WORD2: MB13_16B_WORD2 and MB4_64B_WORD8
    /// MB13_16B_WORD2: MB13_16B_WORD2 and MB20_8B_WORD0
    /// MB13_16B_WORD2: Message Buffer 13 WORD_16B Register
    /// MB20_8B_WORD0: Message Buffer 20 WORD_8B Register
    /// MB4_64B_WORD8: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD0: Message Buffer 8 WORD_32B Register
    /// WORD020: Message Buffer 20 WORD0 Register
    pub MB13_16B_WORD2: RWRegister<u32>,

    /// MB13_16B_WORD3 and WORD120
    /// MB13_16B_WORD3: MB13_16B_WORD3 and MB8_32B_WORD1
    /// MB13_16B_WORD3: MB13_16B_WORD3 and MB4_64B_WORD9
    /// MB13_16B_WORD3: MB13_16B_WORD3 and MB20_8B_WORD1
    /// MB13_16B_WORD3: Message Buffer 13 WORD_16B Register
    /// MB20_8B_WORD1: Message Buffer 20 WORD_8B Register
    /// MB4_64B_WORD9: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD1: Message Buffer 8 WORD_32B Register
    /// WORD120: Message Buffer 20 WORD1 Register
    pub MB13_16B_WORD3: RWRegister<u32>,

    /// CS21 and MB8_32B_WORD2
    /// CS21: CS21 and MB4_64B_WORD10
    /// CS21: CS21 and MB21_8B_CS
    /// CS21: CS21 and MB14_16B_CS
    /// CS21: Message Buffer 21 CS Register
    /// MB14_16B_CS: Message Buffer 14 CS Register
    /// MB21_8B_CS: Message Buffer 21 CS Register
    /// MB4_64B_WORD10: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD2: Message Buffer 8 WORD_32B Register
    pub CS21: RWRegister<u32>,

    /// ID21 and MB8_32B_WORD3
    /// ID21: ID21 and MB4_64B_WORD11
    /// ID21: ID21 and MB21_8B_ID
    /// ID21: ID21 and MB14_16B_ID
    /// ID21: Message Buffer 21 ID Register
    /// MB14_16B_ID: Message Buffer 14 ID Register
    /// MB21_8B_ID: Message Buffer 21 ID Register
    /// MB4_64B_WORD11: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD3: Message Buffer 8 WORD_32B Register
    pub ID21: RWRegister<u32>,

    /// MB14_16B_WORD0 and WORD021
    /// MB14_16B_WORD0: MB14_16B_WORD0 and MB8_32B_WORD4
    /// MB14_16B_WORD0: MB14_16B_WORD0 and MB4_64B_WORD12
    /// MB14_16B_WORD0: MB14_16B_WORD0 and MB21_8B_WORD0
    /// MB14_16B_WORD0: Message Buffer 14 WORD_16B Register
    /// MB21_8B_WORD0: Message Buffer 21 WORD_8B Register
    /// MB4_64B_WORD12: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD4: Message Buffer 8 WORD_32B Register
    /// WORD021: Message Buffer 21 WORD0 Register
    pub MB14_16B_WORD0: RWRegister<u32>,

    /// MB14_16B_WORD1 and WORD121
    /// MB14_16B_WORD1: MB14_16B_WORD1 and MB8_32B_WORD5
    /// MB14_16B_WORD1: MB14_16B_WORD1 and MB4_64B_WORD13
    /// MB14_16B_WORD1: MB14_16B_WORD1 and MB21_8B_WORD1
    /// MB14_16B_WORD1: Message Buffer 14 WORD_16B Register
    /// MB21_8B_WORD1: Message Buffer 21 WORD_8B Register
    /// MB4_64B_WORD13: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD5: Message Buffer 8 WORD_32B Register
    /// WORD121: Message Buffer 21 WORD1 Register
    pub MB14_16B_WORD1: RWRegister<u32>,

    /// CS22 and MB8_32B_WORD6
    /// CS22: CS22 and MB4_64B_WORD14
    /// CS22: CS22 and MB22_8B_CS
    /// CS22: CS22 and MB14_16B_WORD2
    /// CS22: Message Buffer 22 CS Register
    /// MB14_16B_WORD2: Message Buffer 14 WORD_16B Register
    /// MB22_8B_CS: Message Buffer 22 CS Register
    /// MB4_64B_WORD14: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD6: Message Buffer 8 WORD_32B Register
    pub CS22: RWRegister<u32>,

    /// ID22 and MB8_32B_WORD7
    /// ID22: ID22 and MB4_64B_WORD15
    /// ID22: ID22 and MB22_8B_ID
    /// ID22: ID22 and MB14_16B_WORD3
    /// ID22: Message Buffer 22 ID Register
    /// MB14_16B_WORD3: Message Buffer 14 WORD_16B Register
    /// MB22_8B_ID: Message Buffer 22 ID Register
    /// MB4_64B_WORD15: Message Buffer 4 WORD_64B Register
    /// MB8_32B_WORD7: Message Buffer 8 WORD_32B Register
    pub ID22: RWRegister<u32>,

    /// MB15_16B_CS and WORD022
    /// MB15_16B_CS: MB15_16B_CS and MB9_32B_CS
    /// MB15_16B_CS: MB15_16B_CS and MB5_64B_CS
    /// MB15_16B_CS: MB15_16B_CS and MB22_8B_WORD0
    /// MB15_16B_CS: Message Buffer 15 CS Register
    /// MB22_8B_WORD0: Message Buffer 22 WORD_8B Register
    /// MB5_64B_CS: Message Buffer 5 CS Register
    /// MB9_32B_CS: Message Buffer 9 CS Register
    /// WORD022: Message Buffer 22 WORD0 Register
    pub MB15_16B_CS: RWRegister<u32>,

    /// MB15_16B_ID and WORD122
    /// MB15_16B_ID: MB15_16B_ID and MB9_32B_ID
    /// MB15_16B_ID: MB15_16B_ID and MB5_64B_ID
    /// MB15_16B_ID: MB15_16B_ID and MB22_8B_WORD1
    /// MB15_16B_ID: Message Buffer 15 ID Register
    /// MB22_8B_WORD1: Message Buffer 22 WORD_8B Register
    /// MB5_64B_ID: Message Buffer 5 ID Register
    /// MB9_32B_ID: Message Buffer 9 ID Register
    /// WORD122: Message Buffer 22 WORD1 Register
    pub MB15_16B_ID: RWRegister<u32>,

    /// CS23 and MB9_32B_WORD0
    /// CS23: CS23 and MB5_64B_WORD0
    /// CS23: CS23 and MB23_8B_CS
    /// CS23: CS23 and MB15_16B_WORD0
    /// CS23: Message Buffer 23 CS Register
    /// MB15_16B_WORD0: Message Buffer 15 WORD_16B Register
    /// MB23_8B_CS: Message Buffer 23 CS Register
    /// MB5_64B_WORD0: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD0: Message Buffer 9 WORD_32B Register
    pub CS23: RWRegister<u32>,

    /// ID23 and MB9_32B_WORD1
    /// ID23: ID23 and MB5_64B_WORD1
    /// ID23: ID23 and MB23_8B_ID
    /// ID23: ID23 and MB15_16B_WORD1
    /// ID23: Message Buffer 23 ID Register
    /// MB15_16B_WORD1: Message Buffer 15 WORD_16B Register
    /// MB23_8B_ID: Message Buffer 23 ID Register
    /// MB5_64B_WORD1: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD1: Message Buffer 9 WORD_32B Register
    pub ID23: RWRegister<u32>,

    /// MB15_16B_WORD2 and WORD023
    /// MB15_16B_WORD2: MB15_16B_WORD2 and MB9_32B_WORD2
    /// MB15_16B_WORD2: MB15_16B_WORD2 and MB5_64B_WORD2
    /// MB15_16B_WORD2: MB15_16B_WORD2 and MB23_8B_WORD0
    /// MB15_16B_WORD2: Message Buffer 15 WORD_16B Register
    /// MB23_8B_WORD0: Message Buffer 23 WORD_8B Register
    /// MB5_64B_WORD2: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD2: Message Buffer 9 WORD_32B Register
    /// WORD023: Message Buffer 23 WORD0 Register
    pub MB15_16B_WORD2: RWRegister<u32>,

    /// MB15_16B_WORD3 and WORD123
    /// MB15_16B_WORD3: MB15_16B_WORD3 and MB9_32B_WORD3
    /// MB15_16B_WORD3: MB15_16B_WORD3 and MB5_64B_WORD3
    /// MB15_16B_WORD3: MB15_16B_WORD3 and MB23_8B_WORD1
    /// MB15_16B_WORD3: Message Buffer 15 WORD_16B Register
    /// MB23_8B_WORD1: Message Buffer 23 WORD_8B Register
    /// MB5_64B_WORD3: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD3: Message Buffer 9 WORD_32B Register
    /// WORD123: Message Buffer 23 WORD1 Register
    pub MB15_16B_WORD3: RWRegister<u32>,

    /// CS24 and MB9_32B_WORD4
    /// CS24: CS24 and MB5_64B_WORD4
    /// CS24: CS24 and MB24_8B_CS
    /// CS24: CS24 and MB16_16B_CS
    /// CS24: Message Buffer 24 CS Register
    /// MB16_16B_CS: Message Buffer 16 CS Register
    /// MB24_8B_CS: Message Buffer 24 CS Register
    /// MB5_64B_WORD4: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD4: Message Buffer 9 WORD_32B Register
    pub CS24: RWRegister<u32>,

    /// ID24 and MB9_32B_WORD5
    /// ID24: ID24 and MB5_64B_WORD5
    /// ID24: ID24 and MB24_8B_ID
    /// ID24: ID24 and MB16_16B_ID
    /// ID24: Message Buffer 24 ID Register
    /// MB16_16B_ID: Message Buffer 16 ID Register
    /// MB24_8B_ID: Message Buffer 24 ID Register
    /// MB5_64B_WORD5: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD5: Message Buffer 9 WORD_32B Register
    pub ID24: RWRegister<u32>,

    /// MB16_16B_WORD0 and WORD024
    /// MB16_16B_WORD0: MB16_16B_WORD0 and MB9_32B_WORD6
    /// MB16_16B_WORD0: MB16_16B_WORD0 and MB5_64B_WORD6
    /// MB16_16B_WORD0: MB16_16B_WORD0 and MB24_8B_WORD0
    /// MB16_16B_WORD0: Message Buffer 16 WORD_16B Register
    /// MB24_8B_WORD0: Message Buffer 24 WORD_8B Register
    /// MB5_64B_WORD6: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD6: Message Buffer 9 WORD_32B Register
    /// WORD024: Message Buffer 24 WORD0 Register
    pub MB16_16B_WORD0: RWRegister<u32>,

    /// MB16_16B_WORD1 and WORD124
    /// MB16_16B_WORD1: MB16_16B_WORD1 and MB9_32B_WORD7
    /// MB16_16B_WORD1: MB16_16B_WORD1 and MB5_64B_WORD7
    /// MB16_16B_WORD1: MB16_16B_WORD1 and MB24_8B_WORD1
    /// MB16_16B_WORD1: Message Buffer 16 WORD_16B Register
    /// MB24_8B_WORD1: Message Buffer 24 WORD_8B Register
    /// MB5_64B_WORD7: Message Buffer 5 WORD_64B Register
    /// MB9_32B_WORD7: Message Buffer 9 WORD_32B Register
    /// WORD124: Message Buffer 24 WORD1 Register
    pub MB16_16B_WORD1: RWRegister<u32>,

    /// CS25 and MB5_64B_WORD8
    /// CS25: CS25 and MB25_8B_CS
    /// CS25: CS25 and MB16_16B_WORD2
    /// CS25: CS25 and MB10_32B_CS
    /// CS25: Message Buffer 25 CS Register
    /// MB10_32B_CS: Message Buffer 10 CS Register
    /// MB16_16B_WORD2: Message Buffer 16 WORD_16B Register
    /// MB25_8B_CS: Message Buffer 25 CS Register
    /// MB5_64B_WORD8: Message Buffer 5 WORD_64B Register
    pub CS25: RWRegister<u32>,

    /// ID25 and MB5_64B_WORD9
    /// ID25: ID25 and MB25_8B_ID
    /// ID25: ID25 and MB16_16B_WORD3
    /// ID25: ID25 and MB10_32B_ID
    /// ID25: Message Buffer 25 ID Register
    /// MB10_32B_ID: Message Buffer 10 ID Register
    /// MB16_16B_WORD3: Message Buffer 16 WORD_16B Register
    /// MB25_8B_ID: Message Buffer 25 ID Register
    /// MB5_64B_WORD9: Message Buffer 5 WORD_64B Register
    pub ID25: RWRegister<u32>,

    /// MB10_32B_WORD0 and WORD025
    /// MB10_32B_WORD0: MB10_32B_WORD0 and MB5_64B_WORD10
    /// MB10_32B_WORD0: MB10_32B_WORD0 and MB25_8B_WORD0
    /// MB10_32B_WORD0: MB10_32B_WORD0 and MB17_16B_CS
    /// MB10_32B_WORD0: Message Buffer 10 WORD_32B Register
    /// MB17_16B_CS: Message Buffer 17 CS Register
    /// MB25_8B_WORD0: Message Buffer 25 WORD_8B Register
    /// MB5_64B_WORD10: Message Buffer 5 WORD_64B Register
    /// WORD025: Message Buffer 25 WORD0 Register
    pub MB10_32B_WORD0: RWRegister<u32>,

    /// MB10_32B_WORD1 and WORD125
    /// MB10_32B_WORD1: MB10_32B_WORD1 and MB5_64B_WORD11
    /// MB10_32B_WORD1: MB10_32B_WORD1 and MB25_8B_WORD1
    /// MB10_32B_WORD1: MB10_32B_WORD1 and MB17_16B_ID
    /// MB10_32B_WORD1: Message Buffer 10 WORD_32B Register
    /// MB17_16B_ID: Message Buffer 17 ID Register
    /// MB25_8B_WORD1: Message Buffer 25 WORD_8B Register
    /// MB5_64B_WORD11: Message Buffer 5 WORD_64B Register
    /// WORD125: Message Buffer 25 WORD1 Register
    pub MB10_32B_WORD1: RWRegister<u32>,

    /// CS26 and MB5_64B_WORD12
    /// CS26: CS26 and MB26_8B_CS
    /// CS26: CS26 and MB17_16B_WORD0
    /// CS26: CS26 and MB10_32B_WORD2
    /// CS26: Message Buffer 26 CS Register
    /// MB10_32B_WORD2: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD0: Message Buffer 17 WORD_16B Register
    /// MB26_8B_CS: Message Buffer 26 CS Register
    /// MB5_64B_WORD12: Message Buffer 5 WORD_64B Register
    pub CS26: RWRegister<u32>,

    /// ID26 and MB5_64B_WORD13
    /// ID26: ID26 and MB26_8B_ID
    /// ID26: ID26 and MB17_16B_WORD1
    /// ID26: ID26 and MB10_32B_WORD3
    /// ID26: Message Buffer 26 ID Register
    /// MB10_32B_WORD3: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD1: Message Buffer 17 WORD_16B Register
    /// MB26_8B_ID: Message Buffer 26 ID Register
    /// MB5_64B_WORD13: Message Buffer 5 WORD_64B Register
    pub ID26: RWRegister<u32>,

    /// MB10_32B_WORD4 and WORD026
    /// MB10_32B_WORD4: MB10_32B_WORD4 and MB5_64B_WORD14
    /// MB10_32B_WORD4: MB10_32B_WORD4 and MB26_8B_WORD0
    /// MB10_32B_WORD4: MB10_32B_WORD4 and MB17_16B_WORD2
    /// MB10_32B_WORD4: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD2: Message Buffer 17 WORD_16B Register
    /// MB26_8B_WORD0: Message Buffer 26 WORD_8B Register
    /// MB5_64B_WORD14: Message Buffer 5 WORD_64B Register
    /// WORD026: Message Buffer 26 WORD0 Register
    pub MB10_32B_WORD4: RWRegister<u32>,

    /// MB10_32B_WORD5 and WORD126
    /// MB10_32B_WORD5: MB10_32B_WORD5 and MB5_64B_WORD15
    /// MB10_32B_WORD5: MB10_32B_WORD5 and MB26_8B_WORD1
    /// MB10_32B_WORD5: MB10_32B_WORD5 and MB17_16B_WORD3
    /// MB10_32B_WORD5: Message Buffer 10 WORD_32B Register
    /// MB17_16B_WORD3: Message Buffer 17 WORD_16B Register
    /// MB26_8B_WORD1: Message Buffer 26 WORD_8B Register
    /// MB5_64B_WORD15: Message Buffer 5 WORD_64B Register
    /// WORD126: Message Buffer 26 WORD1 Register
    pub MB10_32B_WORD5: RWRegister<u32>,

    /// CS27 and MB6_64B_CS
    /// CS27: CS27 and MB27_8B_CS
    /// CS27: CS27 and MB18_16B_CS
    /// CS27: CS27 and MB10_32B_WORD6
    /// CS27: Message Buffer 27 CS Register
    /// MB10_32B_WORD6: Message Buffer 10 WORD_32B Register
    /// MB18_16B_CS: Message Buffer 18 CS Register
    /// MB27_8B_CS: Message Buffer 27 CS Register
    /// MB6_64B_CS: Message Buffer 6 CS Register
    pub CS27: RWRegister<u32>,

    /// ID27 and MB6_64B_ID
    /// ID27: ID27 and MB27_8B_ID
    /// ID27: ID27 and MB18_16B_ID
    /// ID27: ID27 and MB10_32B_WORD7
    /// ID27: Message Buffer 27 ID Register
    /// MB10_32B_WORD7: Message Buffer 10 WORD_32B Register
    /// MB18_16B_ID: Message Buffer 18 ID Register
    /// MB27_8B_ID: Message Buffer 27 ID Register
    /// MB6_64B_ID: Message Buffer 6 ID Register
    pub ID27: RWRegister<u32>,

    /// MB11_32B_CS and WORD027
    /// MB11_32B_CS: MB11_32B_CS and MB6_64B_WORD0
    /// MB11_32B_CS: MB11_32B_CS and MB27_8B_WORD0
    /// MB11_32B_CS: MB11_32B_CS and MB18_16B_WORD0
    /// MB11_32B_CS: Message Buffer 11 CS Register
    /// MB18_16B_WORD0: Message Buffer 18 WORD_16B Register
    /// MB27_8B_WORD0: Message Buffer 27 WORD_8B Register
    /// MB6_64B_WORD0: Message Buffer 6 WORD_64B Register
    /// WORD027: Message Buffer 27 WORD0 Register
    pub MB11_32B_CS: RWRegister<u32>,

    /// MB11_32B_ID and WORD127
    /// MB11_32B_ID: MB11_32B_ID and MB6_64B_WORD1
    /// MB11_32B_ID: MB11_32B_ID and MB27_8B_WORD1
    /// MB11_32B_ID: MB11_32B_ID and MB18_16B_WORD1
    /// MB11_32B_ID: Message Buffer 11 ID Register
    /// MB18_16B_WORD1: Message Buffer 18 WORD_16B Register
    /// MB27_8B_WORD1: Message Buffer 27 WORD_8B Register
    /// MB6_64B_WORD1: Message Buffer 6 WORD_64B Register
    /// WORD127: Message Buffer 27 WORD1 Register
    pub MB11_32B_ID: RWRegister<u32>,

    /// CS28 and MB6_64B_WORD2
    /// CS28: CS28 and MB28_8B_CS
    /// CS28: CS28 and MB18_16B_WORD2
    /// CS28: CS28 and MB11_32B_WORD0
    /// CS28: Message Buffer 28 CS Register
    /// MB11_32B_WORD0: Message Buffer 11 WORD_32B Register
    /// MB18_16B_WORD2: Message Buffer 18 WORD_16B Register
    /// MB28_8B_CS: Message Buffer 28 CS Register
    /// MB6_64B_WORD2: Message Buffer 6 WORD_64B Register
    pub CS28: RWRegister<u32>,

    /// ID28 and MB6_64B_WORD3
    /// ID28: ID28 and MB28_8B_ID
    /// ID28: ID28 and MB18_16B_WORD3
    /// ID28: ID28 and MB11_32B_WORD1
    /// ID28: Message Buffer 28 ID Register
    /// MB11_32B_WORD1: Message Buffer 11 WORD_32B Register
    /// MB18_16B_WORD3: Message Buffer 18 WORD_16B Register
    /// MB28_8B_ID: Message Buffer 28 ID Register
    /// MB6_64B_WORD3: Message Buffer 6 WORD_64B Register
    pub ID28: RWRegister<u32>,

    /// MB11_32B_WORD2 and WORD028
    /// MB11_32B_WORD2: MB11_32B_WORD2 and MB6_64B_WORD4
    /// MB11_32B_WORD2: MB11_32B_WORD2 and MB28_8B_WORD0
    /// MB11_32B_WORD2: MB11_32B_WORD2 and MB19_16B_CS
    /// MB11_32B_WORD2: Message Buffer 11 WORD_32B Register
    /// MB19_16B_CS: Message Buffer 19 CS Register
    /// MB28_8B_WORD0: Message Buffer 28 WORD_8B Register
    /// MB6_64B_WORD4: Message Buffer 6 WORD_64B Register
    /// WORD028: Message Buffer 28 WORD0 Register
    pub MB11_32B_WORD2: RWRegister<u32>,

    /// MB11_32B_WORD3 and WORD128
    /// MB11_32B_WORD3: MB11_32B_WORD3 and MB6_64B_WORD5
    /// MB11_32B_WORD3: MB11_32B_WORD3 and MB28_8B_WORD1
    /// MB11_32B_WORD3: MB11_32B_WORD3 and MB19_16B_ID
    /// MB11_32B_WORD3: Message Buffer 11 WORD_32B Register
    /// MB19_16B_ID: Message Buffer 19 ID Register
    /// MB28_8B_WORD1: Message Buffer 28 WORD_8B Register
    /// MB6_64B_WORD5: Message Buffer 6 WORD_64B Register
    /// WORD128: Message Buffer 28 WORD1 Register
    pub MB11_32B_WORD3: RWRegister<u32>,

    /// CS29 and MB6_64B_WORD6
    /// CS29: CS29 and MB29_8B_CS
    /// CS29: CS29 and MB19_16B_WORD0
    /// CS29: CS29 and MB11_32B_WORD4
    /// CS29: Message Buffer 29 CS Register
    /// MB11_32B_WORD4: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD0: Message Buffer 19 WORD_16B Register
    /// MB29_8B_CS: Message Buffer 29 CS Register
    /// MB6_64B_WORD6: Message Buffer 6 WORD_64B Register
    pub CS29: RWRegister<u32>,

    /// ID29 and MB6_64B_WORD7
    /// ID29: ID29 and MB29_8B_ID
    /// ID29: ID29 and MB19_16B_WORD1
    /// ID29: ID29 and MB11_32B_WORD5
    /// ID29: Message Buffer 29 ID Register
    /// MB11_32B_WORD5: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD1: Message Buffer 19 WORD_16B Register
    /// MB29_8B_ID: Message Buffer 29 ID Register
    /// MB6_64B_WORD7: Message Buffer 6 WORD_64B Register
    pub ID29: RWRegister<u32>,

    /// MB11_32B_WORD6 and WORD029
    /// MB11_32B_WORD6: MB11_32B_WORD6 and MB6_64B_WORD8
    /// MB11_32B_WORD6: MB11_32B_WORD6 and MB29_8B_WORD0
    /// MB11_32B_WORD6: MB11_32B_WORD6 and MB19_16B_WORD2
    /// MB11_32B_WORD6: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD2: Message Buffer 19 WORD_16B Register
    /// MB29_8B_WORD0: Message Buffer 29 WORD_8B Register
    /// MB6_64B_WORD8: Message Buffer 6 WORD_64B Register
    /// WORD029: Message Buffer 29 WORD0 Register
    pub MB11_32B_WORD6: RWRegister<u32>,

    /// MB11_32B_WORD7 and WORD129
    /// MB11_32B_WORD7: MB11_32B_WORD7 and MB6_64B_WORD9
    /// MB11_32B_WORD7: MB11_32B_WORD7 and MB29_8B_WORD1
    /// MB11_32B_WORD7: MB11_32B_WORD7 and MB19_16B_WORD3
    /// MB11_32B_WORD7: Message Buffer 11 WORD_32B Register
    /// MB19_16B_WORD3: Message Buffer 19 WORD_16B Register
    /// MB29_8B_WORD1: Message Buffer 29 WORD_8B Register
    /// MB6_64B_WORD9: Message Buffer 6 WORD_64B Register
    /// WORD129: Message Buffer 29 WORD1 Register
    pub MB11_32B_WORD7: RWRegister<u32>,

    /// CS30 and MB6_64B_WORD10
    /// CS30: CS30 and MB30_8B_CS
    /// CS30: CS30 and MB20_16B_CS
    /// CS30: CS30 and MB12_32B_CS
    /// CS30: Message Buffer 30 CS Register
    /// MB12_32B_CS: Message Buffer 12 CS Register
    /// MB20_16B_CS: Message Buffer 20 CS Register
    /// MB30_8B_CS: Message Buffer 30 CS Register
    /// MB6_64B_WORD10: Message Buffer 6 WORD_64B Register
    pub CS30: RWRegister<u32>,

    /// ID30 and MB6_64B_WORD11
    /// ID30: ID30 and MB30_8B_ID
    /// ID30: ID30 and MB20_16B_ID
    /// ID30: ID30 and MB12_32B_ID
    /// ID30: Message Buffer 30 ID Register
    /// MB12_32B_ID: Message Buffer 12 ID Register
    /// MB20_16B_ID: Message Buffer 20 ID Register
    /// MB30_8B_ID: Message Buffer 30 ID Register
    /// MB6_64B_WORD11: Message Buffer 6 WORD_64B Register
    pub ID30: RWRegister<u32>,

    /// MB12_32B_WORD0 and WORD030
    /// MB12_32B_WORD0: MB12_32B_WORD0 and MB6_64B_WORD12
    /// MB12_32B_WORD0: MB12_32B_WORD0 and MB30_8B_WORD0
    /// MB12_32B_WORD0: MB12_32B_WORD0 and MB20_16B_WORD0
    /// MB12_32B_WORD0: Message Buffer 12 WORD_32B Register
    /// MB20_16B_WORD0: Message Buffer 20 WORD_16B Register
    /// MB30_8B_WORD0: Message Buffer 30 WORD_8B Register
    /// MB6_64B_WORD12: Message Buffer 6 WORD_64B Register
    /// WORD030: Message Buffer 30 WORD0 Register
    pub MB12_32B_WORD0: RWRegister<u32>,

    /// MB12_32B_WORD1 and WORD130
    /// MB12_32B_WORD1: MB12_32B_WORD1 and MB6_64B_WORD13
    /// MB12_32B_WORD1: MB12_32B_WORD1 and MB30_8B_WORD1
    /// MB12_32B_WORD1: MB12_32B_WORD1 and MB20_16B_WORD1
    /// MB12_32B_WORD1: Message Buffer 12 WORD_32B Register
    /// MB20_16B_WORD1: Message Buffer 20 WORD_16B Register
    /// MB30_8B_WORD1: Message Buffer 30 WORD_8B Register
    /// MB6_64B_WORD13: Message Buffer 6 WORD_64B Register
    /// WORD130: Message Buffer 30 WORD1 Register
    pub MB12_32B_WORD1: RWRegister<u32>,

    /// CS31 and MB6_64B_WORD14
    /// CS31: CS31 and MB31_8B_CS
    /// CS31: CS31 and MB20_16B_WORD2
    /// CS31: CS31 and MB12_32B_WORD2
    /// CS31: Message Buffer 31 CS Register
    /// MB12_32B_WORD2: Message Buffer 12 WORD_32B Register
    /// MB20_16B_WORD2: Message Buffer 20 WORD_16B Register
    /// MB31_8B_CS: Message Buffer 31 CS Register
    /// MB6_64B_WORD14: Message Buffer 6 WORD_64B Register
    pub CS31: RWRegister<u32>,

    /// ID31 and MB6_64B_WORD15
    /// ID31: ID31 and MB31_8B_ID
    /// ID31: ID31 and MB20_16B_WORD3
    /// ID31: ID31 and MB12_32B_WORD3
    /// ID31: Message Buffer 31 ID Register
    /// MB12_32B_WORD3: Message Buffer 12 WORD_32B Register
    /// MB20_16B_WORD3: Message Buffer 20 WORD_16B Register
    /// MB31_8B_ID: Message Buffer 31 ID Register
    /// MB6_64B_WORD15: Message Buffer 6 WORD_64B Register
    pub ID31: RWRegister<u32>,

    /// MB12_32B_WORD4 and WORD031
    /// MB12_32B_WORD4: MB12_32B_WORD4 and MB7_64B_CS
    /// MB12_32B_WORD4: MB12_32B_WORD4 and MB31_8B_WORD0
    /// MB12_32B_WORD4: MB12_32B_WORD4 and MB21_16B_CS
    /// MB12_32B_WORD4: Message Buffer 12 WORD_32B Register
    /// MB21_16B_CS: Message Buffer 21 CS Register
    /// MB31_8B_WORD0: Message Buffer 31 WORD_8B Register
    /// MB7_64B_CS: Message Buffer 7 CS Register
    /// WORD031: Message Buffer 31 WORD0 Register
    pub MB12_32B_WORD4: RWRegister<u32>,

    /// MB12_32B_WORD5 and WORD131
    /// MB12_32B_WORD5: MB12_32B_WORD5 and MB7_64B_ID
    /// MB12_32B_WORD5: MB12_32B_WORD5 and MB31_8B_WORD1
    /// MB12_32B_WORD5: MB12_32B_WORD5 and MB21_16B_ID
    /// MB12_32B_WORD5: Message Buffer 12 WORD_32B Register
    /// MB21_16B_ID: Message Buffer 21 ID Register
    /// MB31_8B_WORD1: Message Buffer 31 WORD_8B Register
    /// MB7_64B_ID: Message Buffer 7 ID Register
    /// WORD131: Message Buffer 31 WORD1 Register
    pub MB12_32B_WORD5: RWRegister<u32>,

    /// CS32 and MB7_64B_WORD0
    /// CS32: CS32 and MB32_8B_CS
    /// CS32: CS32 and MB21_16B_WORD0
    /// CS32: CS32 and MB12_32B_WORD6
    /// CS32: Message Buffer 32 CS Register
    /// MB12_32B_WORD6: Message Buffer 12 WORD_32B Register
    /// MB21_16B_WORD0: Message Buffer 21 WORD_16B Register
    /// MB32_8B_CS: Message Buffer 32 CS Register
    /// MB7_64B_WORD0: Message Buffer 7 WORD_64B Register
    pub CS32: RWRegister<u32>,

    /// ID32 and MB7_64B_WORD1
    /// ID32: ID32 and MB32_8B_ID
    /// ID32: ID32 and MB21_16B_WORD1
    /// ID32: ID32 and MB12_32B_WORD7
    /// ID32: Message Buffer 32 ID Register
    /// MB12_32B_WORD7: Message Buffer 12 WORD_32B Register
    /// MB21_16B_WORD1: Message Buffer 21 WORD_16B Register
    /// MB32_8B_ID: Message Buffer 32 ID Register
    /// MB7_64B_WORD1: Message Buffer 7 WORD_64B Register
    pub ID32: RWRegister<u32>,

    /// MB13_32B_CS and WORD032
    /// MB13_32B_CS: MB13_32B_CS and MB7_64B_WORD2
    /// MB13_32B_CS: MB13_32B_CS and MB32_8B_WORD0
    /// MB13_32B_CS: MB13_32B_CS and MB21_16B_WORD2
    /// MB13_32B_CS: Message Buffer 13 CS Register
    /// MB21_16B_WORD2: Message Buffer 21 WORD_16B Register
    /// MB32_8B_WORD0: Message Buffer 32 WORD_8B Register
    /// MB7_64B_WORD2: Message Buffer 7 WORD_64B Register
    /// WORD032: Message Buffer 32 WORD0 Register
    pub MB13_32B_CS: RWRegister<u32>,

    /// MB13_32B_ID and WORD132
    /// MB13_32B_ID: MB13_32B_ID and MB7_64B_WORD3
    /// MB13_32B_ID: MB13_32B_ID and MB32_8B_WORD1
    /// MB13_32B_ID: MB13_32B_ID and MB21_16B_WORD3
    /// MB13_32B_ID: Message Buffer 13 ID Register
    /// MB21_16B_WORD3: Message Buffer 21 WORD_16B Register
    /// MB32_8B_WORD1: Message Buffer 32 WORD_8B Register
    /// MB7_64B_WORD3: Message Buffer 7 WORD_64B Register
    /// WORD132: Message Buffer 32 WORD1 Register
    pub MB13_32B_ID: RWRegister<u32>,

    /// CS33 and MB7_64B_WORD4
    /// CS33: CS33 and MB33_8B_CS
    /// CS33: CS33 and MB22_16B_CS
    /// CS33: CS33 and MB13_32B_WORD0
    /// CS33: Message Buffer 33 CS Register
    /// MB13_32B_WORD0: Message Buffer 13 WORD_32B Register
    /// MB22_16B_CS: Message Buffer 22 CS Register
    /// MB33_8B_CS: Message Buffer 33 CS Register
    /// MB7_64B_WORD4: Message Buffer 7 WORD_64B Register
    pub CS33: RWRegister<u32>,

    /// ID33 and MB7_64B_WORD5
    /// ID33: ID33 and MB33_8B_ID
    /// ID33: ID33 and MB22_16B_ID
    /// ID33: ID33 and MB13_32B_WORD1
    /// ID33: Message Buffer 33 ID Register
    /// MB13_32B_WORD1: Message Buffer 13 WORD_32B Register
    /// MB22_16B_ID: Message Buffer 22 ID Register
    /// MB33_8B_ID: Message Buffer 33 ID Register
    /// MB7_64B_WORD5: Message Buffer 7 WORD_64B Register
    pub ID33: RWRegister<u32>,

    /// MB13_32B_WORD2 and WORD033
    /// MB13_32B_WORD2: MB13_32B_WORD2 and MB7_64B_WORD6
    /// MB13_32B_WORD2: MB13_32B_WORD2 and MB33_8B_WORD0
    /// MB13_32B_WORD2: MB13_32B_WORD2 and MB22_16B_WORD0
    /// MB13_32B_WORD2: Message Buffer 13 WORD_32B Register
    /// MB22_16B_WORD0: Message Buffer 22 WORD_16B Register
    /// MB33_8B_WORD0: Message Buffer 33 WORD_8B Register
    /// MB7_64B_WORD6: Message Buffer 7 WORD_64B Register
    /// WORD033: Message Buffer 33 WORD0 Register
    pub MB13_32B_WORD2: RWRegister<u32>,

    /// MB13_32B_WORD3 and WORD133
    /// MB13_32B_WORD3: MB13_32B_WORD3 and MB7_64B_WORD7
    /// MB13_32B_WORD3: MB13_32B_WORD3 and MB33_8B_WORD1
    /// MB13_32B_WORD3: MB13_32B_WORD3 and MB22_16B_WORD1
    /// MB13_32B_WORD3: Message Buffer 13 WORD_32B Register
    /// MB22_16B_WORD1: Message Buffer 22 WORD_16B Register
    /// MB33_8B_WORD1: Message Buffer 33 WORD_8B Register
    /// MB7_64B_WORD7: Message Buffer 7 WORD_64B Register
    /// WORD133: Message Buffer 33 WORD1 Register
    pub MB13_32B_WORD3: RWRegister<u32>,

    /// CS34 and MB7_64B_WORD8
    /// CS34: CS34 and MB34_8B_CS
    /// CS34: CS34 and MB22_16B_WORD2
    /// CS34: CS34 and MB13_32B_WORD4
    /// CS34: Message Buffer 34 CS Register
    /// MB13_32B_WORD4: Message Buffer 13 WORD_32B Register
    /// MB22_16B_WORD2: Message Buffer 22 WORD_16B Register
    /// MB34_8B_CS: Message Buffer 34 CS Register
    /// MB7_64B_WORD8: Message Buffer 7 WORD_64B Register
    pub CS34: RWRegister<u32>,

    /// ID34 and MB7_64B_WORD9
    /// ID34: ID34 and MB34_8B_ID
    /// ID34: ID34 and MB22_16B_WORD3
    /// ID34: ID34 and MB13_32B_WORD5
    /// ID34: Message Buffer 34 ID Register
    /// MB13_32B_WORD5: Message Buffer 13 WORD_32B Register
    /// MB22_16B_WORD3: Message Buffer 22 WORD_16B Register
    /// MB34_8B_ID: Message Buffer 34 ID Register
    /// MB7_64B_WORD9: Message Buffer 7 WORD_64B Register
    pub ID34: RWRegister<u32>,

    /// MB13_32B_WORD6 and WORD034
    /// MB13_32B_WORD6: MB13_32B_WORD6 and MB7_64B_WORD10
    /// MB13_32B_WORD6: MB13_32B_WORD6 and MB34_8B_WORD0
    /// MB13_32B_WORD6: MB13_32B_WORD6 and MB23_16B_CS
    /// MB13_32B_WORD6: Message Buffer 13 WORD_32B Register
    /// MB23_16B_CS: Message Buffer 23 CS Register
    /// MB34_8B_WORD0: Message Buffer 34 WORD_8B Register
    /// MB7_64B_WORD10: Message Buffer 7 WORD_64B Register
    /// WORD034: Message Buffer 34 WORD0 Register
    pub MB13_32B_WORD6: RWRegister<u32>,

    /// MB13_32B_WORD7 and WORD134
    /// MB13_32B_WORD7: MB13_32B_WORD7 and MB7_64B_WORD11
    /// MB13_32B_WORD7: MB13_32B_WORD7 and MB34_8B_WORD1
    /// MB13_32B_WORD7: MB13_32B_WORD7 and MB23_16B_ID
    /// MB13_32B_WORD7: Message Buffer 13 WORD_32B Register
    /// MB23_16B_ID: Message Buffer 23 ID Register
    /// MB34_8B_WORD1: Message Buffer 34 WORD_8B Register
    /// MB7_64B_WORD11: Message Buffer 7 WORD_64B Register
    /// WORD134: Message Buffer 34 WORD1 Register
    pub MB13_32B_WORD7: RWRegister<u32>,

    /// CS35 and MB7_64B_WORD12
    /// CS35: CS35 and MB35_8B_CS
    /// CS35: CS35 and MB23_16B_WORD0
    /// CS35: CS35 and MB14_32B_CS
    /// CS35: Message Buffer 35 CS Register
    /// MB14_32B_CS: Message Buffer 14 CS Register
    /// MB23_16B_WORD0: Message Buffer 23 WORD_16B Register
    /// MB35_8B_CS: Message Buffer 35 CS Register
    /// MB7_64B_WORD12: Message Buffer 7 WORD_64B Register
    pub CS35: RWRegister<u32>,

    /// ID35 and MB7_64B_WORD13
    /// ID35: ID35 and MB35_8B_ID
    /// ID35: ID35 and MB23_16B_WORD1
    /// ID35: ID35 and MB14_32B_ID
    /// ID35: Message Buffer 35 ID Register
    /// MB14_32B_ID: Message Buffer 14 ID Register
    /// MB23_16B_WORD1: Message Buffer 23 WORD_16B Register
    /// MB35_8B_ID: Message Buffer 35 ID Register
    /// MB7_64B_WORD13: Message Buffer 7 WORD_64B Register
    pub ID35: RWRegister<u32>,

    /// MB14_32B_WORD0 and WORD035
    /// MB14_32B_WORD0: MB14_32B_WORD0 and MB7_64B_WORD14
    /// MB14_32B_WORD0: MB14_32B_WORD0 and MB35_8B_WORD0
    /// MB14_32B_WORD0: MB14_32B_WORD0 and MB23_16B_WORD2
    /// MB14_32B_WORD0: Message Buffer 14 WORD_32B Register
    /// MB23_16B_WORD2: Message Buffer 23 WORD_16B Register
    /// MB35_8B_WORD0: Message Buffer 35 WORD_8B Register
    /// MB7_64B_WORD14: Message Buffer 7 WORD_64B Register
    /// WORD035: Message Buffer 35 WORD0 Register
    pub MB14_32B_WORD0: RWRegister<u32>,

    /// MB14_32B_WORD1 and WORD135
    /// MB14_32B_WORD1: MB14_32B_WORD1 and MB7_64B_WORD15
    /// MB14_32B_WORD1: MB14_32B_WORD1 and MB35_8B_WORD1
    /// MB14_32B_WORD1: MB14_32B_WORD1 and MB23_16B_WORD3
    /// MB14_32B_WORD1: Message Buffer 14 WORD_32B Register
    /// MB23_16B_WORD3: Message Buffer 23 WORD_16B Register
    /// MB35_8B_WORD1: Message Buffer 35 WORD_8B Register
    /// MB7_64B_WORD15: Message Buffer 7 WORD_64B Register
    /// WORD135: Message Buffer 35 WORD1 Register
    pub MB14_32B_WORD1: RWRegister<u32>,

    /// CS36 and MB8_64B_CS
    /// CS36: CS36 and MB36_8B_CS
    /// CS36: CS36 and MB24_16B_CS
    /// CS36: CS36 and MB14_32B_WORD2
    /// CS36: Message Buffer 36 CS Register
    /// MB14_32B_WORD2: Message Buffer 14 WORD_32B Register
    /// MB24_16B_CS: Message Buffer 24 CS Register
    /// MB36_8B_CS: Message Buffer 36 CS Register
    /// MB8_64B_CS: Message Buffer 8 CS Register
    pub CS36: RWRegister<u32>,

    /// ID36 and MB8_64B_ID
    /// ID36: ID36 and MB36_8B_ID
    /// ID36: ID36 and MB24_16B_ID
    /// ID36: ID36 and MB14_32B_WORD3
    /// ID36: Message Buffer 36 ID Register
    /// MB14_32B_WORD3: Message Buffer 14 WORD_32B Register
    /// MB24_16B_ID: Message Buffer 24 ID Register
    /// MB36_8B_ID: Message Buffer 36 ID Register
    /// MB8_64B_ID: Message Buffer 8 ID Register
    pub ID36: RWRegister<u32>,

    /// MB14_32B_WORD4 and WORD036
    /// MB14_32B_WORD4: MB14_32B_WORD4 and MB8_64B_WORD0
    /// MB14_32B_WORD4: MB14_32B_WORD4 and MB36_8B_WORD0
    /// MB14_32B_WORD4: MB14_32B_WORD4 and MB24_16B_WORD0
    /// MB14_32B_WORD4: Message Buffer 14 WORD_32B Register
    /// MB24_16B_WORD0: Message Buffer 24 WORD_16B Register
    /// MB36_8B_WORD0: Message Buffer 36 WORD_8B Register
    /// MB8_64B_WORD0: Message Buffer 8 WORD_64B Register
    /// WORD036: Message Buffer 36 WORD0 Register
    pub MB14_32B_WORD4: RWRegister<u32>,

    /// MB14_32B_WORD5 and WORD136
    /// MB14_32B_WORD5: MB14_32B_WORD5 and MB8_64B_WORD1
    /// MB14_32B_WORD5: MB14_32B_WORD5 and MB36_8B_WORD1
    /// MB14_32B_WORD5: MB14_32B_WORD5 and MB24_16B_WORD1
    /// MB14_32B_WORD5: Message Buffer 14 WORD_32B Register
    /// MB24_16B_WORD1: Message Buffer 24 WORD_16B Register
    /// MB36_8B_WORD1: Message Buffer 36 WORD_8B Register
    /// MB8_64B_WORD1: Message Buffer 8 WORD_64B Register
    /// WORD136: Message Buffer 36 WORD1 Register
    pub MB14_32B_WORD5: RWRegister<u32>,

    /// CS37 and MB8_64B_WORD2
    /// CS37: CS37 and MB37_8B_CS
    /// CS37: CS37 and MB24_16B_WORD2
    /// CS37: CS37 and MB14_32B_WORD6
    /// CS37: Message Buffer 37 CS Register
    /// MB14_32B_WORD6: Message Buffer 14 WORD_32B Register
    /// MB24_16B_WORD2: Message Buffer 24 WORD_16B Register
    /// MB37_8B_CS: Message Buffer 37 CS Register
    /// MB8_64B_WORD2: Message Buffer 8 WORD_64B Register
    pub CS37: RWRegister<u32>,

    /// ID37 and MB8_64B_WORD3
    /// ID37: ID37 and MB37_8B_ID
    /// ID37: ID37 and MB24_16B_WORD3
    /// ID37: ID37 and MB14_32B_WORD7
    /// ID37: Message Buffer 37 ID Register
    /// MB14_32B_WORD7: Message Buffer 14 WORD_32B Register
    /// MB24_16B_WORD3: Message Buffer 24 WORD_16B Register
    /// MB37_8B_ID: Message Buffer 37 ID Register
    /// MB8_64B_WORD3: Message Buffer 8 WORD_64B Register
    pub ID37: RWRegister<u32>,

    /// MB15_32B_CS and WORD037
    /// MB15_32B_CS: MB15_32B_CS and MB8_64B_WORD4
    /// MB15_32B_CS: MB15_32B_CS and MB37_8B_WORD0
    /// MB15_32B_CS: MB15_32B_CS and MB25_16B_CS
    /// MB15_32B_CS: Message Buffer 15 CS Register
    /// MB25_16B_CS: Message Buffer 25 CS Register
    /// MB37_8B_WORD0: Message Buffer 37 WORD_8B Register
    /// MB8_64B_WORD4: Message Buffer 8 WORD_64B Register
    /// WORD037: Message Buffer 37 WORD0 Register
    pub MB15_32B_CS: RWRegister<u32>,

    /// MB15_32B_ID and WORD137
    /// MB15_32B_ID: MB15_32B_ID and MB8_64B_WORD5
    /// MB15_32B_ID: MB15_32B_ID and MB37_8B_WORD1
    /// MB15_32B_ID: MB15_32B_ID and MB25_16B_ID
    /// MB15_32B_ID: Message Buffer 15 ID Register
    /// MB25_16B_ID: Message Buffer 25 ID Register
    /// MB37_8B_WORD1: Message Buffer 37 WORD_8B Register
    /// MB8_64B_WORD5: Message Buffer 8 WORD_64B Register
    /// WORD137: Message Buffer 37 WORD1 Register
    pub MB15_32B_ID: RWRegister<u32>,

    /// CS38 and MB8_64B_WORD6
    /// CS38: CS38 and MB38_8B_CS
    /// CS38: CS38 and MB25_16B_WORD0
    /// CS38: CS38 and MB15_32B_WORD0
    /// CS38: Message Buffer 38 CS Register
    /// MB15_32B_WORD0: Message Buffer 15 WORD_32B Register
    /// MB25_16B_WORD0: Message Buffer 25 WORD_16B Register
    /// MB38_8B_CS: Message Buffer 38 CS Register
    /// MB8_64B_WORD6: Message Buffer 8 WORD_64B Register
    pub CS38: RWRegister<u32>,

    /// ID38 and MB8_64B_WORD7
    /// ID38: ID38 and MB38_8B_ID
    /// ID38: ID38 and MB25_16B_WORD1
    /// ID38: ID38 and MB15_32B_WORD1
    /// ID38: Message Buffer 38 ID Register
    /// MB15_32B_WORD1: Message Buffer 15 WORD_32B Register
    /// MB25_16B_WORD1: Message Buffer 25 WORD_16B Register
    /// MB38_8B_ID: Message Buffer 38 ID Register
    /// MB8_64B_WORD7: Message Buffer 8 WORD_64B Register
    pub ID38: RWRegister<u32>,

    /// MB15_32B_WORD2 and WORD038
    /// MB15_32B_WORD2: MB15_32B_WORD2 and MB8_64B_WORD8
    /// MB15_32B_WORD2: MB15_32B_WORD2 and MB38_8B_WORD0
    /// MB15_32B_WORD2: MB15_32B_WORD2 and MB25_16B_WORD2
    /// MB15_32B_WORD2: Message Buffer 15 WORD_32B Register
    /// MB25_16B_WORD2: Message Buffer 25 WORD_16B Register
    /// MB38_8B_WORD0: Message Buffer 38 WORD_8B Register
    /// MB8_64B_WORD8: Message Buffer 8 WORD_64B Register
    /// WORD038: Message Buffer 38 WORD0 Register
    pub MB15_32B_WORD2: RWRegister<u32>,

    /// MB15_32B_WORD3 and WORD138
    /// MB15_32B_WORD3: MB15_32B_WORD3 and MB8_64B_WORD9
    /// MB15_32B_WORD3: MB15_32B_WORD3 and MB38_8B_WORD1
    /// MB15_32B_WORD3: MB15_32B_WORD3 and MB25_16B_WORD3
    /// MB15_32B_WORD3: Message Buffer 15 WORD_32B Register
    /// MB25_16B_WORD3: Message Buffer 25 WORD_16B Register
    /// MB38_8B_WORD1: Message Buffer 38 WORD_8B Register
    /// MB8_64B_WORD9: Message Buffer 8 WORD_64B Register
    /// WORD138: Message Buffer 38 WORD1 Register
    pub MB15_32B_WORD3: RWRegister<u32>,

    /// CS39 and MB8_64B_WORD10
    /// CS39: CS39 and MB39_8B_CS
    /// CS39: CS39 and MB26_16B_CS
    /// CS39: CS39 and MB15_32B_WORD4
    /// CS39: Message Buffer 39 CS Register
    /// MB15_32B_WORD4: Message Buffer 15 WORD_32B Register
    /// MB26_16B_CS: Message Buffer 26 CS Register
    /// MB39_8B_CS: Message Buffer 39 CS Register
    /// MB8_64B_WORD10: Message Buffer 8 WORD_64B Register
    pub CS39: RWRegister<u32>,

    /// ID39 and MB8_64B_WORD11
    /// ID39: ID39 and MB39_8B_ID
    /// ID39: ID39 and MB26_16B_ID
    /// ID39: ID39 and MB15_32B_WORD5
    /// ID39: Message Buffer 39 ID Register
    /// MB15_32B_WORD5: Message Buffer 15 WORD_32B Register
    /// MB26_16B_ID: Message Buffer 26 ID Register
    /// MB39_8B_ID: Message Buffer 39 ID Register
    /// MB8_64B_WORD11: Message Buffer 8 WORD_64B Register
    pub ID39: RWRegister<u32>,

    /// MB15_32B_WORD6 and WORD039
    /// MB15_32B_WORD6: MB15_32B_WORD6 and MB8_64B_WORD12
    /// MB15_32B_WORD6: MB15_32B_WORD6 and MB39_8B_WORD0
    /// MB15_32B_WORD6: MB15_32B_WORD6 and MB26_16B_WORD0
    /// MB15_32B_WORD6: Message Buffer 15 WORD_32B Register
    /// MB26_16B_WORD0: Message Buffer 26 WORD_16B Register
    /// MB39_8B_WORD0: Message Buffer 39 WORD_8B Register
    /// MB8_64B_WORD12: Message Buffer 8 WORD_64B Register
    /// WORD039: Message Buffer 39 WORD0 Register
    pub MB15_32B_WORD6: RWRegister<u32>,

    /// MB15_32B_WORD7 and WORD139
    /// MB15_32B_WORD7: MB15_32B_WORD7 and MB8_64B_WORD13
    /// MB15_32B_WORD7: MB15_32B_WORD7 and MB39_8B_WORD1
    /// MB15_32B_WORD7: MB15_32B_WORD7 and MB26_16B_WORD1
    /// MB15_32B_WORD7: Message Buffer 15 WORD_32B Register
    /// MB26_16B_WORD1: Message Buffer 26 WORD_16B Register
    /// MB39_8B_WORD1: Message Buffer 39 WORD_8B Register
    /// MB8_64B_WORD13: Message Buffer 8 WORD_64B Register
    /// WORD139: Message Buffer 39 WORD1 Register
    pub MB15_32B_WORD7: RWRegister<u32>,

    /// CS40 and MB8_64B_WORD14
    /// CS40: CS40 and MB40_8B_CS
    /// CS40: CS40 and MB26_16B_WORD2
    /// CS40: CS40 and MB16_32B_CS
    /// CS40: Message Buffer 40 CS Register
    /// MB16_32B_CS: Message Buffer 16 CS Register
    /// MB26_16B_WORD2: Message Buffer 26 WORD_16B Register
    /// MB40_8B_CS: Message Buffer 40 CS Register
    /// MB8_64B_WORD14: Message Buffer 8 WORD_64B Register
    pub CS40: RWRegister<u32>,

    /// ID40 and MB8_64B_WORD15
    /// ID40: ID40 and MB40_8B_ID
    /// ID40: ID40 and MB26_16B_WORD3
    /// ID40: ID40 and MB16_32B_ID
    /// ID40: Message Buffer 40 ID Register
    /// MB16_32B_ID: Message Buffer 16 ID Register
    /// MB26_16B_WORD3: Message Buffer 26 WORD_16B Register
    /// MB40_8B_ID: Message Buffer 40 ID Register
    /// MB8_64B_WORD15: Message Buffer 8 WORD_64B Register
    pub ID40: RWRegister<u32>,

    /// MB16_32B_WORD0 and WORD040
    /// MB16_32B_WORD0: MB16_32B_WORD0 and MB9_64B_CS
    /// MB16_32B_WORD0: MB16_32B_WORD0 and MB40_8B_WORD0
    /// MB16_32B_WORD0: MB16_32B_WORD0 and MB27_16B_CS
    /// MB16_32B_WORD0: Message Buffer 16 WORD_32B Register
    /// MB27_16B_CS: Message Buffer 27 CS Register
    /// MB40_8B_WORD0: Message Buffer 40 WORD_8B Register
    /// MB9_64B_CS: Message Buffer 9 CS Register
    /// WORD040: Message Buffer 40 WORD0 Register
    pub MB16_32B_WORD0: RWRegister<u32>,

    /// MB16_32B_WORD1 and WORD140
    /// MB16_32B_WORD1: MB16_32B_WORD1 and MB9_64B_ID
    /// MB16_32B_WORD1: MB16_32B_WORD1 and MB40_8B_WORD1
    /// MB16_32B_WORD1: MB16_32B_WORD1 and MB27_16B_ID
    /// MB16_32B_WORD1: Message Buffer 16 WORD_32B Register
    /// MB27_16B_ID: Message Buffer 27 ID Register
    /// MB40_8B_WORD1: Message Buffer 40 WORD_8B Register
    /// MB9_64B_ID: Message Buffer 9 ID Register
    /// WORD140: Message Buffer 40 WORD1 Register
    pub MB16_32B_WORD1: RWRegister<u32>,

    /// CS41 and MB9_64B_WORD0
    /// CS41: CS41 and MB41_8B_CS
    /// CS41: CS41 and MB27_16B_WORD0
    /// CS41: CS41 and MB16_32B_WORD2
    /// CS41: Message Buffer 41 CS Register
    /// MB16_32B_WORD2: Message Buffer 16 WORD_32B Register
    /// MB27_16B_WORD0: Message Buffer 27 WORD_16B Register
    /// MB41_8B_CS: Message Buffer 41 CS Register
    /// MB9_64B_WORD0: Message Buffer 9 WORD_64B Register
    pub CS41: RWRegister<u32>,

    /// ID41 and MB9_64B_WORD1
    /// ID41: ID41 and MB41_8B_ID
    /// ID41: ID41 and MB27_16B_WORD1
    /// ID41: ID41 and MB16_32B_WORD3
    /// ID41: Message Buffer 41 ID Register
    /// MB16_32B_WORD3: Message Buffer 16 WORD_32B Register
    /// MB27_16B_WORD1: Message Buffer 27 WORD_16B Register
    /// MB41_8B_ID: Message Buffer 41 ID Register
    /// MB9_64B_WORD1: Message Buffer 9 WORD_64B Register
    pub ID41: RWRegister<u32>,

    /// MB16_32B_WORD4 and WORD041
    /// MB16_32B_WORD4: MB16_32B_WORD4 and MB9_64B_WORD2
    /// MB16_32B_WORD4: MB16_32B_WORD4 and MB41_8B_WORD0
    /// MB16_32B_WORD4: MB16_32B_WORD4 and MB27_16B_WORD2
    /// MB16_32B_WORD4: Message Buffer 16 WORD_32B Register
    /// MB27_16B_WORD2: Message Buffer 27 WORD_16B Register
    /// MB41_8B_WORD0: Message Buffer 41 WORD_8B Register
    /// MB9_64B_WORD2: Message Buffer 9 WORD_64B Register
    /// WORD041: Message Buffer 41 WORD0 Register
    pub MB16_32B_WORD4: RWRegister<u32>,

    /// MB16_32B_WORD5 and WORD141
    /// MB16_32B_WORD5: MB16_32B_WORD5 and MB9_64B_WORD3
    /// MB16_32B_WORD5: MB16_32B_WORD5 and MB41_8B_WORD1
    /// MB16_32B_WORD5: MB16_32B_WORD5 and MB27_16B_WORD3
    /// MB16_32B_WORD5: Message Buffer 16 WORD_32B Register
    /// MB27_16B_WORD3: Message Buffer 27 WORD_16B Register
    /// MB41_8B_WORD1: Message Buffer 41 WORD_8B Register
    /// MB9_64B_WORD3: Message Buffer 9 WORD_64B Register
    /// WORD141: Message Buffer 41 WORD1 Register
    pub MB16_32B_WORD5: RWRegister<u32>,

    /// CS42 and MB9_64B_WORD4
    /// CS42: CS42 and MB42_8B_CS
    /// CS42: CS42 and MB28_16B_CS
    /// CS42: CS42 and MB16_32B_WORD6
    /// CS42: Message Buffer 42 CS Register
    /// MB16_32B_WORD6: Message Buffer 16 WORD_32B Register
    /// MB28_16B_CS: Message Buffer 28 CS Register
    /// MB42_8B_CS: Message Buffer 42 CS Register
    /// MB9_64B_WORD4: Message Buffer 9 WORD_64B Register
    pub CS42: RWRegister<u32>,

    /// ID42 and MB9_64B_WORD5
    /// ID42: ID42 and MB42_8B_ID
    /// ID42: ID42 and MB28_16B_ID
    /// ID42: ID42 and MB16_32B_WORD7
    /// ID42: Message Buffer 42 ID Register
    /// MB16_32B_WORD7: Message Buffer 16 WORD_32B Register
    /// MB28_16B_ID: Message Buffer 28 ID Register
    /// MB42_8B_ID: Message Buffer 42 ID Register
    /// MB9_64B_WORD5: Message Buffer 9 WORD_64B Register
    pub ID42: RWRegister<u32>,

    /// MB17_32B_CS and WORD042
    /// MB17_32B_CS: MB17_32B_CS and MB9_64B_WORD6
    /// MB17_32B_CS: MB17_32B_CS and MB42_8B_WORD0
    /// MB17_32B_CS: MB17_32B_CS and MB28_16B_WORD0
    /// MB17_32B_CS: Message Buffer 17 CS Register
    /// MB28_16B_WORD0: Message Buffer 28 WORD_16B Register
    /// MB42_8B_WORD0: Message Buffer 42 WORD_8B Register
    /// MB9_64B_WORD6: Message Buffer 9 WORD_64B Register
    /// WORD042: Message Buffer 42 WORD0 Register
    pub MB17_32B_CS: RWRegister<u32>,

    /// MB17_32B_ID and WORD142
    /// MB17_32B_ID: MB17_32B_ID and MB9_64B_WORD7
    /// MB17_32B_ID: MB17_32B_ID and MB42_8B_WORD1
    /// MB17_32B_ID: MB17_32B_ID and MB28_16B_WORD1
    /// MB17_32B_ID: Message Buffer 17 ID Register
    /// MB28_16B_WORD1: Message Buffer 28 WORD_16B Register
    /// MB42_8B_WORD1: Message Buffer 42 WORD_8B Register
    /// MB9_64B_WORD7: Message Buffer 9 WORD_64B Register
    /// WORD142: Message Buffer 42 WORD1 Register
    pub MB17_32B_ID: RWRegister<u32>,

    /// CS43 and MB9_64B_WORD8
    /// CS43: CS43 and MB43_8B_CS
    /// CS43: CS43 and MB28_16B_WORD2
    /// CS43: CS43 and MB17_32B_WORD0
    /// CS43: Message Buffer 43 CS Register
    /// MB17_32B_WORD0: Message Buffer 17 WORD_32B Register
    /// MB28_16B_WORD2: Message Buffer 28 WORD_16B Register
    /// MB43_8B_CS: Message Buffer 43 CS Register
    /// MB9_64B_WORD8: Message Buffer 9 WORD_64B Register
    pub CS43: RWRegister<u32>,

    /// ID43 and MB9_64B_WORD9
    /// ID43: ID43 and MB43_8B_ID
    /// ID43: ID43 and MB28_16B_WORD3
    /// ID43: ID43 and MB17_32B_WORD1
    /// ID43: Message Buffer 43 ID Register
    /// MB17_32B_WORD1: Message Buffer 17 WORD_32B Register
    /// MB28_16B_WORD3: Message Buffer 28 WORD_16B Register
    /// MB43_8B_ID: Message Buffer 43 ID Register
    /// MB9_64B_WORD9: Message Buffer 9 WORD_64B Register
    pub ID43: RWRegister<u32>,

    /// MB17_32B_WORD2 and WORD043
    /// MB17_32B_WORD2: MB17_32B_WORD2 and MB9_64B_WORD10
    /// MB17_32B_WORD2: MB17_32B_WORD2 and MB43_8B_WORD0
    /// MB17_32B_WORD2: MB17_32B_WORD2 and MB29_16B_CS
    /// MB17_32B_WORD2: Message Buffer 17 WORD_32B Register
    /// MB29_16B_CS: Message Buffer 29 CS Register
    /// MB43_8B_WORD0: Message Buffer 43 WORD_8B Register
    /// MB9_64B_WORD10: Message Buffer 9 WORD_64B Register
    /// WORD043: Message Buffer 43 WORD0 Register
    pub MB17_32B_WORD2: RWRegister<u32>,

    /// MB17_32B_WORD3 and WORD143
    /// MB17_32B_WORD3: MB17_32B_WORD3 and MB9_64B_WORD11
    /// MB17_32B_WORD3: MB17_32B_WORD3 and MB43_8B_WORD1
    /// MB17_32B_WORD3: MB17_32B_WORD3 and MB29_16B_ID
    /// MB17_32B_WORD3: Message Buffer 17 WORD_32B Register
    /// MB29_16B_ID: Message Buffer 29 ID Register
    /// MB43_8B_WORD1: Message Buffer 43 WORD_8B Register
    /// MB9_64B_WORD11: Message Buffer 9 WORD_64B Register
    /// WORD143: Message Buffer 43 WORD1 Register
    pub MB17_32B_WORD3: RWRegister<u32>,

    /// CS44 and MB9_64B_WORD12
    /// CS44: CS44 and MB44_8B_CS
    /// CS44: CS44 and MB29_16B_WORD0
    /// CS44: CS44 and MB17_32B_WORD4
    /// CS44: Message Buffer 44 CS Register
    /// MB17_32B_WORD4: Message Buffer 17 WORD_32B Register
    /// MB29_16B_WORD0: Message Buffer 29 WORD_16B Register
    /// MB44_8B_CS: Message Buffer 44 CS Register
    /// MB9_64B_WORD12: Message Buffer 9 WORD_64B Register
    pub CS44: RWRegister<u32>,

    /// ID44 and MB9_64B_WORD13
    /// ID44: ID44 and MB44_8B_ID
    /// ID44: ID44 and MB29_16B_WORD1
    /// ID44: ID44 and MB17_32B_WORD5
    /// ID44: Message Buffer 44 ID Register
    /// MB17_32B_WORD5: Message Buffer 17 WORD_32B Register
    /// MB29_16B_WORD1: Message Buffer 29 WORD_16B Register
    /// MB44_8B_ID: Message Buffer 44 ID Register
    /// MB9_64B_WORD13: Message Buffer 9 WORD_64B Register
    pub ID44: RWRegister<u32>,

    /// MB17_32B_WORD6 and WORD044
    /// MB17_32B_WORD6: MB17_32B_WORD6 and MB9_64B_WORD14
    /// MB17_32B_WORD6: MB17_32B_WORD6 and MB44_8B_WORD0
    /// MB17_32B_WORD6: MB17_32B_WORD6 and MB29_16B_WORD2
    /// MB17_32B_WORD6: Message Buffer 17 WORD_32B Register
    /// MB29_16B_WORD2: Message Buffer 29 WORD_16B Register
    /// MB44_8B_WORD0: Message Buffer 44 WORD_8B Register
    /// MB9_64B_WORD14: Message Buffer 9 WORD_64B Register
    /// WORD044: Message Buffer 44 WORD0 Register
    pub MB17_32B_WORD6: RWRegister<u32>,

    /// MB17_32B_WORD7 and WORD144
    /// MB17_32B_WORD7: MB17_32B_WORD7 and MB9_64B_WORD15
    /// MB17_32B_WORD7: MB17_32B_WORD7 and MB44_8B_WORD1
    /// MB17_32B_WORD7: MB17_32B_WORD7 and MB29_16B_WORD3
    /// MB17_32B_WORD7: Message Buffer 17 WORD_32B Register
    /// MB29_16B_WORD3: Message Buffer 29 WORD_16B Register
    /// MB44_8B_WORD1: Message Buffer 44 WORD_8B Register
    /// MB9_64B_WORD15: Message Buffer 9 WORD_64B Register
    /// WORD144: Message Buffer 44 WORD1 Register
    pub MB17_32B_WORD7: RWRegister<u32>,

    /// CS45 and MB45_8B_CS
    /// CS45: CS45 and MB30_16B_CS
    /// CS45: CS45 and MB18_32B_CS
    /// CS45: CS45 and MB10_64B_CS
    /// CS45: Message Buffer 45 CS Register
    /// MB10_64B_CS: Message Buffer 10 CS Register
    /// MB18_32B_CS: Message Buffer 18 CS Register
    /// MB30_16B_CS: Message Buffer 30 CS Register
    /// MB45_8B_CS: Message Buffer 45 CS Register
    pub CS45: RWRegister<u32>,

    /// ID45 and MB45_8B_ID
    /// ID45: ID45 and MB30_16B_ID
    /// ID45: ID45 and MB18_32B_ID
    /// ID45: ID45 and MB10_64B_ID
    /// ID45: Message Buffer 45 ID Register
    /// MB10_64B_ID: Message Buffer 10 ID Register
    /// MB18_32B_ID: Message Buffer 18 ID Register
    /// MB30_16B_ID: Message Buffer 30 ID Register
    /// MB45_8B_ID: Message Buffer 45 ID Register
    pub ID45: RWRegister<u32>,

    /// MB10_64B_WORD0 and WORD045
    /// MB10_64B_WORD0: MB10_64B_WORD0 and MB45_8B_WORD0
    /// MB10_64B_WORD0: MB10_64B_WORD0 and MB30_16B_WORD0
    /// MB10_64B_WORD0: MB10_64B_WORD0 and MB18_32B_WORD0
    /// MB10_64B_WORD0: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD0: Message Buffer 18 WORD_32B Register
    /// MB30_16B_WORD0: Message Buffer 30 WORD_16B Register
    /// MB45_8B_WORD0: Message Buffer 45 WORD_8B Register
    /// WORD045: Message Buffer 45 WORD0 Register
    pub MB10_64B_WORD0: RWRegister<u32>,

    /// MB10_64B_WORD1 and WORD145
    /// MB10_64B_WORD1: MB10_64B_WORD1 and MB45_8B_WORD1
    /// MB10_64B_WORD1: MB10_64B_WORD1 and MB30_16B_WORD1
    /// MB10_64B_WORD1: MB10_64B_WORD1 and MB18_32B_WORD1
    /// MB10_64B_WORD1: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD1: Message Buffer 18 WORD_32B Register
    /// MB30_16B_WORD1: Message Buffer 30 WORD_16B Register
    /// MB45_8B_WORD1: Message Buffer 45 WORD_8B Register
    /// WORD145: Message Buffer 45 WORD1 Register
    pub MB10_64B_WORD1: RWRegister<u32>,

    /// CS46 and MB46_8B_CS
    /// CS46: CS46 and MB30_16B_WORD2
    /// CS46: CS46 and MB18_32B_WORD2
    /// CS46: CS46 and MB10_64B_WORD2
    /// CS46: Message Buffer 46 CS Register
    /// MB10_64B_WORD2: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD2: Message Buffer 18 WORD_32B Register
    /// MB30_16B_WORD2: Message Buffer 30 WORD_16B Register
    /// MB46_8B_CS: Message Buffer 46 CS Register
    pub CS46: RWRegister<u32>,

    /// ID46 and MB46_8B_ID
    /// ID46: ID46 and MB30_16B_WORD3
    /// ID46: ID46 and MB18_32B_WORD3
    /// ID46: ID46 and MB10_64B_WORD3
    /// ID46: Message Buffer 46 ID Register
    /// MB10_64B_WORD3: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD3: Message Buffer 18 WORD_32B Register
    /// MB30_16B_WORD3: Message Buffer 30 WORD_16B Register
    /// MB46_8B_ID: Message Buffer 46 ID Register
    pub ID46: RWRegister<u32>,

    /// MB10_64B_WORD4 and WORD046
    /// MB10_64B_WORD4: MB10_64B_WORD4 and MB46_8B_WORD0
    /// MB10_64B_WORD4: MB10_64B_WORD4 and MB31_16B_CS
    /// MB10_64B_WORD4: MB10_64B_WORD4 and MB18_32B_WORD4
    /// MB10_64B_WORD4: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD4: Message Buffer 18 WORD_32B Register
    /// MB31_16B_CS: Message Buffer 31 CS Register
    /// MB46_8B_WORD0: Message Buffer 46 WORD_8B Register
    /// WORD046: Message Buffer 46 WORD0 Register
    pub MB10_64B_WORD4: RWRegister<u32>,

    /// MB10_64B_WORD5 and WORD146
    /// MB10_64B_WORD5: MB10_64B_WORD5 and MB46_8B_WORD1
    /// MB10_64B_WORD5: MB10_64B_WORD5 and MB31_16B_ID
    /// MB10_64B_WORD5: MB10_64B_WORD5 and MB18_32B_WORD5
    /// MB10_64B_WORD5: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD5: Message Buffer 18 WORD_32B Register
    /// MB31_16B_ID: Message Buffer 31 ID Register
    /// MB46_8B_WORD1: Message Buffer 46 WORD_8B Register
    /// WORD146: Message Buffer 46 WORD1 Register
    pub MB10_64B_WORD5: RWRegister<u32>,

    /// CS47 and MB47_8B_CS
    /// CS47: CS47 and MB31_16B_WORD0
    /// CS47: CS47 and MB18_32B_WORD6
    /// CS47: CS47 and MB10_64B_WORD6
    /// CS47: Message Buffer 47 CS Register
    /// MB10_64B_WORD6: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD6: Message Buffer 18 WORD_32B Register
    /// MB31_16B_WORD0: Message Buffer 31 WORD_16B Register
    /// MB47_8B_CS: Message Buffer 47 CS Register
    pub CS47: RWRegister<u32>,

    /// ID47 and MB47_8B_ID
    /// ID47: ID47 and MB31_16B_WORD1
    /// ID47: ID47 and MB18_32B_WORD7
    /// ID47: ID47 and MB10_64B_WORD7
    /// ID47: Message Buffer 47 ID Register
    /// MB10_64B_WORD7: Message Buffer 10 WORD_64B Register
    /// MB18_32B_WORD7: Message Buffer 18 WORD_32B Register
    /// MB31_16B_WORD1: Message Buffer 31 WORD_16B Register
    /// MB47_8B_ID: Message Buffer 47 ID Register
    pub ID47: RWRegister<u32>,

    /// MB10_64B_WORD8 and WORD047
    /// MB10_64B_WORD8: MB10_64B_WORD8 and MB47_8B_WORD0
    /// MB10_64B_WORD8: MB10_64B_WORD8 and MB31_16B_WORD2
    /// MB10_64B_WORD8: MB10_64B_WORD8 and MB19_32B_CS
    /// MB10_64B_WORD8: Message Buffer 10 WORD_64B Register
    /// MB19_32B_CS: Message Buffer 19 CS Register
    /// MB31_16B_WORD2: Message Buffer 31 WORD_16B Register
    /// MB47_8B_WORD0: Message Buffer 47 WORD_8B Register
    /// WORD047: Message Buffer 47 WORD0 Register
    pub MB10_64B_WORD8: RWRegister<u32>,

    /// MB10_64B_WORD9 and WORD147
    /// MB10_64B_WORD9: MB10_64B_WORD9 and MB47_8B_WORD1
    /// MB10_64B_WORD9: MB10_64B_WORD9 and MB31_16B_WORD3
    /// MB10_64B_WORD9: MB10_64B_WORD9 and MB19_32B_ID
    /// MB10_64B_WORD9: Message Buffer 10 WORD_64B Register
    /// MB19_32B_ID: Message Buffer 19 ID Register
    /// MB31_16B_WORD3: Message Buffer 31 WORD_16B Register
    /// MB47_8B_WORD1: Message Buffer 47 WORD_8B Register
    /// WORD147: Message Buffer 47 WORD1 Register
    pub MB10_64B_WORD9: RWRegister<u32>,

    /// CS48 and MB48_8B_CS
    /// CS48: CS48 and MB32_16B_CS
    /// CS48: CS48 and MB19_32B_WORD0
    /// CS48: CS48 and MB10_64B_WORD10
    /// CS48: Message Buffer 48 CS Register
    /// MB10_64B_WORD10: Message Buffer 10 WORD_64B Register
    /// MB19_32B_WORD0: Message Buffer 19 WORD_32B Register
    /// MB32_16B_CS: Message Buffer 32 CS Register
    /// MB48_8B_CS: Message Buffer 48 CS Register
    pub CS48: RWRegister<u32>,

    /// ID48 and MB48_8B_ID
    /// ID48: ID48 and MB32_16B_ID
    /// ID48: ID48 and MB19_32B_WORD1
    /// ID48: ID48 and MB10_64B_WORD11
    /// ID48: Message Buffer 48 ID Register
    /// MB10_64B_WORD11: Message Buffer 10 WORD_64B Register
    /// MB19_32B_WORD1: Message Buffer 19 WORD_32B Register
    /// MB32_16B_ID: Message Buffer 32 ID Register
    /// MB48_8B_ID: Message Buffer 48 ID Register
    pub ID48: RWRegister<u32>,

    /// MB10_64B_WORD12 and WORD048
    /// MB10_64B_WORD12: MB10_64B_WORD12 and MB48_8B_WORD0
    /// MB10_64B_WORD12: MB10_64B_WORD12 and MB32_16B_WORD0
    /// MB10_64B_WORD12: MB10_64B_WORD12 and MB19_32B_WORD2
    /// MB10_64B_WORD12: Message Buffer 10 WORD_64B Register
    /// MB19_32B_WORD2: Message Buffer 19 WORD_32B Register
    /// MB32_16B_WORD0: Message Buffer 32 WORD_16B Register
    /// MB48_8B_WORD0: Message Buffer 48 WORD_8B Register
    /// WORD048: Message Buffer 48 WORD0 Register
    pub MB10_64B_WORD12: RWRegister<u32>,

    /// MB10_64B_WORD13 and WORD148
    /// MB10_64B_WORD13: MB10_64B_WORD13 and MB48_8B_WORD1
    /// MB10_64B_WORD13: MB10_64B_WORD13 and MB32_16B_WORD1
    /// MB10_64B_WORD13: MB10_64B_WORD13 and MB19_32B_WORD3
    /// MB10_64B_WORD13: Message Buffer 10 WORD_64B Register
    /// MB19_32B_WORD3: Message Buffer 19 WORD_32B Register
    /// MB32_16B_WORD1: Message Buffer 32 WORD_16B Register
    /// MB48_8B_WORD1: Message Buffer 48 WORD_8B Register
    /// WORD148: Message Buffer 48 WORD1 Register
    pub MB10_64B_WORD13: RWRegister<u32>,

    /// CS49 and MB49_8B_CS
    /// CS49: CS49 and MB32_16B_WORD2
    /// CS49: CS49 and MB19_32B_WORD4
    /// CS49: CS49 and MB10_64B_WORD14
    /// CS49: Message Buffer 49 CS Register
    /// MB10_64B_WORD14: Message Buffer 10 WORD_64B Register
    /// MB19_32B_WORD4: Message Buffer 19 WORD_32B Register
    /// MB32_16B_WORD2: Message Buffer 32 WORD_16B Register
    /// MB49_8B_CS: Message Buffer 49 CS Register
    pub CS49: RWRegister<u32>,

    /// ID49 and MB49_8B_ID
    /// ID49: ID49 and MB32_16B_WORD3
    /// ID49: ID49 and MB19_32B_WORD5
    /// ID49: ID49 and MB10_64B_WORD15
    /// ID49: Message Buffer 49 ID Register
    /// MB10_64B_WORD15: Message Buffer 10 WORD_64B Register
    /// MB19_32B_WORD5: Message Buffer 19 WORD_32B Register
    /// MB32_16B_WORD3: Message Buffer 32 WORD_16B Register
    /// MB49_8B_ID: Message Buffer 49 ID Register
    pub ID49: RWRegister<u32>,

    /// MB11_64B_CS and WORD049
    /// MB11_64B_CS: MB11_64B_CS and MB49_8B_WORD0
    /// MB11_64B_CS: MB11_64B_CS and MB33_16B_CS
    /// MB11_64B_CS: MB11_64B_CS and MB19_32B_WORD6
    /// MB11_64B_CS: Message Buffer 11 CS Register
    /// MB19_32B_WORD6: Message Buffer 19 WORD_32B Register
    /// MB33_16B_CS: Message Buffer 33 CS Register
    /// MB49_8B_WORD0: Message Buffer 49 WORD_8B Register
    /// WORD049: Message Buffer 49 WORD0 Register
    pub MB11_64B_CS: RWRegister<u32>,

    /// MB11_64B_ID and WORD149
    /// MB11_64B_ID: MB11_64B_ID and MB49_8B_WORD1
    /// MB11_64B_ID: MB11_64B_ID and MB33_16B_ID
    /// MB11_64B_ID: MB11_64B_ID and MB19_32B_WORD7
    /// MB11_64B_ID: Message Buffer 11 ID Register
    /// MB19_32B_WORD7: Message Buffer 19 WORD_32B Register
    /// MB33_16B_ID: Message Buffer 33 ID Register
    /// MB49_8B_WORD1: Message Buffer 49 WORD_8B Register
    /// WORD149: Message Buffer 49 WORD1 Register
    pub MB11_64B_ID: RWRegister<u32>,

    /// CS50 and MB50_8B_CS
    /// CS50: CS50 and MB33_16B_WORD0
    /// CS50: CS50 and MB20_32B_CS
    /// CS50: CS50 and MB11_64B_WORD0
    /// CS50: Message Buffer 50 CS Register
    /// MB11_64B_WORD0: Message Buffer 11 WORD_64B Register
    /// MB20_32B_CS: Message Buffer 20 CS Register
    /// MB33_16B_WORD0: Message Buffer 33 WORD_16B Register
    /// MB50_8B_CS: Message Buffer 50 CS Register
    pub CS50: RWRegister<u32>,

    /// ID50 and MB50_8B_ID
    /// ID50: ID50 and MB33_16B_WORD1
    /// ID50: ID50 and MB20_32B_ID
    /// ID50: ID50 and MB11_64B_WORD1
    /// ID50: Message Buffer 50 ID Register
    /// MB11_64B_WORD1: Message Buffer 11 WORD_64B Register
    /// MB20_32B_ID: Message Buffer 20 ID Register
    /// MB33_16B_WORD1: Message Buffer 33 WORD_16B Register
    /// MB50_8B_ID: Message Buffer 50 ID Register
    pub ID50: RWRegister<u32>,

    /// MB11_64B_WORD2 and WORD050
    /// MB11_64B_WORD2: MB11_64B_WORD2 and MB50_8B_WORD0
    /// MB11_64B_WORD2: MB11_64B_WORD2 and MB33_16B_WORD2
    /// MB11_64B_WORD2: MB11_64B_WORD2 and MB20_32B_WORD0
    /// MB11_64B_WORD2: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD0: Message Buffer 20 WORD_32B Register
    /// MB33_16B_WORD2: Message Buffer 33 WORD_16B Register
    /// MB50_8B_WORD0: Message Buffer 50 WORD_8B Register
    /// WORD050: Message Buffer 50 WORD0 Register
    pub MB11_64B_WORD2: RWRegister<u32>,

    /// MB11_64B_WORD3 and WORD150
    /// MB11_64B_WORD3: MB11_64B_WORD3 and MB50_8B_WORD1
    /// MB11_64B_WORD3: MB11_64B_WORD3 and MB33_16B_WORD3
    /// MB11_64B_WORD3: MB11_64B_WORD3 and MB20_32B_WORD1
    /// MB11_64B_WORD3: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD1: Message Buffer 20 WORD_32B Register
    /// MB33_16B_WORD3: Message Buffer 33 WORD_16B Register
    /// MB50_8B_WORD1: Message Buffer 50 WORD_8B Register
    /// WORD150: Message Buffer 50 WORD1 Register
    pub MB11_64B_WORD3: RWRegister<u32>,

    /// CS51 and MB51_8B_CS
    /// CS51: CS51 and MB34_16B_CS
    /// CS51: CS51 and MB20_32B_WORD2
    /// CS51: CS51 and MB11_64B_WORD4
    /// CS51: Message Buffer 51 CS Register
    /// MB11_64B_WORD4: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD2: Message Buffer 20 WORD_32B Register
    /// MB34_16B_CS: Message Buffer 34 CS Register
    /// MB51_8B_CS: Message Buffer 51 CS Register
    pub CS51: RWRegister<u32>,

    /// ID51 and MB51_8B_ID
    /// ID51: ID51 and MB34_16B_ID
    /// ID51: ID51 and MB20_32B_WORD3
    /// ID51: ID51 and MB11_64B_WORD5
    /// ID51: Message Buffer 51 ID Register
    /// MB11_64B_WORD5: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD3: Message Buffer 20 WORD_32B Register
    /// MB34_16B_ID: Message Buffer 34 ID Register
    /// MB51_8B_ID: Message Buffer 51 ID Register
    pub ID51: RWRegister<u32>,

    /// MB11_64B_WORD6 and WORD051
    /// MB11_64B_WORD6: MB11_64B_WORD6 and MB51_8B_WORD0
    /// MB11_64B_WORD6: MB11_64B_WORD6 and MB34_16B_WORD0
    /// MB11_64B_WORD6: MB11_64B_WORD6 and MB20_32B_WORD4
    /// MB11_64B_WORD6: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD4: Message Buffer 20 WORD_32B Register
    /// MB34_16B_WORD0: Message Buffer 34 WORD_16B Register
    /// MB51_8B_WORD0: Message Buffer 51 WORD_8B Register
    /// WORD051: Message Buffer 51 WORD0 Register
    pub MB11_64B_WORD6: RWRegister<u32>,

    /// MB11_64B_WORD7 and WORD151
    /// MB11_64B_WORD7: MB11_64B_WORD7 and MB51_8B_WORD1
    /// MB11_64B_WORD7: MB11_64B_WORD7 and MB34_16B_WORD1
    /// MB11_64B_WORD7: MB11_64B_WORD7 and MB20_32B_WORD5
    /// MB11_64B_WORD7: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD5: Message Buffer 20 WORD_32B Register
    /// MB34_16B_WORD1: Message Buffer 34 WORD_16B Register
    /// MB51_8B_WORD1: Message Buffer 51 WORD_8B Register
    /// WORD151: Message Buffer 51 WORD1 Register
    pub MB11_64B_WORD7: RWRegister<u32>,

    /// CS52 and MB52_8B_CS
    /// CS52: CS52 and MB34_16B_WORD2
    /// CS52: CS52 and MB20_32B_WORD6
    /// CS52: CS52 and MB11_64B_WORD8
    /// CS52: Message Buffer 52 CS Register
    /// MB11_64B_WORD8: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD6: Message Buffer 20 WORD_32B Register
    /// MB34_16B_WORD2: Message Buffer 34 WORD_16B Register
    /// MB52_8B_CS: Message Buffer 52 CS Register
    pub CS52: RWRegister<u32>,

    /// ID52 and MB52_8B_ID
    /// ID52: ID52 and MB34_16B_WORD3
    /// ID52: ID52 and MB20_32B_WORD7
    /// ID52: ID52 and MB11_64B_WORD9
    /// ID52: Message Buffer 52 ID Register
    /// MB11_64B_WORD9: Message Buffer 11 WORD_64B Register
    /// MB20_32B_WORD7: Message Buffer 20 WORD_32B Register
    /// MB34_16B_WORD3: Message Buffer 34 WORD_16B Register
    /// MB52_8B_ID: Message Buffer 52 ID Register
    pub ID52: RWRegister<u32>,

    /// MB11_64B_WORD10 and WORD052
    /// MB11_64B_WORD10: MB11_64B_WORD10 and MB52_8B_WORD0
    /// MB11_64B_WORD10: MB11_64B_WORD10 and MB35_16B_CS
    /// MB11_64B_WORD10: MB11_64B_WORD10 and MB21_32B_CS
    /// MB11_64B_WORD10: Message Buffer 11 WORD_64B Register
    /// MB21_32B_CS: Message Buffer 21 CS Register
    /// MB35_16B_CS: Message Buffer 35 CS Register
    /// MB52_8B_WORD0: Message Buffer 52 WORD_8B Register
    /// WORD052: Message Buffer 52 WORD0 Register
    pub MB11_64B_WORD10: RWRegister<u32>,

    /// MB11_64B_WORD11 and WORD152
    /// MB11_64B_WORD11: MB11_64B_WORD11 and MB52_8B_WORD1
    /// MB11_64B_WORD11: MB11_64B_WORD11 and MB35_16B_ID
    /// MB11_64B_WORD11: MB11_64B_WORD11 and MB21_32B_ID
    /// MB11_64B_WORD11: Message Buffer 11 WORD_64B Register
    /// MB21_32B_ID: Message Buffer 21 ID Register
    /// MB35_16B_ID: Message Buffer 35 ID Register
    /// MB52_8B_WORD1: Message Buffer 52 WORD_8B Register
    /// WORD152: Message Buffer 52 WORD1 Register
    pub MB11_64B_WORD11: RWRegister<u32>,

    /// CS53 and MB53_8B_CS
    /// CS53: CS53 and MB35_16B_WORD0
    /// CS53: CS53 and MB21_32B_WORD0
    /// CS53: CS53 and MB11_64B_WORD12
    /// CS53: Message Buffer 53 CS Register
    /// MB11_64B_WORD12: Message Buffer 11 WORD_64B Register
    /// MB21_32B_WORD0: Message Buffer 21 WORD_32B Register
    /// MB35_16B_WORD0: Message Buffer 35 WORD_16B Register
    /// MB53_8B_CS: Message Buffer 53 CS Register
    pub CS53: RWRegister<u32>,

    /// ID53 and MB53_8B_ID
    /// ID53: ID53 and MB35_16B_WORD1
    /// ID53: ID53 and MB21_32B_WORD1
    /// ID53: ID53 and MB11_64B_WORD13
    /// ID53: Message Buffer 53 ID Register
    /// MB11_64B_WORD13: Message Buffer 11 WORD_64B Register
    /// MB21_32B_WORD1: Message Buffer 21 WORD_32B Register
    /// MB35_16B_WORD1: Message Buffer 35 WORD_16B Register
    /// MB53_8B_ID: Message Buffer 53 ID Register
    pub ID53: RWRegister<u32>,

    /// MB11_64B_WORD14 and WORD053
    /// MB11_64B_WORD14: MB11_64B_WORD14 and MB53_8B_WORD0
    /// MB11_64B_WORD14: MB11_64B_WORD14 and MB35_16B_WORD2
    /// MB11_64B_WORD14: MB11_64B_WORD14 and MB21_32B_WORD2
    /// MB11_64B_WORD14: Message Buffer 11 WORD_64B Register
    /// MB21_32B_WORD2: Message Buffer 21 WORD_32B Register
    /// MB35_16B_WORD2: Message Buffer 35 WORD_16B Register
    /// MB53_8B_WORD0: Message Buffer 53 WORD_8B Register
    /// WORD053: Message Buffer 53 WORD0 Register
    pub MB11_64B_WORD14: RWRegister<u32>,

    /// MB11_64B_WORD15 and WORD153
    /// MB11_64B_WORD15: MB11_64B_WORD15 and MB53_8B_WORD1
    /// MB11_64B_WORD15: MB11_64B_WORD15 and MB35_16B_WORD3
    /// MB11_64B_WORD15: MB11_64B_WORD15 and MB21_32B_WORD3
    /// MB11_64B_WORD15: Message Buffer 11 WORD_64B Register
    /// MB21_32B_WORD3: Message Buffer 21 WORD_32B Register
    /// MB35_16B_WORD3: Message Buffer 35 WORD_16B Register
    /// MB53_8B_WORD1: Message Buffer 53 WORD_8B Register
    /// WORD153: Message Buffer 53 WORD1 Register
    pub MB11_64B_WORD15: RWRegister<u32>,

    /// CS54 and MB54_8B_CS
    /// CS54: CS54 and MB36_16B_CS
    /// CS54: CS54 and MB21_32B_WORD4
    /// CS54: CS54 and MB12_64B_CS
    /// CS54: Message Buffer 54 CS Register
    /// MB12_64B_CS: Message Buffer 12 CS Register
    /// MB21_32B_WORD4: Message Buffer 21 WORD_32B Register
    /// MB36_16B_CS: Message Buffer 36 CS Register
    /// MB54_8B_CS: Message Buffer 54 CS Register
    pub CS54: RWRegister<u32>,

    /// ID54 and MB54_8B_ID
    /// ID54: ID54 and MB36_16B_ID
    /// ID54: ID54 and MB21_32B_WORD5
    /// ID54: ID54 and MB12_64B_ID
    /// ID54: Message Buffer 54 ID Register
    /// MB12_64B_ID: Message Buffer 12 ID Register
    /// MB21_32B_WORD5: Message Buffer 21 WORD_32B Register
    /// MB36_16B_ID: Message Buffer 36 ID Register
    /// MB54_8B_ID: Message Buffer 54 ID Register
    pub ID54: RWRegister<u32>,

    /// MB12_64B_WORD0 and WORD054
    /// MB12_64B_WORD0: MB12_64B_WORD0 and MB54_8B_WORD0
    /// MB12_64B_WORD0: MB12_64B_WORD0 and MB36_16B_WORD0
    /// MB12_64B_WORD0: MB12_64B_WORD0 and MB21_32B_WORD6
    /// MB12_64B_WORD0: Message Buffer 12 WORD_64B Register
    /// MB21_32B_WORD6: Message Buffer 21 WORD_32B Register
    /// MB36_16B_WORD0: Message Buffer 36 WORD_16B Register
    /// MB54_8B_WORD0: Message Buffer 54 WORD_8B Register
    /// WORD054: Message Buffer 54 WORD0 Register
    pub MB12_64B_WORD0: RWRegister<u32>,

    /// MB12_64B_WORD1 and WORD154
    /// MB12_64B_WORD1: MB12_64B_WORD1 and MB54_8B_WORD1
    /// MB12_64B_WORD1: MB12_64B_WORD1 and MB36_16B_WORD1
    /// MB12_64B_WORD1: MB12_64B_WORD1 and MB21_32B_WORD7
    /// MB12_64B_WORD1: Message Buffer 12 WORD_64B Register
    /// MB21_32B_WORD7: Message Buffer 21 WORD_32B Register
    /// MB36_16B_WORD1: Message Buffer 36 WORD_16B Register
    /// MB54_8B_WORD1: Message Buffer 54 WORD_8B Register
    /// WORD154: Message Buffer 54 WORD1 Register
    pub MB12_64B_WORD1: RWRegister<u32>,

    /// CS55 and MB55_8B_CS
    /// CS55: CS55 and MB36_16B_WORD2
    /// CS55: CS55 and MB22_32B_CS
    /// CS55: CS55 and MB12_64B_WORD2
    /// CS55: Message Buffer 55 CS Register
    /// MB12_64B_WORD2: Message Buffer 12 WORD_64B Register
    /// MB22_32B_CS: Message Buffer 22 CS Register
    /// MB36_16B_WORD2: Message Buffer 36 WORD_16B Register
    /// MB55_8B_CS: Message Buffer 55 CS Register
    pub CS55: RWRegister<u32>,

    /// ID55 and MB55_8B_ID
    /// ID55: ID55 and MB36_16B_WORD3
    /// ID55: ID55 and MB22_32B_ID
    /// ID55: ID55 and MB12_64B_WORD3
    /// ID55: Message Buffer 55 ID Register
    /// MB12_64B_WORD3: Message Buffer 12 WORD_64B Register
    /// MB22_32B_ID: Message Buffer 22 ID Register
    /// MB36_16B_WORD3: Message Buffer 36 WORD_16B Register
    /// MB55_8B_ID: Message Buffer 55 ID Register
    pub ID55: RWRegister<u32>,

    /// MB12_64B_WORD4 and WORD055
    /// MB12_64B_WORD4: MB12_64B_WORD4 and MB55_8B_WORD0
    /// MB12_64B_WORD4: MB12_64B_WORD4 and MB37_16B_CS
    /// MB12_64B_WORD4: MB12_64B_WORD4 and MB22_32B_WORD0
    /// MB12_64B_WORD4: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD0: Message Buffer 22 WORD_32B Register
    /// MB37_16B_CS: Message Buffer 37 CS Register
    /// MB55_8B_WORD0: Message Buffer 55 WORD_8B Register
    /// WORD055: Message Buffer 55 WORD0 Register
    pub MB12_64B_WORD4: RWRegister<u32>,

    /// MB12_64B_WORD5 and WORD155
    /// MB12_64B_WORD5: MB12_64B_WORD5 and MB55_8B_WORD1
    /// MB12_64B_WORD5: MB12_64B_WORD5 and MB37_16B_ID
    /// MB12_64B_WORD5: MB12_64B_WORD5 and MB22_32B_WORD1
    /// MB12_64B_WORD5: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD1: Message Buffer 22 WORD_32B Register
    /// MB37_16B_ID: Message Buffer 37 ID Register
    /// MB55_8B_WORD1: Message Buffer 55 WORD_8B Register
    /// WORD155: Message Buffer 55 WORD1 Register
    pub MB12_64B_WORD5: RWRegister<u32>,

    /// CS56 and MB56_8B_CS
    /// CS56: CS56 and MB37_16B_WORD0
    /// CS56: CS56 and MB22_32B_WORD2
    /// CS56: CS56 and MB12_64B_WORD6
    /// CS56: Message Buffer 56 CS Register
    /// MB12_64B_WORD6: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD2: Message Buffer 22 WORD_32B Register
    /// MB37_16B_WORD0: Message Buffer 37 WORD_16B Register
    /// MB56_8B_CS: Message Buffer 56 CS Register
    pub CS56: RWRegister<u32>,

    /// ID56 and MB56_8B_ID
    /// ID56: ID56 and MB37_16B_WORD1
    /// ID56: ID56 and MB22_32B_WORD3
    /// ID56: ID56 and MB12_64B_WORD7
    /// ID56: Message Buffer 56 ID Register
    /// MB12_64B_WORD7: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD3: Message Buffer 22 WORD_32B Register
    /// MB37_16B_WORD1: Message Buffer 37 WORD_16B Register
    /// MB56_8B_ID: Message Buffer 56 ID Register
    pub ID56: RWRegister<u32>,

    /// MB12_64B_WORD8 and WORD056
    /// MB12_64B_WORD8: MB12_64B_WORD8 and MB56_8B_WORD0
    /// MB12_64B_WORD8: MB12_64B_WORD8 and MB37_16B_WORD2
    /// MB12_64B_WORD8: MB12_64B_WORD8 and MB22_32B_WORD4
    /// MB12_64B_WORD8: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD4: Message Buffer 22 WORD_32B Register
    /// MB37_16B_WORD2: Message Buffer 37 WORD_16B Register
    /// MB56_8B_WORD0: Message Buffer 56 WORD_8B Register
    /// WORD056: Message Buffer 56 WORD0 Register
    pub MB12_64B_WORD8: RWRegister<u32>,

    /// MB12_64B_WORD9 and WORD156
    /// MB12_64B_WORD9: MB12_64B_WORD9 and MB56_8B_WORD1
    /// MB12_64B_WORD9: MB12_64B_WORD9 and MB37_16B_WORD3
    /// MB12_64B_WORD9: MB12_64B_WORD9 and MB22_32B_WORD5
    /// MB12_64B_WORD9: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD5: Message Buffer 22 WORD_32B Register
    /// MB37_16B_WORD3: Message Buffer 37 WORD_16B Register
    /// MB56_8B_WORD1: Message Buffer 56 WORD_8B Register
    /// WORD156: Message Buffer 56 WORD1 Register
    pub MB12_64B_WORD9: RWRegister<u32>,

    /// CS57 and MB57_8B_CS
    /// CS57: CS57 and MB38_16B_CS
    /// CS57: CS57 and MB22_32B_WORD6
    /// CS57: CS57 and MB12_64B_WORD10
    /// CS57: Message Buffer 57 CS Register
    /// MB12_64B_WORD10: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD6: Message Buffer 22 WORD_32B Register
    /// MB38_16B_CS: Message Buffer 38 CS Register
    /// MB57_8B_CS: Message Buffer 57 CS Register
    pub CS57: RWRegister<u32>,

    /// ID57 and MB57_8B_ID
    /// ID57: ID57 and MB38_16B_ID
    /// ID57: ID57 and MB22_32B_WORD7
    /// ID57: ID57 and MB12_64B_WORD11
    /// ID57: Message Buffer 57 ID Register
    /// MB12_64B_WORD11: Message Buffer 12 WORD_64B Register
    /// MB22_32B_WORD7: Message Buffer 22 WORD_32B Register
    /// MB38_16B_ID: Message Buffer 38 ID Register
    /// MB57_8B_ID: Message Buffer 57 ID Register
    pub ID57: RWRegister<u32>,

    /// MB12_64B_WORD12 and WORD057
    /// MB12_64B_WORD12: MB12_64B_WORD12 and MB57_8B_WORD0
    /// MB12_64B_WORD12: MB12_64B_WORD12 and MB38_16B_WORD0
    /// MB12_64B_WORD12: MB12_64B_WORD12 and MB23_32B_CS
    /// MB12_64B_WORD12: Message Buffer 12 WORD_64B Register
    /// MB23_32B_CS: Message Buffer 23 CS Register
    /// MB38_16B_WORD0: Message Buffer 38 WORD_16B Register
    /// MB57_8B_WORD0: Message Buffer 57 WORD_8B Register
    /// WORD057: Message Buffer 57 WORD0 Register
    pub MB12_64B_WORD12: RWRegister<u32>,

    /// MB12_64B_WORD13 and WORD157
    /// MB12_64B_WORD13: MB12_64B_WORD13 and MB57_8B_WORD1
    /// MB12_64B_WORD13: MB12_64B_WORD13 and MB38_16B_WORD1
    /// MB12_64B_WORD13: MB12_64B_WORD13 and MB23_32B_ID
    /// MB12_64B_WORD13: Message Buffer 12 WORD_64B Register
    /// MB23_32B_ID: Message Buffer 23 ID Register
    /// MB38_16B_WORD1: Message Buffer 38 WORD_16B Register
    /// MB57_8B_WORD1: Message Buffer 57 WORD_8B Register
    /// WORD157: Message Buffer 57 WORD1 Register
    pub MB12_64B_WORD13: RWRegister<u32>,

    /// CS58 and MB58_8B_CS
    /// CS58: CS58 and MB38_16B_WORD2
    /// CS58: CS58 and MB23_32B_WORD0
    /// CS58: CS58 and MB12_64B_WORD14
    /// CS58: Message Buffer 58 CS Register
    /// MB12_64B_WORD14: Message Buffer 12 WORD_64B Register
    /// MB23_32B_WORD0: Message Buffer 23 WORD_32B Register
    /// MB38_16B_WORD2: Message Buffer 38 WORD_16B Register
    /// MB58_8B_CS: Message Buffer 58 CS Register
    pub CS58: RWRegister<u32>,

    /// ID58 and MB58_8B_ID
    /// ID58: ID58 and MB38_16B_WORD3
    /// ID58: ID58 and MB23_32B_WORD1
    /// ID58: ID58 and MB12_64B_WORD15
    /// ID58: Message Buffer 58 ID Register
    /// MB12_64B_WORD15: Message Buffer 12 WORD_64B Register
    /// MB23_32B_WORD1: Message Buffer 23 WORD_32B Register
    /// MB38_16B_WORD3: Message Buffer 38 WORD_16B Register
    /// MB58_8B_ID: Message Buffer 58 ID Register
    pub ID58: RWRegister<u32>,

    /// MB13_64B_CS and WORD058
    /// MB13_64B_CS: MB13_64B_CS and MB58_8B_WORD0
    /// MB13_64B_CS: MB13_64B_CS and MB39_16B_CS
    /// MB13_64B_CS: MB13_64B_CS and MB23_32B_WORD2
    /// MB13_64B_CS: Message Buffer 13 CS Register
    /// MB23_32B_WORD2: Message Buffer 23 WORD_32B Register
    /// MB39_16B_CS: Message Buffer 39 CS Register
    /// MB58_8B_WORD0: Message Buffer 58 WORD_8B Register
    /// WORD058: Message Buffer 58 WORD0 Register
    pub MB13_64B_CS: RWRegister<u32>,

    /// MB13_64B_ID and WORD158
    /// MB13_64B_ID: MB13_64B_ID and MB58_8B_WORD1
    /// MB13_64B_ID: MB13_64B_ID and MB39_16B_ID
    /// MB13_64B_ID: MB13_64B_ID and MB23_32B_WORD3
    /// MB13_64B_ID: Message Buffer 13 ID Register
    /// MB23_32B_WORD3: Message Buffer 23 WORD_32B Register
    /// MB39_16B_ID: Message Buffer 39 ID Register
    /// MB58_8B_WORD1: Message Buffer 58 WORD_8B Register
    /// WORD158: Message Buffer 58 WORD1 Register
    pub MB13_64B_ID: RWRegister<u32>,

    /// CS59 and MB59_8B_CS
    /// CS59: CS59 and MB39_16B_WORD0
    /// CS59: CS59 and MB23_32B_WORD4
    /// CS59: CS59 and MB13_64B_WORD0
    /// CS59: Message Buffer 59 CS Register
    /// MB13_64B_WORD0: Message Buffer 13 WORD_64B Register
    /// MB23_32B_WORD4: Message Buffer 23 WORD_32B Register
    /// MB39_16B_WORD0: Message Buffer 39 WORD_16B Register
    /// MB59_8B_CS: Message Buffer 59 CS Register
    pub CS59: RWRegister<u32>,

    /// ID59 and MB59_8B_ID
    /// ID59: ID59 and MB39_16B_WORD1
    /// ID59: ID59 and MB23_32B_WORD5
    /// ID59: ID59 and MB13_64B_WORD1
    /// ID59: Message Buffer 59 ID Register
    /// MB13_64B_WORD1: Message Buffer 13 WORD_64B Register
    /// MB23_32B_WORD5: Message Buffer 23 WORD_32B Register
    /// MB39_16B_WORD1: Message Buffer 39 WORD_16B Register
    /// MB59_8B_ID: Message Buffer 59 ID Register
    pub ID59: RWRegister<u32>,

    /// MB13_64B_WORD2 and WORD059
    /// MB13_64B_WORD2: MB13_64B_WORD2 and MB59_8B_WORD0
    /// MB13_64B_WORD2: MB13_64B_WORD2 and MB39_16B_WORD2
    /// MB13_64B_WORD2: MB13_64B_WORD2 and MB23_32B_WORD6
    /// MB13_64B_WORD2: Message Buffer 13 WORD_64B Register
    /// MB23_32B_WORD6: Message Buffer 23 WORD_32B Register
    /// MB39_16B_WORD2: Message Buffer 39 WORD_16B Register
    /// MB59_8B_WORD0: Message Buffer 59 WORD_8B Register
    /// WORD059: Message Buffer 59 WORD0 Register
    pub MB13_64B_WORD2: RWRegister<u32>,

    /// MB13_64B_WORD3 and WORD159
    /// MB13_64B_WORD3: MB13_64B_WORD3 and MB59_8B_WORD1
    /// MB13_64B_WORD3: MB13_64B_WORD3 and MB39_16B_WORD3
    /// MB13_64B_WORD3: MB13_64B_WORD3 and MB23_32B_WORD7
    /// MB13_64B_WORD3: Message Buffer 13 WORD_64B Register
    /// MB23_32B_WORD7: Message Buffer 23 WORD_32B Register
    /// MB39_16B_WORD3: Message Buffer 39 WORD_16B Register
    /// MB59_8B_WORD1: Message Buffer 59 WORD_8B Register
    /// WORD159: Message Buffer 59 WORD1 Register
    pub MB13_64B_WORD3: RWRegister<u32>,

    /// CS60 and MB60_8B_CS
    /// CS60: CS60 and MB40_16B_CS
    /// CS60: CS60 and MB13_64B_WORD4
    /// CS60: Message Buffer 60 CS Register
    /// MB13_64B_WORD4: Message Buffer 13 WORD_64B Register
    /// MB40_16B_CS: Message Buffer 40 CS Register
    /// MB60_8B_CS: Message Buffer 60 CS Register
    pub CS60: RWRegister<u32>,

    /// ID60 and MB60_8B_ID
    /// ID60: ID60 and MB40_16B_ID
    /// ID60: ID60 and MB13_64B_WORD5
    /// ID60: Message Buffer 60 ID Register
    /// MB13_64B_WORD5: Message Buffer 13 WORD_64B Register
    /// MB40_16B_ID: Message Buffer 40 ID Register
    /// MB60_8B_ID: Message Buffer 60 ID Register
    pub ID60: RWRegister<u32>,

    /// MB13_64B_WORD6 and WORD060
    /// MB13_64B_WORD6: MB13_64B_WORD6 and MB60_8B_WORD0
    /// MB13_64B_WORD6: MB13_64B_WORD6 and MB40_16B_WORD0
    /// MB13_64B_WORD6: Message Buffer 13 WORD_64B Register
    /// MB40_16B_WORD0: Message Buffer 40 WORD_16B Register
    /// MB60_8B_WORD0: Message Buffer 60 WORD_8B Register
    /// WORD060: Message Buffer 60 WORD0 Register
    pub MB13_64B_WORD6: RWRegister<u32>,

    /// MB13_64B_WORD7 and WORD160
    /// MB13_64B_WORD7: MB13_64B_WORD7 and MB60_8B_WORD1
    /// MB13_64B_WORD7: MB13_64B_WORD7 and MB40_16B_WORD1
    /// MB13_64B_WORD7: Message Buffer 13 WORD_64B Register
    /// MB40_16B_WORD1: Message Buffer 40 WORD_16B Register
    /// MB60_8B_WORD1: Message Buffer 60 WORD_8B Register
    /// WORD160: Message Buffer 60 WORD1 Register
    pub MB13_64B_WORD7: RWRegister<u32>,

    /// CS61 and MB61_8B_CS
    /// CS61: CS61 and MB40_16B_WORD2
    /// CS61: CS61 and MB13_64B_WORD8
    /// CS61: Message Buffer 61 CS Register
    /// MB13_64B_WORD8: Message Buffer 13 WORD_64B Register
    /// MB40_16B_WORD2: Message Buffer 40 WORD_16B Register
    /// MB61_8B_CS: Message Buffer 61 CS Register
    pub CS61: RWRegister<u32>,

    /// ID61 and MB61_8B_ID
    /// ID61: ID61 and MB40_16B_WORD3
    /// ID61: ID61 and MB13_64B_WORD9
    /// ID61: Message Buffer 61 ID Register
    /// MB13_64B_WORD9: Message Buffer 13 WORD_64B Register
    /// MB40_16B_WORD3: Message Buffer 40 WORD_16B Register
    /// MB61_8B_ID: Message Buffer 61 ID Register
    pub ID61: RWRegister<u32>,

    /// MB13_64B_WORD10 and WORD061
    /// MB13_64B_WORD10: MB13_64B_WORD10 and MB61_8B_WORD0
    /// MB13_64B_WORD10: MB13_64B_WORD10 and MB41_16B_CS
    /// MB13_64B_WORD10: Message Buffer 13 WORD_64B Register
    /// MB41_16B_CS: Message Buffer 41 CS Register
    /// MB61_8B_WORD0: Message Buffer 61 WORD_8B Register
    /// WORD061: Message Buffer 61 WORD0 Register
    pub MB13_64B_WORD10: RWRegister<u32>,

    /// MB13_64B_WORD11 and WORD161
    /// MB13_64B_WORD11: MB13_64B_WORD11 and MB61_8B_WORD1
    /// MB13_64B_WORD11: MB13_64B_WORD11 and MB41_16B_ID
    /// MB13_64B_WORD11: Message Buffer 13 WORD_64B Register
    /// MB41_16B_ID: Message Buffer 41 ID Register
    /// MB61_8B_WORD1: Message Buffer 61 WORD_8B Register
    /// WORD161: Message Buffer 61 WORD1 Register
    pub MB13_64B_WORD11: RWRegister<u32>,

    /// CS62 and MB62_8B_CS
    /// CS62: CS62 and MB41_16B_WORD0
    /// CS62: CS62 and MB13_64B_WORD12
    /// CS62: Message Buffer 62 CS Register
    /// MB13_64B_WORD12: Message Buffer 13 WORD_64B Register
    /// MB41_16B_WORD0: Message Buffer 41 WORD_16B Register
    /// MB62_8B_CS: Message Buffer 62 CS Register
    pub CS62: RWRegister<u32>,

    /// ID62 and MB62_8B_ID
    /// ID62: ID62 and MB41_16B_WORD1
    /// ID62: ID62 and MB13_64B_WORD13
    /// ID62: Message Buffer 62 ID Register
    /// MB13_64B_WORD13: Message Buffer 13 WORD_64B Register
    /// MB41_16B_WORD1: Message Buffer 41 WORD_16B Register
    /// MB62_8B_ID: Message Buffer 62 ID Register
    pub ID62: RWRegister<u32>,

    /// MB13_64B_WORD14 and WORD062
    /// MB13_64B_WORD14: MB13_64B_WORD14 and MB62_8B_WORD0
    /// MB13_64B_WORD14: MB13_64B_WORD14 and MB41_16B_WORD2
    /// MB13_64B_WORD14: Message Buffer 13 WORD_64B Register
    /// MB41_16B_WORD2: Message Buffer 41 WORD_16B Register
    /// MB62_8B_WORD0: Message Buffer 62 WORD_8B Register
    /// WORD062: Message Buffer 62 WORD0 Register
    pub MB13_64B_WORD14: RWRegister<u32>,

    /// MB13_64B_WORD15 and WORD162
    /// MB13_64B_WORD15: MB13_64B_WORD15 and MB62_8B_WORD1
    /// MB13_64B_WORD15: MB13_64B_WORD15 and MB41_16B_WORD3
    /// MB13_64B_WORD15: Message Buffer 13 WORD_64B Register
    /// MB41_16B_WORD3: Message Buffer 41 WORD_16B Register
    /// MB62_8B_WORD1: Message Buffer 62 WORD_8B Register
    /// WORD162: Message Buffer 62 WORD1 Register
    pub MB13_64B_WORD15: RWRegister<u32>,

    /// CS63 and MB63_8B_CS
    /// CS63: Message Buffer 63 CS Register
    /// MB63_8B_CS: Message Buffer 63 CS Register
    pub CS63: RWRegister<u32>,

    /// ID63 and MB63_8B_ID
    /// ID63: Message Buffer 63 ID Register
    /// MB63_8B_ID: Message Buffer 63 ID Register
    pub ID63: RWRegister<u32>,

    /// MB63_8B_WORD0 and WORD063
    /// MB63_8B_WORD0: Message Buffer 63 WORD_8B Register
    /// WORD063: Message Buffer 63 WORD0 Register
    pub MB63_8B_WORD0: RWRegister<u32>,

    /// MB63_8B_WORD1 and WORD163
    /// MB63_8B_WORD1: Message Buffer 63 WORD_8B Register
    /// WORD163: Message Buffer 63 WORD1 Register
    pub MB63_8B_WORD1: RWRegister<u32>,

    _reserved4: [u32; 256],

    /// Rx Individual Mask Registers
    pub RXIMR0: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR1: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR2: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR3: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR4: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR5: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR6: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR7: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR8: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR9: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR10: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR11: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR12: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR13: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR14: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR15: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR16: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR17: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR18: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR19: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR20: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR21: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR22: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR23: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR24: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR25: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR26: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR27: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR28: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR29: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR30: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR31: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR32: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR33: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR34: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR35: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR36: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR37: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR38: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR39: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR40: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR41: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR42: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR43: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR44: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR45: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR46: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR47: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR48: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR49: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR50: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR51: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR52: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR53: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR54: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR55: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR56: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR57: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR58: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR59: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR60: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR61: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR62: RWRegister<u32>,

    /// Rx Individual Mask Registers
    pub RXIMR63: RWRegister<u32>,

    _reserved5: [u32; 156],

    /// Enhanced CAN Bit Timing Prescalers
    pub EPRS: RWRegister<u32>,

    /// Enhanced Nominal CAN Bit Timing
    pub ENCBT: RWRegister<u32>,

    /// Enhanced Data Phase CAN bit Timing
    pub EDCBT: RWRegister<u32>,

    /// Enhanced Transceiver Delay Compensation
    pub ETDC: RWRegister<u32>,

    /// CAN FD Control Register
    pub FDCTRL: RWRegister<u32>,

    /// CAN FD Bit Timing Register
    pub FDCBT: RWRegister<u32>,

    /// CAN FD CRC Register
    pub FDCRC: RORegister<u32>,

    /// Enhanced Rx FIFO Control Register
    pub ERFCR: RWRegister<u32>,

    /// Enhanced Rx FIFO Interrupt Enable register
    pub ERFIER: RWRegister<u32>,

    /// Enhanced Rx FIFO Status Register
    pub ERFSR: RWRegister<u32>,

    _reserved6: [u32; 6],

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP0: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP1: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP2: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP3: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP4: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP5: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP6: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP7: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP8: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP9: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP10: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP11: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP12: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP13: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP14: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP15: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP16: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP17: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP18: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP19: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP20: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP21: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP22: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP23: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP24: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP25: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP26: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP27: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP28: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP29: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP30: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP31: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP32: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP33: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP34: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP35: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP36: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP37: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP38: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP39: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP40: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP41: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP42: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP43: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP44: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP45: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP46: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP47: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP48: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP49: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP50: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP51: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP52: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP53: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP54: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP55: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP56: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP57: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP58: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP59: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP60: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP61: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP62: RORegister<u32>,

    /// High Resolution Time Stamp
    pub HR_TIME_STAMP63: RORegister<u32>,

    _reserved7: [u32; 2228],

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL0: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL1: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL2: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL3: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL4: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL5: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL6: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL7: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL8: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL9: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL10: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL11: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL12: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL13: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL14: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL15: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL16: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL17: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL18: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL19: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL20: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL21: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL22: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL23: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL24: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL25: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL26: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL27: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL28: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL29: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL30: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL31: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL32: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL33: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL34: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL35: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL36: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL37: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL38: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL39: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL40: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL41: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL42: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL43: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL44: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL45: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL46: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL47: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL48: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL49: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL50: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL51: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL52: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL53: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL54: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL55: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL56: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL57: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL58: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL59: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL60: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL61: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL62: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL63: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL64: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL65: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL66: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL67: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL68: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL69: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL70: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL71: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL72: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL73: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL74: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL75: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL76: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL77: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL78: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL79: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL80: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL81: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL82: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL83: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL84: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL85: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL86: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL87: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL88: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL89: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL90: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL91: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL92: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL93: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL94: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL95: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL96: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL97: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL98: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL99: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL100: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL101: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL102: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL103: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL104: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL105: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL106: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL107: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL108: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL109: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL110: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL111: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL112: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL113: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL114: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL115: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL116: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL117: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL118: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL119: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL120: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL121: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL122: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL123: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL124: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL125: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL126: RWRegister<u32>,

    /// Enhanced Rx FIFO Filter Element
    pub ERFFEL127: RWRegister<u32>,
}
pub struct ResetValues {
    pub MCR: u32,
    pub CTRL1: u32,
    pub TIMER: u32,
    pub RXMGMASK: u32,
    pub RX14MASK: u32,
    pub RX15MASK: u32,
    pub ECR: u32,
    pub ESR1: u32,
    pub IMASK2: u32,
    pub IMASK1: u32,
    pub IFLAG2: u32,
    pub IFLAG1: u32,
    pub CTRL2: u32,
    pub ESR2: u32,
    pub CRCR: u32,
    pub RXFGMASK: u32,
    pub RXFIR: u32,
    pub CBT: u32,
    pub CS0: u32,
    pub ID0: u32,
    pub MB0: u32,
    pub MB0_16B_WORD1: u32,
    pub CS1: u32,
    pub ID1: u32,
    pub MB: u32,
    pub MB0_32B_WORD5: u32,
    pub CS2: u32,
    pub ID2: u32,
    pub MB0_64B_WORD8: u32,
    pub MB0_64B_WORD9: u32,
    pub CS3: u32,
    pub ID3: u32,
    pub MB0_64B_WORD12: u32,
    pub MB0_64B_WORD13: u32,
    pub CS4: u32,
    pub ID4: u32,
    pub MB1: u32,
    pub MB1_32B_WORD7: u32,
    pub CS5: u32,
    pub ID5: u32,
    pub MB1_64B_WORD2: u32,
    pub MB1_64B_WORD3: u32,
    pub CS6: u32,
    pub ID6: u32,
    pub MB1_64B_WORD6: u32,
    pub MB1_64B_WORD7: u32,
    pub CS7: u32,
    pub ID7: u32,
    pub MB1_64B_WORD10: u32,
    pub MB1_64B_WORD11: u32,
    pub CS8: u32,
    pub ID8: u32,
    pub MB1_64B_WORD14: u32,
    pub MB1_64B_WORD15: u32,
    pub CS9: u32,
    pub ID9: u32,
    pub MB2_64B_WORD0: u32,
    pub MB2_64B_WORD1: u32,
    pub CS10: u32,
    pub ID10: u32,
    pub MB10_8B_WORD0: u32,
    pub MB10_8B_WORD1: u32,
    pub CS11: u32,
    pub ID11: u32,
    pub MB11_8B_WORD0: u32,
    pub MB11_8B_WORD1: u32,
    pub CS12: u32,
    pub ID12: u32,
    pub MB12_8B_WORD0: u32,
    pub MB12_8B_WORD1: u32,
    pub CS13: u32,
    pub ID13: u32,
    pub MB13_8B_WORD0: u32,
    pub MB13_8B_WORD1: u32,
    pub CS14: u32,
    pub ID14: u32,
    pub MB14_8B_WORD0: u32,
    pub MB14_8B_WORD1: u32,
    pub CS15: u32,
    pub ID15: u32,
    pub MB10_16B_WORD0: u32,
    pub MB10_16B_WORD1: u32,
    pub CS16: u32,
    pub ID16: u32,
    pub MB11_16B_CS: u32,
    pub MB11_16B_ID: u32,
    pub CS17: u32,
    pub ID17: u32,
    pub MB11_16B_WORD2: u32,
    pub MB11_16B_WORD3: u32,
    pub CS18: u32,
    pub ID18: u32,
    pub MB12_16B_WORD0: u32,
    pub MB12_16B_WORD1: u32,
    pub CS19: u32,
    pub ID19: u32,
    pub MB13_16B_CS: u32,
    pub MB13_16B_ID: u32,
    pub CS20: u32,
    pub ID20: u32,
    pub MB13_16B_WORD2: u32,
    pub MB13_16B_WORD3: u32,
    pub CS21: u32,
    pub ID21: u32,
    pub MB14_16B_WORD0: u32,
    pub MB14_16B_WORD1: u32,
    pub CS22: u32,
    pub ID22: u32,
    pub MB15_16B_CS: u32,
    pub MB15_16B_ID: u32,
    pub CS23: u32,
    pub ID23: u32,
    pub MB15_16B_WORD2: u32,
    pub MB15_16B_WORD3: u32,
    pub CS24: u32,
    pub ID24: u32,
    pub MB16_16B_WORD0: u32,
    pub MB16_16B_WORD1: u32,
    pub CS25: u32,
    pub ID25: u32,
    pub MB10_32B_WORD0: u32,
    pub MB10_32B_WORD1: u32,
    pub CS26: u32,
    pub ID26: u32,
    pub MB10_32B_WORD4: u32,
    pub MB10_32B_WORD5: u32,
    pub CS27: u32,
    pub ID27: u32,
    pub MB11_32B_CS: u32,
    pub MB11_32B_ID: u32,
    pub CS28: u32,
    pub ID28: u32,
    pub MB11_32B_WORD2: u32,
    pub MB11_32B_WORD3: u32,
    pub CS29: u32,
    pub ID29: u32,
    pub MB11_32B_WORD6: u32,
    pub MB11_32B_WORD7: u32,
    pub CS30: u32,
    pub ID30: u32,
    pub MB12_32B_WORD0: u32,
    pub MB12_32B_WORD1: u32,
    pub CS31: u32,
    pub ID31: u32,
    pub MB12_32B_WORD4: u32,
    pub MB12_32B_WORD5: u32,
    pub CS32: u32,
    pub ID32: u32,
    pub MB13_32B_CS: u32,
    pub MB13_32B_ID: u32,
    pub CS33: u32,
    pub ID33: u32,
    pub MB13_32B_WORD2: u32,
    pub MB13_32B_WORD3: u32,
    pub CS34: u32,
    pub ID34: u32,
    pub MB13_32B_WORD6: u32,
    pub MB13_32B_WORD7: u32,
    pub CS35: u32,
    pub ID35: u32,
    pub MB14_32B_WORD0: u32,
    pub MB14_32B_WORD1: u32,
    pub CS36: u32,
    pub ID36: u32,
    pub MB14_32B_WORD4: u32,
    pub MB14_32B_WORD5: u32,
    pub CS37: u32,
    pub ID37: u32,
    pub MB15_32B_CS: u32,
    pub MB15_32B_ID: u32,
    pub CS38: u32,
    pub ID38: u32,
    pub MB15_32B_WORD2: u32,
    pub MB15_32B_WORD3: u32,
    pub CS39: u32,
    pub ID39: u32,
    pub MB15_32B_WORD6: u32,
    pub MB15_32B_WORD7: u32,
    pub CS40: u32,
    pub ID40: u32,
    pub MB16_32B_WORD0: u32,
    pub MB16_32B_WORD1: u32,
    pub CS41: u32,
    pub ID41: u32,
    pub MB16_32B_WORD4: u32,
    pub MB16_32B_WORD5: u32,
    pub CS42: u32,
    pub ID42: u32,
    pub MB17_32B_CS: u32,
    pub MB17_32B_ID: u32,
    pub CS43: u32,
    pub ID43: u32,
    pub MB17_32B_WORD2: u32,
    pub MB17_32B_WORD3: u32,
    pub CS44: u32,
    pub ID44: u32,
    pub MB17_32B_WORD6: u32,
    pub MB17_32B_WORD7: u32,
    pub CS45: u32,
    pub ID45: u32,
    pub MB10_64B_WORD0: u32,
    pub MB10_64B_WORD1: u32,
    pub CS46: u32,
    pub ID46: u32,
    pub MB10_64B_WORD4: u32,
    pub MB10_64B_WORD5: u32,
    pub CS47: u32,
    pub ID47: u32,
    pub MB10_64B_WORD8: u32,
    pub MB10_64B_WORD9: u32,
    pub CS48: u32,
    pub ID48: u32,
    pub MB10_64B_WORD12: u32,
    pub MB10_64B_WORD13: u32,
    pub CS49: u32,
    pub ID49: u32,
    pub MB11_64B_CS: u32,
    pub MB11_64B_ID: u32,
    pub CS50: u32,
    pub ID50: u32,
    pub MB11_64B_WORD2: u32,
    pub MB11_64B_WORD3: u32,
    pub CS51: u32,
    pub ID51: u32,
    pub MB11_64B_WORD6: u32,
    pub MB11_64B_WORD7: u32,
    pub CS52: u32,
    pub ID52: u32,
    pub MB11_64B_WORD10: u32,
    pub MB11_64B_WORD11: u32,
    pub CS53: u32,
    pub ID53: u32,
    pub MB11_64B_WORD14: u32,
    pub MB11_64B_WORD15: u32,
    pub CS54: u32,
    pub ID54: u32,
    pub MB12_64B_WORD0: u32,
    pub MB12_64B_WORD1: u32,
    pub CS55: u32,
    pub ID55: u32,
    pub MB12_64B_WORD4: u32,
    pub MB12_64B_WORD5: u32,
    pub CS56: u32,
    pub ID56: u32,
    pub MB12_64B_WORD8: u32,
    pub MB12_64B_WORD9: u32,
    pub CS57: u32,
    pub ID57: u32,
    pub MB12_64B_WORD12: u32,
    pub MB12_64B_WORD13: u32,
    pub CS58: u32,
    pub ID58: u32,
    pub MB13_64B_CS: u32,
    pub MB13_64B_ID: u32,
    pub CS59: u32,
    pub ID59: u32,
    pub MB13_64B_WORD2: u32,
    pub MB13_64B_WORD3: u32,
    pub CS60: u32,
    pub ID60: u32,
    pub MB13_64B_WORD6: u32,
    pub MB13_64B_WORD7: u32,
    pub CS61: u32,
    pub ID61: u32,
    pub MB13_64B_WORD10: u32,
    pub MB13_64B_WORD11: u32,
    pub CS62: u32,
    pub ID62: u32,
    pub MB13_64B_WORD14: u32,
    pub MB13_64B_WORD15: u32,
    pub CS63: u32,
    pub ID63: u32,
    pub MB63_8B_WORD0: u32,
    pub MB63_8B_WORD1: u32,
    pub RXIMR0: u32,
    pub RXIMR1: u32,
    pub RXIMR2: u32,
    pub RXIMR3: u32,
    pub RXIMR4: u32,
    pub RXIMR5: u32,
    pub RXIMR6: u32,
    pub RXIMR7: u32,
    pub RXIMR8: u32,
    pub RXIMR9: u32,
    pub RXIMR10: u32,
    pub RXIMR11: u32,
    pub RXIMR12: u32,
    pub RXIMR13: u32,
    pub RXIMR14: u32,
    pub RXIMR15: u32,
    pub RXIMR16: u32,
    pub RXIMR17: u32,
    pub RXIMR18: u32,
    pub RXIMR19: u32,
    pub RXIMR20: u32,
    pub RXIMR21: u32,
    pub RXIMR22: u32,
    pub RXIMR23: u32,
    pub RXIMR24: u32,
    pub RXIMR25: u32,
    pub RXIMR26: u32,
    pub RXIMR27: u32,
    pub RXIMR28: u32,
    pub RXIMR29: u32,
    pub RXIMR30: u32,
    pub RXIMR31: u32,
    pub RXIMR32: u32,
    pub RXIMR33: u32,
    pub RXIMR34: u32,
    pub RXIMR35: u32,
    pub RXIMR36: u32,
    pub RXIMR37: u32,
    pub RXIMR38: u32,
    pub RXIMR39: u32,
    pub RXIMR40: u32,
    pub RXIMR41: u32,
    pub RXIMR42: u32,
    pub RXIMR43: u32,
    pub RXIMR44: u32,
    pub RXIMR45: u32,
    pub RXIMR46: u32,
    pub RXIMR47: u32,
    pub RXIMR48: u32,
    pub RXIMR49: u32,
    pub RXIMR50: u32,
    pub RXIMR51: u32,
    pub RXIMR52: u32,
    pub RXIMR53: u32,
    pub RXIMR54: u32,
    pub RXIMR55: u32,
    pub RXIMR56: u32,
    pub RXIMR57: u32,
    pub RXIMR58: u32,
    pub RXIMR59: u32,
    pub RXIMR60: u32,
    pub RXIMR61: u32,
    pub RXIMR62: u32,
    pub RXIMR63: u32,
    pub EPRS: u32,
    pub ENCBT: u32,
    pub EDCBT: u32,
    pub ETDC: u32,
    pub FDCTRL: u32,
    pub FDCBT: u32,
    pub FDCRC: u32,
    pub ERFCR: u32,
    pub ERFIER: u32,
    pub ERFSR: u32,
    pub HR_TIME_STAMP0: u32,
    pub HR_TIME_STAMP1: u32,
    pub HR_TIME_STAMP2: u32,
    pub HR_TIME_STAMP3: u32,
    pub HR_TIME_STAMP4: u32,
    pub HR_TIME_STAMP5: u32,
    pub HR_TIME_STAMP6: u32,
    pub HR_TIME_STAMP7: u32,
    pub HR_TIME_STAMP8: u32,
    pub HR_TIME_STAMP9: u32,
    pub HR_TIME_STAMP10: u32,
    pub HR_TIME_STAMP11: u32,
    pub HR_TIME_STAMP12: u32,
    pub HR_TIME_STAMP13: u32,
    pub HR_TIME_STAMP14: u32,
    pub HR_TIME_STAMP15: u32,
    pub HR_TIME_STAMP16: u32,
    pub HR_TIME_STAMP17: u32,
    pub HR_TIME_STAMP18: u32,
    pub HR_TIME_STAMP19: u32,
    pub HR_TIME_STAMP20: u32,
    pub HR_TIME_STAMP21: u32,
    pub HR_TIME_STAMP22: u32,
    pub HR_TIME_STAMP23: u32,
    pub HR_TIME_STAMP24: u32,
    pub HR_TIME_STAMP25: u32,
    pub HR_TIME_STAMP26: u32,
    pub HR_TIME_STAMP27: u32,
    pub HR_TIME_STAMP28: u32,
    pub HR_TIME_STAMP29: u32,
    pub HR_TIME_STAMP30: u32,
    pub HR_TIME_STAMP31: u32,
    pub HR_TIME_STAMP32: u32,
    pub HR_TIME_STAMP33: u32,
    pub HR_TIME_STAMP34: u32,
    pub HR_TIME_STAMP35: u32,
    pub HR_TIME_STAMP36: u32,
    pub HR_TIME_STAMP37: u32,
    pub HR_TIME_STAMP38: u32,
    pub HR_TIME_STAMP39: u32,
    pub HR_TIME_STAMP40: u32,
    pub HR_TIME_STAMP41: u32,
    pub HR_TIME_STAMP42: u32,
    pub HR_TIME_STAMP43: u32,
    pub HR_TIME_STAMP44: u32,
    pub HR_TIME_STAMP45: u32,
    pub HR_TIME_STAMP46: u32,
    pub HR_TIME_STAMP47: u32,
    pub HR_TIME_STAMP48: u32,
    pub HR_TIME_STAMP49: u32,
    pub HR_TIME_STAMP50: u32,
    pub HR_TIME_STAMP51: u32,
    pub HR_TIME_STAMP52: u32,
    pub HR_TIME_STAMP53: u32,
    pub HR_TIME_STAMP54: u32,
    pub HR_TIME_STAMP55: u32,
    pub HR_TIME_STAMP56: u32,
    pub HR_TIME_STAMP57: u32,
    pub HR_TIME_STAMP58: u32,
    pub HR_TIME_STAMP59: u32,
    pub HR_TIME_STAMP60: u32,
    pub HR_TIME_STAMP61: u32,
    pub HR_TIME_STAMP62: u32,
    pub HR_TIME_STAMP63: u32,
    pub ERFFEL0: u32,
    pub ERFFEL1: u32,
    pub ERFFEL2: u32,
    pub ERFFEL3: u32,
    pub ERFFEL4: u32,
    pub ERFFEL5: u32,
    pub ERFFEL6: u32,
    pub ERFFEL7: u32,
    pub ERFFEL8: u32,
    pub ERFFEL9: u32,
    pub ERFFEL10: u32,
    pub ERFFEL11: u32,
    pub ERFFEL12: u32,
    pub ERFFEL13: u32,
    pub ERFFEL14: u32,
    pub ERFFEL15: u32,
    pub ERFFEL16: u32,
    pub ERFFEL17: u32,
    pub ERFFEL18: u32,
    pub ERFFEL19: u32,
    pub ERFFEL20: u32,
    pub ERFFEL21: u32,
    pub ERFFEL22: u32,
    pub ERFFEL23: u32,
    pub ERFFEL24: u32,
    pub ERFFEL25: u32,
    pub ERFFEL26: u32,
    pub ERFFEL27: u32,
    pub ERFFEL28: u32,
    pub ERFFEL29: u32,
    pub ERFFEL30: u32,
    pub ERFFEL31: u32,
    pub ERFFEL32: u32,
    pub ERFFEL33: u32,
    pub ERFFEL34: u32,
    pub ERFFEL35: u32,
    pub ERFFEL36: u32,
    pub ERFFEL37: u32,
    pub ERFFEL38: u32,
    pub ERFFEL39: u32,
    pub ERFFEL40: u32,
    pub ERFFEL41: u32,
    pub ERFFEL42: u32,
    pub ERFFEL43: u32,
    pub ERFFEL44: u32,
    pub ERFFEL45: u32,
    pub ERFFEL46: u32,
    pub ERFFEL47: u32,
    pub ERFFEL48: u32,
    pub ERFFEL49: u32,
    pub ERFFEL50: u32,
    pub ERFFEL51: u32,
    pub ERFFEL52: u32,
    pub ERFFEL53: u32,
    pub ERFFEL54: u32,
    pub ERFFEL55: u32,
    pub ERFFEL56: u32,
    pub ERFFEL57: u32,
    pub ERFFEL58: u32,
    pub ERFFEL59: u32,
    pub ERFFEL60: u32,
    pub ERFFEL61: u32,
    pub ERFFEL62: u32,
    pub ERFFEL63: u32,
    pub ERFFEL64: u32,
    pub ERFFEL65: u32,
    pub ERFFEL66: u32,
    pub ERFFEL67: u32,
    pub ERFFEL68: u32,
    pub ERFFEL69: u32,
    pub ERFFEL70: u32,
    pub ERFFEL71: u32,
    pub ERFFEL72: u32,
    pub ERFFEL73: u32,
    pub ERFFEL74: u32,
    pub ERFFEL75: u32,
    pub ERFFEL76: u32,
    pub ERFFEL77: u32,
    pub ERFFEL78: u32,
    pub ERFFEL79: u32,
    pub ERFFEL80: u32,
    pub ERFFEL81: u32,
    pub ERFFEL82: u32,
    pub ERFFEL83: u32,
    pub ERFFEL84: u32,
    pub ERFFEL85: u32,
    pub ERFFEL86: u32,
    pub ERFFEL87: u32,
    pub ERFFEL88: u32,
    pub ERFFEL89: u32,
    pub ERFFEL90: u32,
    pub ERFFEL91: u32,
    pub ERFFEL92: u32,
    pub ERFFEL93: u32,
    pub ERFFEL94: u32,
    pub ERFFEL95: u32,
    pub ERFFEL96: u32,
    pub ERFFEL97: u32,
    pub ERFFEL98: u32,
    pub ERFFEL99: u32,
    pub ERFFEL100: u32,
    pub ERFFEL101: u32,
    pub ERFFEL102: u32,
    pub ERFFEL103: u32,
    pub ERFFEL104: u32,
    pub ERFFEL105: u32,
    pub ERFFEL106: u32,
    pub ERFFEL107: u32,
    pub ERFFEL108: u32,
    pub ERFFEL109: u32,
    pub ERFFEL110: u32,
    pub ERFFEL111: u32,
    pub ERFFEL112: u32,
    pub ERFFEL113: u32,
    pub ERFFEL114: u32,
    pub ERFFEL115: u32,
    pub ERFFEL116: u32,
    pub ERFFEL117: u32,
    pub ERFFEL118: u32,
    pub ERFFEL119: u32,
    pub ERFFEL120: u32,
    pub ERFFEL121: u32,
    pub ERFFEL122: u32,
    pub ERFFEL123: u32,
    pub ERFFEL124: u32,
    pub ERFFEL125: u32,
    pub ERFFEL126: u32,
    pub ERFFEL127: u32,
}
#[cfg(not(feature = "nosync"))]
pub struct Instance {
    pub(crate) addr: u32,
    pub(crate) _marker: PhantomData<*const RegisterBlock>,
}
#[cfg(not(feature = "nosync"))]
impl ::core::ops::Deref for Instance {
    type Target = RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &RegisterBlock {
        unsafe { &*(self.addr as *const _) }
    }
}

unsafe impl Send for Instance {}
